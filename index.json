{
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | VPE Documentation",
    "keywords": "Changelog This documents all notable changes to the Visual Pinball Engine and its dependent projects. Unreleased Built with Unity 2022.3.x Added Free transformation (#500) Kinematic collisions (#460) Flipper tricks by nFozzy (#436) Asset Library now has thumbnails. Documentation for score reels. Score Motor Component (#435, Documentation). Scale support for rubbers. Slingarm coil arms can now be any game objects, not just primitives (#432). Gate Lifter Component (#418, Documentation). Asset Browser (#412) Trigger meshes can now be easily scaled (#374) We got a new game item called Metal Wire Guide (thanks @Cupiii, #366) A Collision Switch component (#344, Documentation). A Rotator component (#337, Documentation). A Teleporter component (#336, Documentation). A Drop Target Bank component (#333, Documentation). Editor: Enable manual trigger for coils, switches, lamps and wires during gameplay (#332) Support for dynamic wires, also known as Fast Flip (#330, Documentation). Component for light groups, allowing easy grouping of GI lamps. (#330 Documentation). Slingshot component (#329, Documentation). Create insert meshes (#320). Full support for custom playfield meshes. Remove Hybrid Renderer (#316). Create and use Unity assets when importing (#320). Native support for nFozzy flipper physics (#305). Automated camera clipping (#304). DMD and segment display support (Documentation). Plugin: Mission Pinball Framework (Documentation). Gamelogic Engine: Support for hardware rules (#293). Support for Extended ASCII strings (#291). Support for Elasticity Falloff in walls (added in VP 10.7) (#291). Support for table notes (added in VP 10.7) (#291). Slow motion during gameplay (#288). Lamp Manager (#282). The VPE core is now also available on NuGet. VPE is now packaged and published on every merge! Native trough component (#229, #248, #256, Documentation). Changed Removed DOTS in favor of Jobs with Burst (#459) All geometry is now in world space. Removed internal ID in gamelogic engine API (#408) When importing, meshes are now saved as easily editable .fbx files instead of Unity's internal format (#387). Revised rubber mesh generation (#384). APIs for RGB lamps and Visual Scripting (#382). Playfield is now rotated to the correct angle during gameplay (#370). Decouple light components from transformation override (#350). Refactored drag points. They are nicely separated and typed now. Collider debug view is now much faster and intuitive. It's also activated per default when there is no visible mesh. Drop and hit targets are now different components. Kicker is now a coil device with different coils for different angles/forces. Ground truth of data is now the scene, not the imported data anymore (#302). Plunger is now a coil device, meaning it can both be pulled back and fired through different inputs. Move render pipelines into separate repos (#259). Put game-, mesh-, collision- animation data into separate components (#227, Documentation). Fixed Disappearing objects due to wrong bounding box (#441). Default table import (#434) Remaining ball spinning issue should now be solved (#397). Physics error when the ball would stop rotate (#393). Finally, ball rotation is rendered correctly (#386). Ball stuttering when rolling over dropped target (#375). Plunger disappearing due to too small bounding box. Fixed switch status when multiple mappings point to the same ID (#347). Lighting setup. It's now usable (#330). Ball passing through collider plane and disappearing. Alpha channel of color values is now correctly written (#291). Layer names are correctly computed when importing a 10.6 file (#291). Clear texture and material references that don't exist before writing (VP 10.7 behavior) (#291). Bug in writing animation vertices which caused VP to hang when re-reading the file (#291). A few bugs in drag point gizmos (#246)."
  },
  "creators-guide/editor/advanced/camera-settings.html": {
    "href": "creators-guide/editor/advanced/camera-settings.html",
    "title": "Camera Settings | VPE Documentation",
    "keywords": "Camera Settings The editor camera controller is a tool designed to set different camera views during the editing and testing process. It allows the camera to be easily adjusted with a few sliders as well as allowing for the saving and loading of presets. The camera controller is setup to orbit around a focal point. While doing this it will automatically adjust the clipping planes on the camera to ensure the best quality shadows and highest precision sorting of transparent objects. Note In most 3D engines, a depth buffer us used for many rendering features such as shadows, transparency sorting and various post process effects. This buffer is a greyscale representation of the distance of a pixel from the camera. As such, it has a limited value range that must be spread to cover the entire scene. The larger the range, the less precision the buffer will have. By closely cropping the range, the precision can be increased. In using the camera controller this is handled automatically. If you add your own camera you will have to adjust this manually. Usage To use the camera controller, select the Camera scene object, which is at the very top of the hierarchy. In the inspector you will find a few sliders: Angle: Controls the angle of the camera to the table. A value of zero places the camera parallel to the table. A value of 90 places the camera perpendicular to the table. Offset XYZ: Moves the pivot point of the camera along the three world axis. X moves the camera left and right relative to where a player would stand. V moves it up and down and Z moves it forward and back. Angle, Distance and Orbit are always relative to this point. Distance: Moves the camera closer to or further away from the pivot point. This is used in conjunction with the FOV to frame the table in view. FOV: Sets the field of view of the camera. High values result in a wide field of view and more depth perspective. Low values narrow and flatten the view. Note Adjusting the distance and FOV together will control how much apparent depth there is to the table. A wide field of view and low distance will give the table a bit of perspective and depth, but will be more challenging to fit in the view without clipping the front, or having a lot of space to the sides in the back. Conversely, moving the camera further away and lowering the FOV will remove much of the perspective allowing the table to fit more evenly in the frame. Orbit: Controls the camera angle in an orbit around the table. 0 and 360 are standing in front of the table, 90 is on the left, 270 to the right. Presets Camera presets are stored camera settings that allow you to rapidly switch between different camera views. This can be useful when developing a table to view specific areas or just to take pretty screenshots. The preset slider changes between the stored camera views. There are three views included by default. Any preset can be overwritten by changing the parameters and clicking the Save button. If Save is not pressed, the values will be lost when you cycle to a new preset. New presets can be made by adjusting the values and clicking Clone. This preset will be added to the presets at the end. You can delete any preset by setting the slider to that preset and clicking the Delete button."
  },
  "creators-guide/editor/asset-library-styleguide.html": {
    "href": "creators-guide/editor/asset-library-styleguide.html",
    "title": "Asset Library Style Guide | VPE Documentation",
    "keywords": "Asset Library Style Guide This document serves as a comprehensive style guide for all 3D assets in the pinball asset library. Our goal is to maintain assets that are high quality, visually consistent, optimized for performance, and customizable. These guidelines should be followed for the vast majority of assets; exceptions can be made in special cases. Note Throughout this guide, you'll see examples highlighted in red and green. They signify whether you should follow these examples. That said, please consider this guide as work in progress. Design Language We're aiming for a photorealistic look, as opposed to stylized visuals. Shapes should match those in the real world and maintain accurate proportions and sizes. Target Hardware We're targeting desktop PC hardware. This means we should be able to make use of the latest graphics features while still being able to run on older hardware. Geometry Guidelines This section covers modeling practices, i.e. how to create meshes consisting of vertices, edges, and faces. Topology Topology describes how vertices and edges form the shapes of your model. While there are many ideas on best practices, here are the essentials for game-ready assets: Use quads where possible and avoid n-gons. Maintain clean topology with proper edge flow, if possible. Apply proper smoothing groups/hard edges for accurate normal calculation (shade smooth/flat in Blender). Avoid non-manifold geometry and floating vertices - make the mesh watertight. If you're converting CAD models which aren't polygon-based, you'll likely need to apply some retopology. The same applies to 3D scans. A STEP model imported into Blender (left), versus the re-modeled version (right). Poly Count In polygonal modeling, the poly count refers to the number of polygons used in a model. In game engines, quads and n-gons are converted to triangles, so we measure by the number of triangles. Higher triangle counts allow for more detail but increase rendering time. Follow these poly count guidelines: Small objects (e.g., spinners, drop targets) can typically stay under 500 triangles. Standard playfield objects (e.g., flippers, bumpers) can range from about 500 to 2,000 triangles. Hero pieces (large ramps, toys): higher counts are acceptable, but remain mindful of necessary detail. A gate bracket at 108 triangles (left), 420 (middle) and 906 triangles (right) Scale and Orientation Unity uses a left-handed coordinate system, where X points to the right, Y up, and Z forward. Your models should be oriented accordingly. The various orientations we're dealing with. For scale, use meters as your unit of measurement. It's crucial to model in real-world units to ensure correct proportions between assets, as improper scaling makes it difficult to accurately size components. Ensure that scaling is applied directly to the model's geometry, eliminating the need for rescaling within the game engine. Complexity While we encourage providing details that might only be visible when pivoting around the table, nobody will examine what's below the playfield or hidden inside of other meshes. Therefore, don't include geometry that won't be visible. A drop target with the entire footing which is hidden by the playfield on the right, and reduced on the left. Pivot Point The pivot point, also known as object origin or local origin, defines where your model appears for a given position in 3D space. Static objects should always have their vertical axis (the Y axis in Unity, or Z axis in VPX) of the pivot point at playfield height, so setting it to 0 will position the object on the playfield. Objects that rotate need their pivot point on the rotation axis. If such an object is parented to another (static) object, the parent should also have its vertical origin at playfield height. On the horizontal plane, the pivot point should be in the center unless the object's topology suggests another more logical position. A drop target with the origin placed at different locations. UV Maps All models must be UV-mapped. UVs should be unwrapped with minimal stretching. Maintain 2-4 pixel padding between UV islands to prevent texture bleeding. Keep UV shells proportional to their 3D size to maintain consistent texel density. Organize UVs within the 0-1 UV space. Decals If your model contains art that varies from instance to instance, use a decal mesh. Decals should be used where you would find literal decals or imprints in the real world. Examples include spinners, aprons, targets, and bumpers. On the right side you see two drop target meshes with their corresponding decal meshes in orange. The decal geometry should be in a separate object parented to the main object. The UVs of the decal mesh should be laid out in a way that allows its textures to be created with non-specialized image editors. Be sure to keep the aspect ratio without distortion when UV-mapping decals. Note Why Decals? Decals are great because they make your workflow more flexible and are at the same time more performant: Flexible, because it allows us to texture our models in a generic way so that they can be used in any context. Imagine a drop target with a star on it. Without decals, the star would be baked into the texture, and if anybody else would want reuse that target with different art on it, they would need to recreate the texture. With decals, they only need to swap out the decal texture. Performance, because Unity is optimized for having thousands of decals in a scene, allowing us to use higher-resolution textures for our decals without having to waste resources on the rest of the object. Colliders VPE uses separate meshes for collision for some items (currently drop targets and hit targets). These collider meshes should be included in the model. Their pivot point must align with the pivot point of the main mesh. The scale must be applied and correspond to the main mesh's scale. They shouldn't include any UVs. You can see a hit target mesh with its collider mesh in orange on the right side. LODs Regarding LODs (Levels of Detail), we're only using one LOD. This guideline is based on the compact size of the playfield, where most elements would be rendered at the same LOD anyway. Additionally, most assets will be under 1,000 triangles, making the performance impact of LODs minimal. File Format Export your meshes in a format supported by Unity. The preferred formats are glTF and FBX. Avoid .obj due to its limitations and inefficiency. Vendor-specific formats are also to avoid (even .blend), because they only can be imported if the corresponding 3D software is installed. Material Guidelines We use physically based rendering (PBR) for realistic visuals. In Unity HDRP, this generally means using the Lit Shader. Note We're still determining whether authors will be able to choose other shaders, create their own, or if usage will be restricted. We'll update this section as soon as we have more information. For now, we focus on authoring using the Lit Shader. Texture Maps In the PBR workflow, these texture maps are most relevant: Color map (also called diffuse or albedo map) Normal map (often called bump map) Metallic map Smoothness map (which is an inverted roughness map) Ambient occlusion map Unity also supports emissive maps, detail maps, and others depending on the material type, but we'll focus on those mentioned above. Color Maps The color map contains RGB values that represent surface color without lighting information. If your asset or parts of your asset exist in multiple color variations, consider using only gray tones and tinting the material with the Lit shader's base color. This approach makes it customizable without having to render out textures for each color variant (and is also more memory-efficient). A drop target with the same base material but different tints, and three different decal materials. As mentioned above, don't bake art that varies into the texture; use decals instead. Single-color decals that come in multiple color variations should also use a gray-tone color map and be tinted through the Decal Shader directly, making them more easily customizable without requiring multiple material instances. Normal Maps Normal Maps simulate lighting effects on surface details without adding geometry. Generally, if a detail doesn't have any silhouette-defining features and isn't deep enough to cast visible shadows, flatten it and bake it as a normal map. A playfield toy at 185k tris (left), 2.7k tris without normal map (middle) and with normal map (right). Edges are particularly important for achieving realistic visuals. In the real world, light always reflects off edges because they are never perfectly sharp. To simulate this, you should always bevel your edges. For models with few prominent edges, you can add bevels in the geometry. However, baking the bevel into a normal map is typically more efficient. A gate with beveled geometry at 3.6k tris (left), at 420 tris without normal map (middle) and with normal map (right). To summarize, use normal maps for: Surface details (scratches, small dents, panel seams) Shallow details (<5mm in real scale) Beveled edges Text or logo embossing Pattern detailing Metallic / Smoothness Maps With a metallic map, you can define on pixel level whether your material is metallic, or not. Only use this if your material covers both metallic and non-metallic parts of your model. Otherwise, use the metallicness property of the Lit Shader directly. You should only use values of 0 or 1, as partially metallic materials don't exist in the real world. The smoothness map (the inverse of a roughness map) defines how regularly light is reflected at the micro-surface level. A value of 1 behaves like a mirror, while a value of 0 is more like an eraser. Metallicness set to 1 with smoothness going from 0 to 1. Texture Map Resolution All texture maps must use power-of-two dimensions for width and height (e.g., 256, 512, 1024). They don't have to be square. We're aiming for a resolution of about 6 pixels per millimeter (approximately 150 DPI). For a playfield texture, this means roughly 4096×8192 pixels. Use this resolution when possible, but don't upscale images — the highest resolution should be from your source. This applies to both color and normal maps. For metallic/smoothness maps, half the resolution of the color map is a good balance between performance and visual fidelity. Note You can determine the resolution by looking at your UV map and the size of the asset. Let's take the gate from the previous section as an example. Take a large section of your mesh, and measure it. The larger, the more precise it will be. Here we're measuring the top surface, from where the bevel starts: Next, identify that section on your UV map, and note where in UV space they are: As you can see, they go from 0.360 to 0.955 on the X axis. In terms of dimensions, we now have the following: Width in UV space: 0.955 - 0.36 = 0.595 Width in real world space: 29.2mm At 6px / mm, that makes 6px × 29.2mm = 175.2px for the 0.595 UVs To get the resolution of the whole UV map: 175.2px / 0.592 = 296px So, a texture map at 296×296 would correspond to 6px / mm. Since we're at power of twos, we could go for either 512×512 or 256×256. Compression Export your texture maps in PNG format. Use 32-bit if they include an alpha channel; otherwise, 24-bit is sufficient. Use halved resolution for the mask map. Don't quantize / TinyPNG your maps, since together with the GPU's block compression they will result in artifacts. Note Many artists prefer to export their textures as TGA due to faster read/write speeds, but TGA files consume significantly more space. PNG uses lossless compression, and once imported, Unity stores textures in a GPU-friendly format anyway. Additionally, when exporting to the .vpe format, image textures are converted into a runtime-optimized format. In terms of packaging, Unity's HDRP stores metallic, ambient occlusion and smoothness in what they call a mask map. Substance Painter exports this out of the box, but it should be pretty easy to do with Blender as well. Wear Generally, all items should show visible signs of wear, rather than appearing brand new from the factory. This adds realism and character to the assets. They certainly have each their look. But in order to keep consistency, you should follow the example in the middle. Standard Materials Many materials in the asset library will appear in multiple assets. To keep a consistent look across all assets, you should use existing materials. We're providing Substance Painter Smart Materials for metals and plastics (and hopefully Blender versions as well). ℹ️ Table coming soon Attribution When submitting assets to the library, please include your name or handle for proper attribution. If you've adapted assets from other sources, ensure you have the necessary permissions and include appropriate credits. Where to Submit Don't submit yet! 😄 We're still figuring out the best structure and repository for our asset library (our current repo is getting too large). There will also be additional guidelines about metadata. This section will be updated when we're ready!"
  },
  "creators-guide/editor/asset-library.html": {
    "href": "creators-guide/editor/asset-library.html",
    "title": "Asset Library | VPE Documentation",
    "keywords": "Asset Library The asset library is a centrally maintained collection of pinball assets that table authors can use in their table builds. It comes with a browser, a tagging system, search and preview. Assets in this library are of high quality and customizable. We try our best to identify the source of each asset and attribute it to its creator(s). Note This is the creator's guide, so this documentation is aimed towards creators who are contributing to this library. Quality and Flexibility Each asset should be carefully crafted and be as customizable as possible, while having minimal impact on performance. So, let's dive into what this actually means. :) First, a few words about quality. Contributing All assets are free to use, and anybody can contribute to it. Material Separation When starting off, you usually already have some geometry, and in case you're about to contribute multiple assets, you're probably wondering how apply your materials. When dealing with multiple objects, there are generally two approaches how to apply materials to them. Let's say we want to add a bunch of hit targets. This is the geometry we have: With both approaches, these files will be generated: Hit Targets.fbx - The exported .fbx file. Hit Target - Rectangle.prefab - The Unity prefab of the rectangular hit target. Hit Target - Rectangle, Slim.prefab - The prefab of the slim hit target. Hit Target - Round.prefab - The round hit target Let's look at how the two approaches apply materials to these objects. Approach 1 - One material per object This way of applying materials is to use a single material for every object. This works best if no part of the object contains any transparency or subsurface scattering or any other special attributes that are not part of Unity's PBR workflow. The UV mapping in this case is quite standard - map the entire object to one texture set. After creating the materials and baking them out to the maps, it renders as if multiple materials were applied to the object, but technically, it's a single material: The base map, mask map and normal map of the rectangle hit target material. This would result in the following files: Drop Target - Rectangle.mat - The Unity material applied to the entire mesh Drop Target - Rectangle - BaseMap.png - The color map of the material Drop Target - Rectangle - MaskMap.png - The mask map of the material Drop Target - Rectangle - Normal.png - The normal map of the material Note For brevity, we'll skip the other two materials that cover the slim and round hit target. Approach 2 - Texture atlas Instead of grouping per object, we could also group by \"physical\" material, i.e. one material for the plastic, one for the metal, and one for the rubber, but applied to all three objects. Here are the texture maps for the plastic material. It's valid for all three hit targets, and what's called a texture atlas: This would result in the following files: Drop Targets - Plastic.mat - The Unity material Drop Targets - Plastic - BaseMap.png - The color map of the plastic material Drop Targets - Plastic - MaskMap.png - The mask map of the plastic material Drop Targets - Plastic - Normal.png - The normal map of the plastic material Note For brevity, we'll skip the other two materials that cover the metal and rubber material. Which Approach is Best? Both approaches have pros and cons. In terms of performance, the pros and cons depend on whether the scene (a pinball table) is likely to include many of the objects you're creating. If that's the case, then the better approach is #2, the texture atlas: Less draw calls, as multiple objects can share the same material and texture set. More optimized memory, since a single material and texture set can be more efficient than multiple individual materials and textures. More batching-friendly, as objects using the same material can be dynamically batched by Unity. There is also a non-technical advantage: It's easier to create variations of your materials. For instance, if you want to create a worn version of the plastic, you'd simply bake out a new set of maps which you can then apply independently to your objects, versus having to do it individually for each object. However, if the objects are less likely to be all present in the scene, then approach #1 probably the better choice: More optimized memory, since none of the textures are unused Easier UV-mapping, since UV-mapping multiple objects to a single map can be more challenging and less trivial to understand than to a single object. In general practice, for small objects that have lots of variations and that are likely to find themselves together on the same table, we're using a texture atlas. This includes screws, rods, washers, spacers, posts, and so on. For more complex objects, we're using a single material or even multiple materials per object. This includes bumpers, targets, flippers, gates, spinners, etc. These are generally objects that don't have any variation per table. Naming Conventions Asset naming is somehow important because it can help the user figure out the relations between assets. There are several things to name: Prefab - The name of the Unity prefab that shows up in the asset browser. Model File - The model file, i.e. the .fbx or .obj files. Material Slot - The names of the material slots within the model file. Unity Material - The name of the material within Unity. Texture File - The name of the various maps generated per material. Note There is also the original model source of the program used to model, e.g. Blender. How to name this is up to the user, since that's not typically a file that is part of the project. However, for the asset library, we're including the .blend files, and they have a naming convention, too. To complicate things more, the relations between prefabs, models, and materials can different. A model file can contain multiple meshes, e.g. we keep all VPX gates in one .fbx file. A prefab might consists of multiple meshes, sometimes from multiple files, e.g. the bumper ring and base are common in many bumper variations. A mesh might use multiple materials, but a material can also be used for multiple meshes (see the two aproaches above). A material usually uses multiple textures, or maps, but in the vast majority of cases, these maps are specific to the material. Prefabs Prefabs are the files that appear in the asset library. They link the mesh together with the materials and the Unity components necessary for the prefab to work. We name them as descriptively as possible: <prefab description> (<prefab variation>) The <prefab description> goes from more to less specific, using commas. The <prefab variation> is the least specific part of the description. If an asset is an original VPX asset, <prefab variation> is \"VPX\". Examples: Bumpers/Williams/Bumper (Williams).prefab Kickers/VPX/Kicker, Cup 2 (VPX).prefab Hardware/6 Gauge/Hex Nut, Flanged (6-32).prefab Posts/Plastic Posts/Post, Plastic, Star, Double, Rubber Rings, Collidable (1.0625in).prefab Model Files Model files are what's exported from your 3D software. They are usually .fbx, .glb or .obj files, although .fbx is (still) recommended. These are where Unity pulls the mesh data from. Their naming isn't essential since they are rarely user facing, and we usually keep only one model file per folder, so they're named after their folder name, but still in a way it makes it clear what they are. Examples: Bumpers/Williams/Bumper (Williams).fbx Kickers/VPX/Kicker, Cup 2.fbx Hardware/6 Gauge/Hardware 6-gauge.fbx Posts/Plastic Posts/Plastic Posts.fbx Material Slots Material slots are how the materials in the model file are named. If you're using Substance Painter, that's the default way how your generated maps will be named. However, this is only relevant if you're using multiple materials for an object, since one-object materials (approach 1 above) have the same name as the prefab. For texture atlases, the slots should be named as short as possible and describe the material, for example Base for the bumper base, or Cap. For materials that cover the entire object, they should be named like the object. Unity Materials Unity materials are visible by the table creators, so it's important to name them in a way that makes clear what they are. Depending on whether you're using texture atlases or not, they should include the name of the material. Examples: Bumpers/Williams/Bumper (Williams) - Base.mat Bumpers/Williams/Bumper (Williams) - Ring.mat Kickers/VPX/Kicker, Cup 2.mat Hardware/6 Gauge/Hardware 6-gauge - Metal.mat Hardware/6 Gauge/Hardware 6-gauge - Nylon.mat Posts/Plastic Posts/Plastic Post - Metal.mat Posts/Plastic Posts/Plastic Post - Plastic, Red.mat Posts/Plastic Posts/Plastic Post - Plastic, Yellow.mat Texture Maps Texture files are closely related to a material, so we'll name them the same and append the type of map. Examples: Bumpers/Williams/Bumper (Williams) - Base - BaseMap.png Bumpers/Williams/Bumper (Williams) - Base - Normal.png Kickers/VPX/Kicker, Cup 2 - BaseMap.png Hardware/6 Gauge/Hardware 6-gauge - Metal - BaseMap.png Posts/Plastic Posts/Plastic Post - Plastic, Red - MaskMap.png Posts/Plastic Posts/Plastic Post - Plastic, Red - Normal.png"
  },
  "creators-guide/editor/coil-manager.html": {
    "href": "creators-guide/editor/coil-manager.html",
    "title": "Coil Manager | VPE Documentation",
    "keywords": "Coil Manager On a real pinball table most moving parts, including the flippers, are triggered by coils (also called solenoids). In VPE it's the job of the gamelogic engine to trigger them when needed. Just as the coils are physically wired to the power driver board on a regular machine they can be virtually connected in VPE using the coil manager under Visual Pinball -> Coil Manager. Setup Every row in the coil manager corresponds to a logical wire going from a gamelogic engine output to the coil. As with switches, a single coil can be linked to multiple outputs, and an output can be linked to multiple coils. IDs The first column, ID shows the name that the gamelogic engine exports for each coil. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the coil names, you can also add coil IDs manually, but that should be the exception. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the coil name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Destination The Destination column defines where the element in the following column is located. There are three options: Playfield lets you select a game element on the playfield that features the coil Device lets you choose a coil device, a mechanism which may include multiple coils, such as a trough. Lamp sets the coil to be configured in the lamp manager (see flashers in the lamp manager for more details). Element The Element column is where you choose which specifc element in the destination column should be activated. VPE can receive coil events for bumpers, flippers, kickers and plungers and coil devices. Note Bumpers are currently hard-wired, i.e. their switch will directly trigger the coil without going through the gamelogic engine. That means they don't need to be configured in the switch or coil manager. VPE will make this configurable in the future. Runtime During runtime, you'll see the coil statuses update in real-time. Clicking on the icon manually toggles the coil, which can be handy for debugging."
  },
  "creators-guide/editor/lamp-manager.html": {
    "href": "creators-guide/editor/lamp-manager.html",
    "title": "Lamp Manager | VPE Documentation",
    "keywords": "Lamp Manager VPE uses the Unity game engine to accurately simulate the many types of lamps a real pinball machine might use, and connect them to the gamelogic engine. Lamps have a standard set of parameters, which can be tweaked in the editor. Lamps in a game are dynamic, so the gamelogic engine can toggle them, fade them, and even change their color. To link each of the playfield lamps to the gamelogic engine and configure how they behave during gameplay, the Lamp Manager is used. You can find it under Pinball -> Lamp Manager. Note We use the terms lights and lamps as follows: With light we're referring to one of the Unity rendering engine's lights. It's a simulated light source which doesn't have to be a physical element on the table, but can also refer to the sun, some directional scene light, or other types of lighting used in the rendering. With lamp we're referring to a virtual \"bulb\" that is present on the table. It's a logical component VPE uses during gameplay, decoupled from the actual visual display. About Lamps Physical machines have many different implementations when it comes to lighting. The vast majority of solid state machines from the 1970s until the early 2010s used a lamp matrix, where lamps were addressed by row/column, and each individual lamp could only be fully on or off. Historically, incandescent light bulbs were used, which resulted in a brief warm-up period until they reached full brightness (and a cool-down period when turned off). To simulate this, VPE adopted the fade-in and fade-out properties for lights from Visual Pinball. Later machines used single colored LEDs that were each directly connected to a controller board (see also: Lights vs LEDs). Unlike matrix lamps, the intensity of LEDs could be finely controlled by the game software. More recently, games started using RGB-LEDs that can change color as well as brightness during gameplay. In VPE, these can be handled in two different ways: As three single connections from the gamelogic engine, one for each color channel (this is what PinMAME provides, for example.) With a single RGB connection, where the gamelogic engine always provides the full color (used by MPF, or custom table logic.) Additionally, most pinball machines come with GI strands, which are a set of bulbs used for global illumination of the playfield. All lights in a strand are addressed at once, so one gamelogic GI strand maps to multiple lamps on the playfield. Finally, some high-powered lamps such as flashers may appear under the gamelogic engine's coil outputs, since those lamps operate on higher voltage and have the same properties as coils. Setup Every row in the lamp manager corresponds to a logical connection between the gamelogic engine and a lamp on the playfield. A lamp may be linked to multiple outputs, and an output can be linked to multiple lamps. IDs The first column, ID shows the name that the gamelogic engine exports for each lamp. Note Since we cannot be 100% sure that the gamelogic engine has accurate data about the lamp names, you can also add lamp IDs manually, but that should be the exception. Description The Description column is optional. If you're setting up a recreation, you would typically use this for the lamp name from the manual. It's purely for your own benefit, and you can leave this empty if you want. Source GI lights can be emitted as a different type of light from the gamelogic engine. Set the source here in order to prevent conflicts of matching IDs between normal lights and GI lights. Type The Type column defines how the signal is interpreted by the lamp. This is important, because the gamelogic engine typically sends integer values to the lamp. There are four types: Single On|Off - Typically lamps from the lamp matrix. They can only be on or off. Receiving 0 will turn the lamp off, any other value will turn it on. Single Fading - Individual lamps which can be dimmed by the gamelogic engine. Received values can range from 0 to 255, where 0 turns the lamp off, and 255 sets it to full intensity. RGB Multi - An RGB lamp that can change its color during gameplay. Lamps of this type receive three connections, one from each red, green and blue. Each color channel receives values as a fading lamp. RGB - An RGB lamp that receives its data from a single connection. This is the only mode where the lamp doesn't receive an integer, but an entire color value. Element Under the Element column, you choose which lamp among the game items on the playfield should be controlled. Channel If the type of the previous column has been set to RGB Multi, here is where you define which color channel this output corresponds to. Max. Intensity For fading lights, VPE expects values between 0 and 255. However, GI light have usually less variations, typically eight. This column is only enabled for GI lights, and the value is the highest value for a given GI strand that the gamelogic engine will emit. Flashers When using a gamelogic engine that simulates real hardware such as PinMAME, high-powered lamps like flashers usually show up as coils connected to the driver board. To support this VPE allows routing coil outputs to lamps. For that, go to the Coil Manager and select Lamp as Destination: This will make the coil show up in the lamp manager where you can configure it: Note that you cannot change the ID of the lamp, because it's still linked to the coil. Also, removing or changing the coil destination will remove the entry from the lamp manager. Changing the ID in the coil manager will also update it in the lamp manager. GI Strands In Visual Pinball, you can put GI lamps into a collection and address the whole collection at once via script. VPE provides light groups as a similar feature. Editor vs Runtime While editing the table in the Unity editor, you may find it helpful to disable lamps you're not editing. You can quickly do that with the top-right controls, which allow you to toggle selectively GIs, inserts, flashers, lamps selected in the manager, or all lamps. You can also quickly select the light source to quickly edit multiple lights. During runtime, VPE first turns all lamps off, then turns on the constant lamps, and then transfers control of the lamps to the gamelogic engine. If you are running the game in the editor, the lamp manager shows the lamp statuses in real time: During gameplay you can also click on the lamp icon to toggle the lamp. This can be handy for debugging."
  },
  "creators-guide/editor/materials.html": {
    "href": "creators-guide/editor/materials.html",
    "title": "Materials | VPE Documentation",
    "keywords": "Materials Materials are what you apply to an object in order to make it look or behave like something in the real world. Materials are one of the key components of a table, because they define the visuals and the physical behavior. However, the term material can be confusing, because it can have different meanings. So let's define them first. Rendered Materials We refer to rendered materials just as materials. They describe how a surface of a mesh is drawn on the sceen. In Unity, materials and shaders are closely linked - every material uses a shader, which you can configure. The most common shader is the Lit shader, which works well for rigid materials that interact with light. A material typically includes one or more textures that define the color, normals, roughness, metalness and many more parameters on a per-pixel basis. Note In Visual Pinball, materials don't include the texture. Instead, the texture is applied on a per-object basis. Physics Materials We refer to how the material interacts with the ball during the physics simulation as the physics material. It has these properties: Elasticity - The bounciness, how much the ball is thrown back when it collides. Elasticity Falloff - Pinball tables have a lot of rubber parts, and rubber has a special attribute: it gets less bouncy when hit at higher velocity. The falloff parameter controls how much. Friction - How much friction is applied when the ball rolls along this material. Scatter - Adds a random factor to the collision angle. Physics materials are a way to group common behavior among certain objects, but contrarily to rendered materials, you can also not assign a physics material to an object and set each of those four parameters individually. Note In Visual Pinball, the physical parameters are part of the rendered material, so there is only one notion of material. Conversion from Visual Pinball As mentioned above, there are two differences between Visual Pinball and VPE how materials are handled: VPE includes textures in the material, while Visual Pinball does not. VPE differentiates between rendered and the physical material. When importing a .vpx file, VPE converts the \"visual part\" of Visual Pinball materials into materials for the current render pipeline. It does that by creating a new material for every material/texture combination in Visual Pinball. The materials are then written to the Materials asset folder of the imported table where they can be easily edited and referenced. Since Visual Pinball uses different shaders than Unity, the results of the conversion are approximations and should be heavily tweaked. Since VPE uses the same physics engine as Visual Pinball, the physical values of the materials don't need to be converted, they are copied 1:1 into a new physics material and saved in the asset folder."
  },
  "creators-guide/editor/multiple-tables.html": {
    "href": "creators-guide/editor/multiple-tables.html",
    "title": "Working with Multiple Tables | VPE Documentation",
    "keywords": "Working with Multiple Tables When working on a creation, you might want to load other tables to pick assets from. For that, Visual Pinball lets you open multiple tables allowing to switch and copy elements between them relatively quickly. With VPE, you can create or import multiple tables into your scene. VPE's manager panels will switch context when an element from a different table is selected in either the Scene view or the Hierarchy. Tip You can lock a manager window to the selected table by clicking on the small lock in the top right corner: Warning We don't have multi-table support during runtime yet. The idea is that in the future, you would be able to select which table is the runtime table. Warning Moving elements between multiple tables is not implemented yet, there is an open issue."
  },
  "creators-guide/editor/switch-manager.html": {
    "href": "creators-guide/editor/switch-manager.html",
    "title": "Switch Manager | VPE Documentation",
    "keywords": "Switch Manager During gameplay, the gamelogic engine needs to know what is happening on the playfield. For that, real pinball tables have switches on the playfield that signal when a ball rolls over or settles in a certain position. These switches are also built into targets, bumpers, kickers, and other mechanisms (see Supported Game Mechanisms below). Wiring these switches up to the gamelogic engine with code can be a tedious process, so VPE provides a graphical interface where you can do it easily. If you've named them appropriately it can even guess which switch maps to which game item. You can open the switch manager under Pinball -> Switch Manager. Switch matrix from Medieval Madness. Setup Imagine every row as a wire connecting the physical switch to the gamelogic engine. The relation between the two is 0..n -> 0..n, meaning you can link multiple switches to one input or a single switch to multiple inputs. IDs The first column ID shows the names of each switch that the gamelogic engine is aware of. There are two values to fill out here: The first, the dropdown value, is the ID that VPE will use to identify the switch. The second, an integer value, is the ID the gamelogic engine is using. This allows the gamelogic engine to make certain switches more explicit. For example, PinMAME has the same switch mapping all ROMs of a given game. These switches have a readable ID, which then translates into the numeric \"magic value\" that PinMAME uses internally. Global PinMAME switches of WPC games. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the switch names, you can also add switch IDs yourself, but those should be the exception. NC The \"NC\" stands for Normally Closed. In short, enabling this inverts the value sent to the gamelogic engine. As for the long explanation, think about how switches work. Mechanical switches are usually normally open (NO), meaning they are open by default and close when the ball rolls over them (or, if it's a button, when the button is pressed). But some switches behave differently. In opto-switches for instance, the light beam closes the circuit by default, and a ball rolling through it (and thus blocking the light) opens the switch. These type of switches are normally closed (NC). Note In the very first screenshot, you'll notice that the trough switches are normally closed. This is because MM uses a modern trough with opto-switches. There is also the coin door we'd like to have closed by default and open the switch when the coin door is open. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the switch name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Source The Source column defines where the element in the following column originates. There are four options: Playfield lets you choose a game item from the playfield Input System lets you choose an input action from a pre-defined list, e.g. cabinet switches Constant sets the switch once at the beginning of the game to the given value. Device lets you choose a switch device containing the switch. Switch devices are mechanisms that include multiple switches, for example troughs. Element The Element column is where you choose which element triggers the switch. For Playfield sources, you can choose a game item that triggers switch events. Currently, VPE only emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. Note We realize that you might want to use other game items like ramps and walls to emit switch events as well, and we will address this at some point, but for now we're keeping it simple. If Input System is selected, you choose which input action to use (it's an \"action\", because it's not an permanent key binding). Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device, then there are two values to select. The actual switch device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you choose the value that will be permanently set at the beginning of the game. Pulse Delay Internally, VPE connects switches to events. For example, a trigger on the playfield has a Hit event, which occurs when the ball rolls into the trigger's collision zone, and an UnHit event when the ball leaves that zone. These two events close and open the trigger's switch. However, not all mechanisms behave like that. For example a spinner emits a single Spin event. So to prevent the switch from being closed indefinitely VPE automatically re-opens it after a given delay. We call that the Pulse Delay. \"Pulse\", because it gets triggered by one event and reopens after a brief delay. In most cases, you can leave the default delay of 250ms. What's important is that the gamelogic engine gets notified not too long after the switch was closed. Note that if pulse delay is set to 0, the switch will stay closed. Supported Game Mechanisms Below a list of game mechanisms that contain built-in switches. Closes Opens Bumper On ball collision After pulse delay Flipper On EOS, i.e. when the flipper reaches its end position When the flipper switch is opened, i.e. the flipper starts moving down again Gate When ball is passing through the gate When ball has passed through Target On collision After pulse delay Kicker When ball enters the kicker When ball's outside the kicker Spinner On each spin After pulse delay Trigger When the ball rolls over the trigger When the ball is outside of the trigger Runtime During runtime, you'll see the switch statuses update in real-time. Clicking on the icon manually toggles the switch, which can be handy for debugging."
  },
  "creators-guide/editor/units-3d-space.html": {
    "href": "creators-guide/editor/units-3d-space.html",
    "title": "Units and 3D Space | VPE Documentation",
    "keywords": "Units and 3D Space Units describe how we measure things. For example, the units for measuring length are meters in the metric system, or feet and inches in the imperial system. There are also different systems for saving 3D data. For example, in VPX, the x-axis points to the right side of the player, the y-axis down, and the z-axis towards the player. We call this the orientation and handedness of the coordinate system. Different software uses different units and orientations, and this section describes how VPE handles them. We'll also compare how VPX and VPE handle transformations. Units If you've already used VPX, you know that it uses its own units, defined by the ball size: In VPX, 50 units correspond to the ball diameter. A ball being 1¹⁄₁₆ inch, we get the following relations: 50 VP units = 1.0625\" 1 VP unit = 0.02125\" = 0.53975mm or 1\" = 47.05882352941176 VP units 1mm = 1.852709587772117 VP units Obviously, no other 3D software uses these units, so importing models from, let's say, Blender, has always been a pain. The problem is that if we wanted to just scale everything down to meters, it would impact physics because physics is strongly dependent on the real-world size (and thus, mass) of things. Given that VPE uses VPX's physics code, which has been fine-tuned with heuristics based on VPX units, we cannot simply scale everything to real-world units and expect the same behavior in the physics simulation. So, we've chosen the following approach: Everything in the scene uses real-world units (meters). During runtime, 3D data is converted to VPX units for the physics simulation. New movement data from the physics engine is converted back and applied to real-world units. Note VPX Units in the Editor Meters for elements on a pinball table which is under two meters long isn't necessarily the best unit either. The best would have been millimeters, but Unity's units aren't configurable. Because of this and the fact that many table authors are still familiar with VPX units, VPE includes VPX units in the panel of each component. Updating one will automatically update the other. Real world (top) and VPX (bottom) units in the editor Orientation and Handedness As mentioned at the beginning, the coordinate system of VPX is oriented with the Z-axis up and the origin at the top-left corner of the table. It's a left-handed coordinate system. Blender, on the other hand (no pun intended), also has the Z-axis pointing up, but its Y-axis is pointing in the opposite direction, making it right-handed. Unity's coordinate system is left-handed like VPX, but oriented differently. Since the player is usually looking forward, that's where the XY plane lies. So, Y points upwards, X to the right, and Z away from the player. The main impact for you as a table author is that you need to pay attention when exporting your meshes from other 3D software. For example, when exporting to FBX in Blender, you need to make sure that the following mapping is set (the default Forward being -Z Forward): Forward -> Z-Forward Up -> Y-Up Transformations We call it a transformation when we move, rotate, or scale an object. Let's talk about how VPX and VPE handle transformations. In VPX, the XY position within the playfield can be freely set for all items. For the Z-position, some objects allow free positioning, some can be parented to a surface (wall or ramp), and others have a fixed Z-position. Regarding rotation, some items, like spinners or gates, can be Z-rotated, some can be freely rotated, and some can't be rotated at all. Scaling support in VPX is more sparse, with most objects not being able to scale at all or only on a given axis. Note This is not to look down on VPX's transformation capabilities; they make sense in the vast majority of cases, but it's important to highlight them so we can understand how they differ from VPE. For quite a while, VPE implemented the same restrictions as VPX, and we spent considerable time overriding Unity's transformation tools to adhere to those limitations. However, as a user, you could always work around them, often accidentally, by either disabling gizmos in the editor or by simply parenting an item to another object and freely transforming the parent (the child always inherits transformation of its parent). If that happened, the result would be a rather incoherent mess because the visuals wouldn't correspond to the physics simulation, which was still bound by those limits. So, we ended up implementing full transformation support for VPE. That means you can freely position, rotate, and scale all items. You can also parent items to other objects and transform those objects. Or the parents of those objects. In short, however the transformation hierarchy of your scene is, VPE will boil it down to one transformation during runtime, check for each item whether the physics engine supports the resulting transformation, and if not, apply the ball projection trick during a collision. Runtime Transformations In VPX, transformations are static. That means they cannot be changed during runtime. Obviously, a flipper rotates during runtime, but the object itself is fixed in place. Some games, however, require some form of movement. In VPX, that's worked around by creating multiple invisible collider objects that are then toggled depending on the position of the object. That's, of course, very cumbersome and error-prone. In VPE, we've extended the physics engine to be able to mark objects are movable. If an object is marked as such, it can be fully transformed during gameplay, and the colliders are updated accordingly. Note Note that currently, moving objects don't have a velocity, meaning that hitting a moving object only takes into account the speed of the ball, not the object's. It's like the object is teleported frame by frame to its new position. True collision where the object's directional and angular speed is calculated based off the last frame's position and the current one is a feature that is valuable and on the roadmap."
  },
  "creators-guide/editor/unity-components.html": {
    "href": "creators-guide/editor/unity-components.html",
    "title": "Unity Components | VPE Documentation",
    "keywords": "Unity Components When loading or creating a table in Unity, what you're creating is a hierarchy of GameObjects, the basic building blocks of Unity scenes. By default we group game items by their type when importing, but you can arrange them however you want. To give the GameObjects behavior during gameplay, we add components onto them. VPE comes with a large number of components that are used to set up and control the game mechanisms of the table, and advanced programmers can contibute new ones. If you've never heard about GameObjects or components, we recommmend you read through the links in the first two paragraphs. They are short, to the point, and a much better introduction than we could provide here. Components vs Game Items In Visual Pinball, components are what you see in the options panel when you click on a game item. You'll typically find sections for adjusting physical behavior, visual display, and geometric shape of the game item you're editing. Internally, all of these sections belong to the same game item. In VPE, we have separate components for each of these sections. There are four different types of components: The Main Component represents the actual game item. A Collider Component adds physical behavior to the game item. It defines how the item interacts with other objects, for example what bounciness, friction and randomness is applied to a pinball hitting the item. Mesh Components generate meshes, i.e. the geometry used to render the object on the playfield. The results are the procedurally generated 3D objects rendered in the scene. Animation components apply movement to the game item. If the entire object is moving (for example a flipper), that is handled by the collision component, but for items where only parts move (e.g. the plate of a gate, or the ring of a bumper) these components apply the movement to the GameObject. Let's look at a flipper: Here, we see the main component (Flipper), the collider component (Flipper Collider), and two mesh components (Flipper Base Mesh and Flipper Rubber Mesh) inside VPE compared to Visual Pinball. While the main and collider component sit on the base GameObject, each mesh component is on its own child GameObject. This is how Unity works - a GameObject only contains one component of each type."
  },
  "creators-guide/editor/wire-manager.html": {
    "href": "creators-guide/editor/wire-manager.html",
    "title": "Wire Manager | VPE Documentation",
    "keywords": "Wire Manager Using the Switch Manager, you can wire playfield and cabinet switches to the Gamelogic Engine. Similarly, the Coil Manager and Lamp Manager let you connect playfield elements to the outputs of the Gamelogic Engine. The Wire Manager allows you to bypass the gamelogic engine and connect switches directly to coils and lamps. Using the dynamic wires, this can be used to eliminate the flipper lag often introduced by emulated ROMs. But it also can be useful for debugging, or for game logic that might not be covered by the gamelogic engine. You can open the wire manager under Pinball -> Wire Manager. Setup Every row in the wire manager's table corresponds to a connection between a switch and an element that takes an input. You can connect multiple switches to one element or a single switch to multiple elements. In the following, we call the switch the source and the element it is connected to the destination. Description The first column Description is optional. It can help better organize all the connections, but can be left empty if you want. Source The Source column defines the type of source you are connecting to. There are four types: Playfield lets you select any game item that qualifies as a source from the playfield. Input System lets you select an input action from a pre-defined list, e.g. cabinet switches. Constant sets the destination to a constant value. Device lets you select a source device. Such devices are mechanisms that include multiple sources, for example troughs. Source Element The Source Element column is where you select which element acts as the source. For Playfield sources, you can select a game item that triggers switch events. Currently, VPE emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. If Input System is selected, you select which input action to use. Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device, then there are two values to select. The actual source device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you select the value that will be permanently set at the beginning of the game. This might me useful for lamps that are always on. Destination Under Destination you can select the type of the element that will receive the switch changes. There are two types to choose from: Playfield lets you select any game item that qualifies as a destination from the playfield Device lets you choose a destination device. Such devices are mechanisms that include multiple coils or lamps, for example troughs. Destination Element The Destination Element column is where you select which specific element in the destination column should receive switch changes. If Device was selected in the previous column, both the actual device and the element within the device have to be selected. Dynamic By checking the Dynamic box, the wire dynamically enables and disables depending on the gamelogic engine's output. Used with flippers, this feature is also known as Fast Flip and can be used to reduce the lag introduced by an emulated gamelogic engine like PinMAME. If it's enabled and a game is started, VPE compares the switches and coils linked to the gamelogic engine and tries to find the switch and coil IDs that correspond to the wire. If found, VPE monitors the coil signals of the gamelogic engine. If the time between the switch and the coil response is below a threshold, the wire is enabled and future coil signals from the gamelogic engine are discarded. In the same way, if the wire is active and no coil signal is received within the threshold, the wire is disabled again. Note In order to match the switch and coil signals from the gamelogic engine, the switch and the coil need to be linked to the gamelogic engine using the Switch Manager and Coil Manager respectively. For example, it's not sufficient to just create a flipper button -> flipper coil wire and not link the flipper button to the flipper switch and the flipper coil to the flipper. There are a few edge cases that are handled as well. For example, if the wire is active and the gamelogic engine enables the coil without a switch signal (like the Phantom Flip in Monster Bash), the coil event is not discarded (VPE internally keeps a queue of switch events and if the queue is empty, coil events are still processed). However, by design, there are two caveats: When the wire is inactive, the first event always has the gamelogic engine lag, since VPE will only activate the wire when it's sure a coil event is emitted. When the gamelogic engine stops emitting coil events, VPE continues emitting the coil event one more time until it discovers the absence of the coil event and thus sends the negative signal after the threshold to \"undo\" its mistake. Note MPF has a similar feature called Hardware Rules. This is the preferred way, because the gamelogic engine explicitly notifies VPE about which wires to add and remove during gameplay. However, other gamelogic engines like PinMAME don't have this feature, that's why VPE comes with the dynamic wire feature that guesses when wire is active and when not. Pulse Delay Internally, VPE connects switches to events. Some switchable game items only emit the switch closed event. Such items are spinners and targets. These are elements where the re-opening of the switch does not have any semantic value. In order for those to not stay closed forever, VPE closes them after a given delay. We call this the Pulse Delay. This field is only visible if the input source is a pulse-driven source. Runtime During runtime, you'll see the wire statuses update in real-time. Clicking on the icon manually toggles the wire, which can be handy for debugging."
  },
  "creators-guide/introduction/features.html": {
    "href": "creators-guide/introduction/features.html",
    "title": "Features | VPE Documentation",
    "keywords": "Features This section documents what's already working. If it's not, then that's a bug, and you should let us know. Materials We convert Visual Pinball's materials to materials compatible with the active render pipeline. That means materials look similar to Visual Pinball by default, while there's still a lot of potential left to tweak materials using the full material configuration of Unity. Bord's \"Viking\" rendered in VPX (left) and imported as-is in VPE's built-in renderer (right). Meshes Visual Pinball dynamically generates meshes for most of the game items. VPE has ported that code and does the same when loading a table. A rubber mesh generated in the editor Physics We have nearly finished porting Visual Pinball's physics engine to VPE. That means the ball and flipper behavior should be identical to Visual Pinball. This includes physics-based movement from flippers, gates and spinners, as well as animated targets, triggers and plungers. Events The physics engine emits the same events as Visual Pinball. That means you can subscribe to collision events and other game item-specific events. For example, for subscribing to the flip event of a flipper, you would do: table.Flipper(\"LeftFlipper\").LimitEos += (sender, args) => { // do something! }; Note While it's not clear how we'll handle scripting, most events can probably be configured visually in the editor and don't need to be handled via scripting. Cross Platform Unity supports a lot of platforms. Our continuous integration builds for Windows (x86/x64), macOS (x64) and Linux (x64). Besides Windows, some of our developers work on macOS, and we regularly test on Linux as well. File Format We care about backwards-compatibility to Visual Pinball. VPE can read and write .vpx files and supports the full data set. This means that you can load a table into VPE, edit it, export it to .vpx and load it back into Visual Pinball. Note VPE will at some point need to save additional data that isn't available in Visual Pinball. However, the .vpx structure is like a virtual file system, so we can do that without breaking backwards-compatibility. Editor Extensions Unity allows full editor customization. So we're adding the managers, panels, and toolboxes from Visual Pinball into the Unity editor: What you're seeing here is the toolbox as well as a few manager windows we've ported: Material Manager Image Manager Layer Manager Inspector acting as VP's Options Panel You can dock these as you wish, or even undock them and move them to another monitor. Not in the above screenshot but also ported are: Collections Manager Sound Manager VPE is also able to edit drag points. Moving those (in 3D!) re-generates the mesh on the fly: Lastly, we can visualize the colliders of any object. This can be useful to debug, and also to check whether you may have objects set to collide which actually shouldn't (or vice versa)! Patching System There are common patterns for VPX tables that are obsolete in VPE. For instance, VPE doesn't need a flipper shadow mesh, because it can do dynamic lighting out of the box. For that reason, we have a simple but sophisticated patcher system that allows us to apply changes to a table when imported. Of course the changes don't apply to the table data itself but to how we convert it into the Unity scene. You can read more about it here. Display Support VPE provides high-quality rendering of dot matrix and segment displays. Displays can be placed anywhere in the scene, multiple at once, and are easily linked to the game logic engine. For DMDs, dot size, shape and color can be customized, and for segment displays it's the segment weight, skew angle and color."
  },
  "creators-guide/introduction/overview.html": {
    "href": "creators-guide/introduction/overview.html",
    "title": "Overview | VPE Documentation",
    "keywords": "Overview The Visual Pinball Engine (which we call \"VPE\") is an open-source pinball simulator that you can use to create pinball games for Windows, macOS, and Linux. It's based on the famous Visual Pinball (often abbreviated \"VP\" or \"VPX\" for its latest version 10), meaning VPE's physics simulation matches that in VPX, and it can read and write the same file format. VPE uses Unity for its underlying game architecture. Unity is one of the leading cross-platform game engines and provides VPE with an advanced render pipeline that produces high-quality visuals and is continuously maintained and updated to work with new hardware features. Unity also comes with a fantastic editor, which VPE extends to make the table creation process as easy as possible. An imported .vpx file in VPE, using Unitys' High Definition Render Pipeline. Gottlieb's Volley, remodeled and retextured in Unity Audience This documentation is mainly aimed at table creators (\"authors\"). VPE is currently not in a state where it is usable by the general public (\"players\"). Documentation about how to set up VPE to play will follow at a later stage."
  },
  "creators-guide/manual/displays.html": {
    "href": "creators-guide/manual/displays.html",
    "title": "Displays | VPE Documentation",
    "keywords": "Displays Every pinball machine has one or more displays where the score and other important information is shown. In the 80s, mostly numeric 7-segment displays where used, which transitioned in the 90s to alpha-numeric 16-segment and dot matrix displays. A dot matrix display used in the late 90s - Photo © 2009 by ElHeineken VPE supports score reels used in the earliest electro-mechanical machines, as well as segment displays and dot matrix displays (usually referred to as DMDs). During game play displays are driven by the Gamelogic Engine. VPE supports multiple displays per game. Note Many of today's machines are using high resolution LCDs, which are not yet supported in VPE. Setup Displays are lazily bound, meaning that when the game starts, the gamelogic engine announces its displays and VPE connects them to objects in your scene that actually render them. Matching is done with an ID and depends on how the gamelogic engine being used manages displays. For example, in MPF you name your displays yourself in the machine configuration, while PinMAME uses IDs like dmd0 and display0 to identify its DMDs and segment displays. With Visual scripting, you define your own display IDs that must match with the displays on the playfield. Editor VPE provides three display components, a score reel, a segment display and a DMD. Both the segment display and the DMD component create the underlying geometry and apply a shader that renders the content of the display. In order to create one, make an empty game object in your scene and add the desired component under Pinball -> Display. You can also create the game object with a component already assigned by right-clicking in the hierarchy and choosing Pinball -> Dot Matrix Display. This will place the display into your scene right behind your playfield. Selecting the game object will let you customize it in the inspector, and assign the ID that links it to the gamelogic engine. Runtime The inspector allows you customize parameters controlling the geometry of the display like DMD resolution or number of segment columns in the editor. This is useful, because it allows you to see the correct geometry without running the game and place the display where it fits in the scene. However, during runtime these parameters are provided by the gamelogic engine and the displays will be reconfigured as soon as they are received. This means that if you've set the wrong number of chars in your segment display, it will be resized at runtime and look different than the version in the editor. Note There are additional settings that don't affect geometry that aren't configurable in the editor but will be automatically set during gameplay, such as number of segments per column."
  },
  "creators-guide/manual/gamelogic-engine.html": {
    "href": "creators-guide/manual/gamelogic-engine.html",
    "title": "Gamelogic Engine | VPE Documentation",
    "keywords": "Gamelogic Engine When playing a pinball game, some part of the table is driving the gameplay, i.e. deciding when to flip a coil, turn on a light, show something on the DMD, and so on. In VPE, we call this the Gamelogic Engine. The gamelogic engine is purely gameplay driven. It gets input from switches, computes what will happen next, and updates the hardware components of the table. It does not handle game mechanics, which are about simulating the hardware behavior of the table - it just toggles it. Classic examples of gamelogic engines are MPF and PinMAME. Note Let's take a spinning wheel on the playfield as an example. The gamelogic engine's job is to know when to turn it on and off. The game mechanics component of the spinning wheel is about rotating the actual playfield element with the right speed, acceleration, and handle ball collisions with a given friction. At the moment it's still unclear how VPE will deal with game mechanics. Initially, we will ship a bunch of game mechanics ready to use, and the future will tell how authors can create their own. In Visual Pinball, the gamelogic engine is part of the table script, which in most cases uses VPM to drive the game. So a part of the table script is about piping data into VPM and handling its outputs (lamp changes, coil changes, and so on). Since VPE defines a clear API (like a contract) between the table and the gamelogic engine, we can provide tools to make this easy for you. Currently, VPE provides: A Switch Manager A Lamp Manager A Coil Manager These tools provide a graphical user interface where you can link playfield elements to the gamelogic engine and configure them. Ultimately, that means if your table uses an existing gamelogic engine like MPF or PinMAME, and the table doesn't contain any exotic game mechanics, that's all you need to do. You can set up your table without a single line of code!"
  },
  "creators-guide/manual/manual.html": {
    "href": "creators-guide/manual/manual.html",
    "title": "Manual | VPE Documentation",
    "keywords": "Manual This section will document the following: Game Items Pinball Mechanisms Scripting Physics Plugins Sound"
  },
  "creators-guide/manual/mechanisms/collision-switches.html": {
    "href": "creators-guide/manual/mechanisms/collision-switches.html",
    "title": "Collision Switches | VPE Documentation",
    "keywords": "Collision Switches A Collision Switch turns a hittable game object into a switch device. Examples of hittable game objects are walls, rubbers, and primitives. Setup To create a Collision Switch: Add the collision switch directly to a hittable game object. Select the game object you want to add it to, click on Add Component in the inspector and select Pinball -> Mechs -> Collision Switch. To associate the collision switch with a game logic engine switch, use the Switch Manager and select the switch in the Element column: Runtime During gameplay, the inspector shows you the status of the switch."
  },
  "creators-guide/manual/mechanisms/drop-target-banks.html": {
    "href": "creators-guide/manual/mechanisms/drop-target-banks.html",
    "title": "Drop Target Banks | VPE Documentation",
    "keywords": "Drop Target Banks A Drop Target Bank is a collection of one or more drop targets that are reset (raised) when a coil is fired. Setup You can create a Drop Target Bank in two different ways. If your game has a single bank drop target, or multiple single bank drop targets, it is preferred to add it directly to the drop target. Select the drop target you want to add it to, click on Add Component in the inspector and select Pinball -> Mechs -> Drop Target Bank. If your game has drop target banks with multiple drop targets, click on Drop Target Bank in the toolbox. This will add a Drop Target Banks hierarchy to the playfield and create a new GameObject with the right component assigned. To configure the drop target bank, select the total number of drop targets from the Banks drop down. Then, under Playfield Links, select each drop target belonging to the bank. To configure the reset coil, use the Coil Manager and associate the corresponding game logic engine coil with the Reset Coil exposed by the drop target bank: Runtime During gameplay, the inspector shows you switch information for each of the drop targets. You can also drop or reset a drop target by using the Drop and Reset buttons. To test resetting a drop target bank from the Coil Manager, click the icon next to the corresponding reset coil."
  },
  "creators-guide/manual/mechanisms/flippers.html": {
    "href": "creators-guide/manual/mechanisms/flippers.html",
    "title": "Flipper | VPE Documentation",
    "keywords": "Flipper How flippers interact with the ball is what makes or breaks a pinball simulation. A few years ago, a community member named Mukuste spent time on improving Visual Pinball's flipper mechanics. The result was what has become known as the physmod, which provided a much more realistic simulation, and was later merged into Visual Pinball's main branch. In his own words: Flippers are now simulated as true dynamic rigid bodies which have forces from the solenoid, the return spring and the ball acting on them and accelerate accordingly. They will also properly bounce off their stoppers instead of just moving to maximum extension and then stopping. In practice, this means that flipper/ball interaction is now much more realistic and less binary. Post passes, light taps, cradle separations, drop and live catches are now all possible. Furthermore, the simulation of the friction of the flipper rubbers greatly improves aiming. Later, another member of the community named nFozzy managed to measure ball trajectory angles on real pinball machines, and developed a script where authors could provide a profile that would slightly adjust the ball trajectories during game play to match his measurements. This resulted in tables with the most realistic flipper behavior the community has produced yet. VPE's default flipper behavior is identical to Visual Pinball's. However, VPE also provides native support for the nFozzy adjustments. Setup The easiest way to create a flipper is clicking on the flipper icon in the toolbar. This will instantiate a flipper prefab and place it on the playfield. Mesh VPE provides a procedurally generated flipper mesh. It consist of a base mesh (the plastic bat), and a rubber mesh. It's possible to provide a custom mesh for the flipper by replacing the game objects used to generate the procedural meshes. However, the physics simulation will still use the original colliders, so make sure to adapt the parameters to match the custom flipper's dimensions. Physics Adding the Flipper Collider component to the flipper makes it part of the physics simulation. Here you can tweak the various parameters. Most of the following is taken directly from Mukuste's Wiki. Mass This is the mass of the flipper (where 1 corresponds to standard ball mass, 80g). It basically describes how much the flipper interacts with the ball. A very heavy flipper will barely feel the impact of the ball and keep moving at almost the same velocity as it was before the contact. A very light flipper, on the other hand, will move more slowly with the ball on it than it does without, and will be significantly deflected by the impact of a ball. Strength This is the force (actually torque) with which the solenoid accelerates the flipper. The higher this value, the faster the flipper will move. Be aware that this is directly linked to flipper mass; if the flipper is twice as heavy, it also needs twice the force to get it to accelerate at the same rate. Elasticity and Elasticity Falloff This is basically the bounciness of the flipper rubber. Since real rubber is less bouncy when it is hit at a higher velocity, the Falloff parameter allows decreasing the elasticity for fast impacts. A value of 0 for falloff means no falloff, i.e. elasticity is independant of velocity, and a value of 1.0 means that elasticity is halved at an impact velocity of 1 m/s. Friction This describes how much the rubber \"grips\" the ball. This value is very important for enabling center shots on the playfield with a moving ball, as well as backhands. In general it affects the aiming on all shots, but also makes a spinning ball deflect off the flipper in the proper direction. Return Strength Ratio This is the force of the return spring which pulls the flipper back down, relative to the solenoid force which pulls the flipper forward. For instance, at 0.10, the force of the return spring will be 1/10th of that of the solenoid. Due to how acceleration and velocity work, the time the flipper needs to return to its home position is about three times longer than that for the forward stroke in this example (square root of 10, to be precise). If you make this smaller, not only will the flipper return slower, but it will also pick up less speed if you briefly release the flipper and then press it again since it has less time to accelerate. A smaller value therefore makes it easier to do flipper tricks which involve light taps, such as cradle separations and flick passes. Coil Ramp Up This simulates the fact that the magnetic field in the flipper solenoid takes a while to build up when the flipper button is pressed, and to fall off again when the button is released (also known as hysteresis). This means that the flipper will not have its full acceleration immediately as the coil needs some time to ramp up to the full magnetic field. At a value of 0, there is no ramp up, and the full acceleration takes effect immediately. At a nonzero value, this is the relative time the solenoid needs to reach its full acceleration. For instance, if set to 3, the flipper coil will take around 30 ms to ramp up to full force. Gameplay-wise, the effect of this parameter is most strongly felt in situations where the flipper button is pressed only for a very short time, or released for a short time and then pressed again. In other words, it will make light taps much easier and therefore help with moves such as cradle separations and flick passes. Even tap passes can be achieved with the proper setting. Note that increasing this setting will decrease the speed of the flipper a bit and may need to be compensated with a higher Strength setting. Also, if this parameter is set too high, the flipper may feel sluggish and laggy. EOS Torque and Angle The \"end of stroke\" torque is the force that holds the flipper up once it reached the end position. The angle defines how many degrees from the end position that force is applied. Flipper Correction This is where you can set a profile for nFozzy's flipper physics. Profiles are files in your asset folder that you can create and modify. VPE ships with three profiles based on nFozzy's measurements that cover the solid state era of pinball machines. EM machines usually don't need flipper correction. Clicking on a flipper correction profile in your project window shows this in the inspector: You can see that it consists of two curves, one describing the corrected velocity magnitude, and one the corrected x-axis of the velocity. Both curves are relative to ball position on the flipper, and normalized to the flipper length. Additionally, there is a threshold in milliseconds since the flipper was fired, after which no corrections will be applied. You can tweak these curves by clicking on them in the inspector. However you cannot edit VPE's default profiles directly, you must copy it to the table's asset folder first (and of course, assign the new copy to your flippers). Polarity Correction Curve Velocity Correction Curve When applying one of default profiles, you should also adjust the flipper parameters in order to obtain realistic ball behavior. We've also added a column with good values for EM machines that don't need correction. Late 70s to mid 80s Mid 80s to early 90s Mid 90s and later EMs Mass 1 1 1 1 Strength 1400-1600 (1500) 2000-2600 3200-3300 (3250) 500-1000 (750) Elasticity 0.88 0.88 0.88 0.88 Elasticity Falloff 0.15 0.15 0.15 0.15 Friction 0.9 0.9 0.9 0.8-0.9 Return Strength 0.09 0.07 0.055 0.11 Coil Ramp Up 2.5 2.5 2.5 2.5 Scatter Angle 0 0 0 0 EOS Torque 0.3 0.275 0.275 0.3 EOS Torque Angle 4 6 6 4 Common Gotchas Flipper Length A common mistake is incorrect flipper length. A 3-inch flipper with rubbers will be about 3.125 inches long. This translates to about 147 VP units. Therefore, the flipper start radius + the flipper length + the flipper end radius should equal approximately 147 VP units. -> API Reference"
  },
  "creators-guide/manual/mechanisms/lifting-gates.html": {
    "href": "creators-guide/manual/mechanisms/lifting-gates.html",
    "title": "Lifting Gates | VPE Documentation",
    "keywords": "Lifting Gates Photo © 2022 by bord Some Gottlieb and Bally games use gates that can be activated and deactivated. It does that by connecting a stem to the wire that lifts it up so the ball can pass through in both directions. The stem is attached to a relay. When the relay is turned on, the one-way gate becomes a two-way gate. VPE provides a component that you can add to your existing gate. By doing that, it creates a new coil device that you can then map in the Coil Manager. Setup In order to add the lifting gate feature to a gate, select the game object of the gate and click on Add Component in the inspector. Select it by searching or navigating to Pinball -> Mechs -> Gate Lifter. Lifting Angle How many degrees the wire rotates up to the deactivated position. About 15° should work well for most geometry. Animation Speed How fast the gate rotates from and into the decativated position. Higher is faster. 0.1 seems a reasonable value. Usage Adding the gate lifter component adds a coil input to the gate, i.e. you can map it to any of the gamelogic engine's coil outputs through the Coil Manager. Note If you're working on an EM game or an original game with Visual Scripting, don't forget to add the new coil to the coil definitions."
  },
  "creators-guide/manual/mechanisms/light-groups.html": {
    "href": "creators-guide/manual/mechanisms/light-groups.html",
    "title": "Light Groups | VPE Documentation",
    "keywords": "Light Groups Sometimes, a game addresses multiple physical lights as one logical lamp, i.e. all lights are always toggled or faded at the same time. Typical use cases are GI strips. Instead of creating a link in the Lamp Manager for each light separately, VPE ships with a component called Lamp Group. A light group is a component you can add to any GameObject. It's recommended to make it parent of the light objects it contains, but you can also keep it outside of the lights hierarchy, since it explicitly references the lights it contains. Setup To create a new light group, select the GameObject you want to add your light group to, and in the inspector click on Add Component and choose Pinball -> Game Item -> Light Group. Then use the list control to add and remove lights. There are a few buttons that make this easier. Add Children In case you have parented the light groups component to the light GameObjects it should include, this button adds all child lights to the list. Existing lights will remain. Replace With Children Similar to Add Children, only that the list is cleared before adding new lights. Clear Simply clears the list. Select Light Sources When working with lights, the GameObject with the actual light source is nested within the main object. This can make adjusting light settings for multiple lights tedious, since you have to drill into each parent in order to select the source. This button selects all the source GameObjects for the lights in the light group."
  },
  "creators-guide/manual/mechanisms/rotators.html": {
    "href": "creators-guide/manual/mechanisms/rotators.html",
    "title": "Rotators | VPE Documentation",
    "keywords": "Rotators Sometimes during gameplay, you might need to rotate objects in order to recreate certain mechanisms. Like Visual Pinball, VPE doesn't support dynamic colliders (yet), but visually, objects can still be rotated. Rotators in VPE are components that allow you to easily rotate objects around the Z-axis. The Rotator component is applied to a target, which will then rotate around its local origin (typically the position on the playfield). Additional objects can be linked to rotate around the same axis at the same time. Setup In order to create a rotator, add the Rotator component to a game object by clicking Add Component in the inspector, then choosing Pinball -> Game Item -> Rotator. You can use any game object, although we recommend adding it to the target that you want to rotate. Target Just adding the component to your target game object won't automatically rotate the target. You need to explicitly assign it in the Target field. Rotate With Add other objects that rotate along with your target here. Currently, the following game items are supported: Primitives - Apart from the position, the object rotation of the primitive is updated. Note that in case your primitive has collision enabled, the colliders will not rotate along with the rendered object. Kickers - Rotating kickers applies the new angle to the kicker coils, and if a kicker contains a ball, the ball is rotated along as well. Flippers - Rotating flippers updates the start angle of the flipper. Usage When adding a Rotator component to a game object, it provides a float input that other components can use to rotate the object. Currently, only the step rotator mech makes use of this input. However, the step rotator will probably be replaced by a more generic system soon, so we won't go into more details here."
  },
  "creators-guide/manual/mechanisms/score-motors.html": {
    "href": "creators-guide/manual/mechanisms/score-motors.html",
    "title": "Score Motors | VPE Documentation",
    "keywords": "Score Motors Score motors are used in electro-mechanical games to add points to a player's score. They consist of multiple cams that are stacked on top of each other. Each cam has different patterns around the edges, and switches sit at different positions in order to open or close at specific times when the motor runs and thus the cams rotate. A typical score motor, found in Gottlieb and early Bally machines. The score motor assembly sits typically at the bottom of the cabinet. The produced switch sequences are used when the game needs to do several things in a specific order. Although its main purpose is triggering the score reel relays, it is often used to drive other mechanisms as well. Scoring in an EM There are two different modes of operation: The player scores single points, e.g. one, ten, hundred, and so on. In this case, a pulse is directly sent to the coil driving the corresponding score wheel, which increases its position by one. The player scores multiple points, like five, twenty, or 300. In this case, the score motor starts and the appropriate numbers of coil pulses are triggered by the switches around cams. For example, if a player scores fifty points, the score motor runs and enables the ten point relay to pulse five times. With each pulse of the ten point relay, the 10's score reel coil fires, which advances the score reel one position. Another property of a score motor is that it has no state, i.e. it doesn't know the actual score. This means that while the motor is running and the player scores multiple points, they are ignored. For single points, it depends on the machine, some allow single-point scoring while the motor is running, some don't. Note For an in-depth look at score motors, check out the fantastic article Animated Score Motor circuits from EM Pinball Machines at Fun With Pinball. Player Experience The way the scoring works results in a very particular timing of when exactly the score reels move during the game. Since in most games, chimes and bells are fired when the reel position changes, the player not only sees, but also hears these patterns. This means that accurate timing is essential for an authentic gaming experience. Setup VPE provides a component that accurately simulates the behavior described above. It handles score resets and add points, all while performing accurate timing that can be specified by the table author. To setup a score motor, select any game object, click on Add Component in the inspector and select Pinball -> Mechs -> Score Motor. Next, configure the score motor. The inspector shows the following options: Steps defines how many steps the score motor pulses for one turn. Duration defines the length of time it takes the score motor to completely cycle. Block Scoring defines if single point scoring is blocked while the score motor is running. As mentioned before, multiple point scores are always blocked while the score motor is running. Increase by # defines the behavior of the score motor for all of its the possible outputs. This gives the table author control over the timing and execution of Wait (pause) or Increase (add points) actions. The example in the screenshot shows a motor where when the player scores 30 points, it pulses on the first three actions of the score motor. Note The minimum amount of Steps for a score motor is 5. Increase by 5 will not be shown under Reel timing by increase if Steps is set to 5, as all actions would be Increase. By default, the score motor is configured to: 6 Steps 769 ms total run time Next, associate the score motor with the score reel display by selecting it in its inspector. Usage Score motors are primarily used in EMs, so we'll focus on how to use them in Visual Scripting. Programming a game with a score motor is a bit more complicated than with traditional displays for one reason: Scores might get blocked due to the motor being active, so you cannot solely rely on a score variable being updated. To make this less cumbersome, we've added an On Display Changed node that emits the actual value of the display when it has been updated (after potentially blocking scores). Give you've already set up your score reel display, the recommended approach is the following: Add an Add Score event in the Visual Scripting GLE's inspector. Add a Score player variable in the same inspector. In your graph, whenever you do scoring, use a Trigger Pinball Event node and set the Add Score event to be emitted. In your graph, at a centralized location, create an On Pinball Event node, select the Add Score event, and link it to an Update Display node. Just beneath, add an On Display Changed node, select your score reel, and link the node to Set Player Variable node, with Score to be updated. Use the Clear Display node when the game starts, in order to reset the score reels to zero. This setup allows you to: Easily add scores in your game logic by triggering an Add Score event. Subscribe to the Score variable in order to trigger score-dependent game logic, while taking into consideration eventually blocked scores by the motor. Warning If you're working on an original EM game, make sure to only emit scores that a score motor can actually handle. For example, it's impossible to score anything higher than five points (or 50, 500, ...) at once. It's also impossible to score a combination of multiple points at once, like 150. Finally, you might want to hook up other events to the score motor's behavior. For example, in Gottlieb's Volley, some lamps are toggled off while the motor is running. In order to achieve that, the score motor component exposes two switches: The Motor Running switch is activated when the motors starts and deactivated when it stops. The Motor Step Switch pulses on each step. In order to hook into those switches, you'll have to create them in the GLE inspector and link them to the corresponding switches in the Switch Manager. Then, in your graphs, add your logic behind the corresponding On Switch Changed node(s)."
  },
  "creators-guide/manual/mechanisms/score-reels.html": {
    "href": "creators-guide/manual/mechanisms/score-reels.html",
    "title": "Score Reels | VPE Documentation",
    "keywords": "Score Reel Displays In electro-mechanical games, score reels are very common for displaying the player score. Typically, four to six units are mounted behind the backglass. Each reel is driven by a coil that advances the reel by one position when pulsed. The coils are driven by the playfield elements in the game, often indirectly through a score motor for multi-point scoring. VPE includes components that simulate the score motor and render the score reel animation. This page is about the score reel, which presents itself to the GLE as a display that takes in the \"numerical\" frame format (i.e. numbers only). The score motor is an optional component that provides accurate timing when animating the reels. Setup Typically you would drop the desired score reel variant from the asset library into your scene. But you can also set it up manually: A score reel display consists of two separate components. The Score Reel Display component, which represents the logical display that takes in a number and then sets the reels to display that number. The Score Reel component, which represents one single reel and handles the animation. Model The best geometry for a score reel is a simple, open cylinder. Make sure the local origin is in the middle, and that it rotates around the Z-axis. The texture should contain the numbers 0-9, each taking up 36°. The order (and thus the direction of rotation) depends on the game, so both are valid, and can be configured later. Scene In your scene, drop in your reel model and add the Score Reel component (not the Score Reel Display component) to the game object. You can find it under Pinball -> Display. Since you'll need the same reel for each position, the best approach is to create a prefab for the reel and instance it for each position. Then, parent them under a game object that acts as your display. To this object, add the Score Reel component (also under Visual Pinball -> Display). Components Score Reel The Score Reel component is quick to set up. There is only one option, which is the rotation direction. What the score reel component gets from the display component is \"turn to position X\", where X is between 0 and 9, and the component's job is to animate the reel to that position. Internally, it also takes in the rotation speed, and how long it rests at the final position before it can advance to the next position. However, those parameters are not exposed in the inspector but retrieved from the display component described in the next section. Score Reel Display This is the component on the parent game object that receives score numbers from the game and tells the individual reels to which position they need to turn to. ID defines the display ID. Remember that displays are connected at runtime, so this is the identifier that the GLE uses to send data to it. Speed defines how quickly the reels should rotate. Wait indicates the time the reels stand still before they can go to the next position. Under Reel Objects you define your reels (they are not automatically retrieved from the children). The order is from largest to smallest, i.e. from left to right. The Score Motor is an optional reference to a score motor component. Usage Gamelogic Engine Score reels are primarily used in EMs, so they are typically driven by Visual Scripting. As with every display, the first step is to define the display in the GLE component. Add a new display under Displays and set the same ID as you did in the display component. The Width and Height properties are ignored, since they are managed by the display component (contrarily to the other displays, where the size is given by the GLE). Next, add Numeric under Supported Formats. Visual Scripting In Visual Scripting, use the Update Display node to set a new score. It's up to you whether to use a separate event or to subscribe to a player variable directly. If you're using a score motor, read how to set it up correctly here."
  },
  "creators-guide/manual/mechanisms/slingshots.html": {
    "href": "creators-guide/manual/mechanisms/slingshots.html",
    "title": "Slingshots | VPE Documentation",
    "keywords": "Slingshots Slingshots are most commonly located just above the flippers. They usually consist of two \"blade\" switches on the inner side of a triangular rubber. Between the switches there is a coil driven arm that propels the ball away from the slingshot when either switch closes. Visual Pinball doesn't have an explicit slingshot element. Instead, it relies on walls with a segment marked as slingshot, which generates an additional force being applied to the ball when the segment is hit. However, the rubber animation is up to the table script to implement. VPE does provide a slingshot component that implements the rubber animation during runtime. This allows for functional slingshots without any additional code. However, this approach isn't ideal and will be replaced with a proper slingshot element in the future. Setup Slingshot Wall In order to trigger the animation, the slingshot component needs a reference to the wall which has one of the control points set to slingshot. Rubbers VPE animates the control points of the rubber by interpolating between a start position to an end position and then back to the start over the duration of the animation. To set the start and end positions of the control points, we reference two rubber elements (which must have the same number of control points.) In the inspector, Rubber Off indicates the rubber representing the start position, and Rubber On the end position. Note In VPX, tables often come with three rubbers elements that are toggled in order to fake an animation. When using VPE's slingshot component, you can delete the rubber at mid position, since only the start and end rubbers are used. The interpolation is calculated in real time depending on the speed of the slingshot. Coil Arm On physical machines, the rubber is moved by an arm attached to the coil. VPE can simulate the movement of that arm by rotating a primitive across the X-axis. In the Coil Arm field, a reference to the primive can be set, and the total angle of rotation under Arm Angle. Animation The animation has two parameters: The duration in milliseconds, and the curve. The curve represents the position in function of time and covers both directions of travel. This allows non-linear movement of the rubber. Test With the test slider you can easily preview how the rubber and arm are animated. Howto Set Up a Slingshot from an Imported Table This howto uses the blank table, but other tables should be similar. Usually, slingshots consist of three rubbers for the animation, plus a wall for the physics. We need the following elements: The wall with a segment set to slingshot The rubber at idle position The rubber at activated position Optionally, the coil arm that pushes the rubber Note that both rubbers must have the same number of drag points. This is because during the animation, the rubber is linearly interpolated between the two drag points positions, which isn't possible if the number differs. When converting a table from Visual Pinball, that means that you may need to add additional drag points to the rubber at idle position. 1. Identify and clean up the elements Zoom in to the slingshot you want to set up. You'll probably want to temporily hide the plastic that covers up the rubbers and the wall. Find the rubber at idle position and at activated position. Delete the rubber in-between, we don't need that one. Note the names of those rubbers. Here it's LSling and LSling1. Also look for the the coil arm, which is called Sling2, as well as wall that acts as the physical slingshot, here LeftSlingShot. 2. Add additional control points if necessary Now, since LSling1 is bent and thus contains three additional control points, we'll add the same points to LSling. We can now also can hide the meshes of the rubbers. 3. Add the slingshot component In the Toolbox, click on the Slingshot icon, which will create a new element in the scene. Rename it and link the elements we've identified in step 1: Slingshot Wall links to LeftSlingShot Rubber Off links to LSling Rubber On links to LSling1 The slingshot component is now able to create the mesh. The animation can be tested with the Test slider. 4. Setup the coil arm animation Since the rubber is pushed inside by the arm, the arm should be animated along with the rubber. This can be a bit fiddly, since the arm should be as close to the rubber as possible without clipping through it. Move the Test slider all to the right, and play with the X-Rotation of the coil arm. Once you're happy, copy the angle to the clipboard. Then, select the slingshot. In the inspector, set the following fields: Coil Arm links to the primitive, in our case Sling2. Arm Angle is the angle when the coil is enabled. Paste the angle you've copied before. Now, when moving the Test slider, the arm should animate along with the rubbers. 5. Wrap-up and test Before final testing, there are two things left to do: Select the coil arm and disable the collider Enable the plastic we hid in step 1. Then hit play and have a game!"
  },
  "creators-guide/manual/mechanisms/teleporters.html": {
    "href": "creators-guide/manual/mechanisms/teleporters.html",
    "title": "Teleporters | VPE Documentation",
    "keywords": "Teleporters Sometimes it's easier to teleport the ball from one place to another instead of setting up the physical environment to simulate the actual movement. VPE provides a simple component that destroys a ball at kicker A and creates a new one at kicker B. Note Please note that you shouldn't be using teleporters when the ball is visible, because it breaks the natural flow of the ball and looks choppy. Setup In order to create a new teleporter, select the GameObject you want to add it to, click on Add Component and select Pinball -> Game Item -> Teleporter. You can choose any GameObject, although we recommend putting it on same GameObject as the source kicker. Note The teleporter's features are very basic. If there is need, we will add more features like teleportation to multiple types of game elements or the possibility to teleport in both directions. Eject After Teleport Once the ball is created at the destination kicker, it can be ejected immediately or after a delay (see next section), or it can stay in the kicker. If disabled, this option makes the destination kicker keep the ball until it's explicitly ejected through the kicker's coil. Wait Before Eject You should use teleporters only for trajectories that are hidden and that emulate a physical ball going from A to B. In that case, the time it would take for the ball to travel from A to B can be simulated by waiting for the destination kicker to pop out the ball. This is the time in seconds that is waited before the ball is ejected from the destination kicker, but only if Eject After Teleport is enabled. From Kicker A reference to the source kicker. Note that if you use this kicker for teleportation only, it's recommended to remove any coils from the kicker, since it will make it easier to select the right element when linking to it in the Coil Manager. To Kicker The destination kicker. Here you also select a coil in case the ball is ejected after teleportation."
  },
  "creators-guide/manual/mechanisms/troughs.html": {
    "href": "creators-guide/manual/mechanisms/troughs.html",
    "title": "Troughs / Ball Drains | VPE Documentation",
    "keywords": "Troughs / Ball Drains If you are unfamiliar with ball troughs, have a quick look at MPF's documentation, which does an excellent job explaining them. VPE comes with a trough mechanism that simulates the behavior of a real-world ball trough. This is especially important when emulating existing games, since the gamelogic engine expects the trough's switches to be in a plausible state, or else it may have errors. Creating a Trough When importing a .vpx file that doesn't have any troughs (which is likely, because Visual Pinball doesn't currently handle them in the same way as VPE) or creating a new table, VPE will automatically add a main trough to the root of the table. In order to create a trough manually, click on the Trough button in the toolbox. Linking to the Playfield To interact with the game, you must set up an input switch to drain the ball into the trough, and an exit kicker to release a new ball from the trough. This terminology may seem weird, since the ball exits the playfield when draining, but from the trough's perspective, that's where the ball enters. You can setup these links under Playfield Links by selecting the trough in the hierarchy panel and linking them to the desired items using the inspector. Note Both the input switch and the exit kicker are not related to the gamelogic engine. Their goal is purely to link the physics simulation to the trough logic, whose behavior is not physically simulated. Many games do have an input switch (which we call drain switch) and an exit kicker (we that one eject coil). They are simulated by the trough itself and show up in the switch- and coil manager under the trough device. The inspector also lets you configure other options: Ball Count defines how many balls the trough holds when the game starts. Switch Count sets how many ball switches are available. This is usually the same number as the ball count. The drain switch and the jam switch are excluded from this count. Has Jam Switch defines if the trough has a jam switch. This switch is often called eject switch as well. Roll Time sets how long it takes the ball to roll from one switch to the next. Kick Time defines how long it takes the ball to get kicked from the drain into the trough. Transition Time is only relevant for opto switches and defines how long the switch closes between balls. Trough Types VPE supports several variants of troughs found on real machines. You can configure the behavior of the trough by changing the Type in the inspector when the trough is selected in the hierarchy. In this section we'll again link to the excellent MPF documentation explaining each of the different types. We'll also provide an animation of the trough inspector during gameplay showing how the switches and coils behave in real time. Modern Mechanical Modern troughs with mechanical switches are covered by this type. The ball drains from the playfield directly into the ball stack, and every ball slot has an associated switch. When a ball gets ejected, the remaining balls move down simultaneously to the next position. During that movement, their switches get first opened and then closed again when they reach the next position. The time of this movement is defined by Roll Time. The animation on the right shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball, rolling back onto the stack. Modern Opto Modern troughs with optical switches work similar similar to their mechanical counterparts. However there are two differences: Opto switches have the inverse value of mechanical switches. That means per default, an opto switch is closed, and when a ball rolls through, it opens. It's kind of logical, because the ball blocks the beam of light thus opening the circuit, while a mechanical switch gets closed by the ball's weight. Timings are different. When a ball approaches an opto switch, the switch gets triggered as soon as the ball's front hits the beam, while a mechanical switch gets triggered when the ball's center is over it. This results in very short closing times when the ball stack moves to the next position after a ball eject. We call this closing time the transition time - it's the time during stack transition when all switches briefly close. Like before, the animation shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball, rolling back onto the stack. Note When a transition time is set to 0, only the first and the last switch of the stack change value (as opposed to each position opening and closing immediately). Two coils and multiple switches Troughs of this type can be found in older machines from the 80s and early 90s. They consist of two parts: A drain, the ball rolls into when leaving the playfield A ball stack, where the out of play balls are held. In terms of switches, they still include a switch per ball in the stack, but also an additional drain switch to trigger kicking the ball from the drain into the stack. The animation shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball. The ball stays in the drain until the entry coil activates, which makes the ball roll over to the ball stack. Two coils and one switch A trough can also have only one switch in the ball stack. Instead of a Switch Count like the previous types, you select a Switch Position, which is the position in the ball stack at which the ball farthest away from the eject coil sits. The animation shows a 6-ball trough filled with six balls. It starts by ejecting a ball, followed by draining that ball. The ball stays in the drain until the entry coil activates, which makes the ball roll over to the ball stack. Classic single ball A single ball trough may work with or without a shooter lane. The principle is simple: After draining, the ball is kept on the drain coil, which ejects the ball either directly into the plunger lane or back onto the playfield. The animation shows single ball trough that ejects a ball and drains it a few seconds later. Switch Setup The number of simulated switches in the trough depends on the type of trough and the Switch Count property in the inspector panel. For recreations, you can quickly determine the number of trough switches by looking at the switch matrix in the operation manual, it usually matches the number of balls installed in the game. To configure the switches, open the switch manager and add the trough switches if they're not already there. For Destination select \"Device\", under Element, select the trough you've created and which switch to connect. For a modern five-ball trough, it will look something like this: Coil Setup VPE's trough supports up to two coils, an entry coil which drains the ball from the outhole into the trough, and an eject coil which pushes a new ball into the plunger lane. To configure the coils, open the coil manager, find or add the coils, and link them to the trough like you did with the switches: Note Depending on which trough type is set, different coils and switches show up under the trough device."
  },
  "creators-guide/manual/sound.html": {
    "href": "creators-guide/manual/sound.html",
    "title": "Sound | VPE Documentation",
    "keywords": "Sound Unity, the game engine VPE is built on top of, provides many useful audio features out of the box. It can import and play several common audio file formats, it supports directional audio and surround sound and provides mixing and mastering functionality. For a comprehensive overview, refer to the Unity documentation. On top of this built-in functionality, VPE provides some features specific to pinball. Preparing Sound Files Before you can use a sound file in your VPE table, you must import it into Unity. This can be as simple as adding a file of a supported type (.aif, .wav, .mp3, .ogg) to your project folder, but there are a few things you should consider: Encoding No matter what format your file is on disk and no matter what settings you chose when exporting it, Unity will transcode and compress your audio file differently depending on the platform it runs on. This means you should prioritize audio quality over small file size when creating your files. The standard practice among Unity developers is to use uncompressed .wav files to avoid double compression and achieve the highest possible quality on any platform. Channels Use a single channel (mono audio) for any spatial sounds. For example, do not export the sound effect for your plunger with a louder right channel just because the plunger is on the right side of your playfield. Unity can dynamically change the volume per channel depending on the locations of the listener and the audio source. If you already have mechanical sound effects in stereo format, you can mix them down to mono in Unity's import settings. For anything that would come out of the speakers in a real pinball machine, such as music and callouts, you can use stereo sounds if you want. Loudness All your sound files should have a subjectively similar loudness relative to each other so you don't have to mess around with volume sliders in Unity just to equalize the volume. Any volume mixing you do in Unity should be done to make certain sounds louder than others, not the other way around. The overall loudness of your table should also be consistent with other VPE tables and other software in general so that players don't have to fiddle around with their volume controls every time they open your table. Unity does not have the ability to normalize the loudness of your audio files, but the free audio editing software Audacity does: Import your file(s) into Audacity Press Ctrl + A to select all In the toolbar at the top, select Effect -> Volume and Compression -> Loudness Normalization... Do not change the default settings (-23 LUFS) and click 'Apply' Press Ctrl + Shift + E to export Sound Assets After importing your a sound file into Unity, you get an Audio Clip. You could create an Audio Source in your scene and play this clip directly, but VPE allows you to construct different types of sound assets out of one or multiple of these audio clips to produce variation and customize how the sound is played with pinball in mind. VPE differentiates between sound effects, music and callouts. To create a sound asset, navigate to the folder where you want to create it in your Unity project panel, right click, select Create -> Pinball -> Sound and choose the type of sound asset you want to create. All sound asset types have the following properties: Description: You can enter any text here. This field is only for diplay. Use it to describe the sound, when it should be used, how it was recorded, or just leave it blank. Clips: A list of audio clips that may be selected for playback. For frequently played sounds, such as that of a bumper, you should provide multiple samples here. Clip Selection Method: How VPE decides which clip to choose each time the sound is played. Round Robin: The clips will be played first to last in a fixed order. Random: Clips are selected at random. Audio Mixer Group: The audio mixer group whose effects and settings will be applied to the sound asset when played. VPE comes with a default audio mixer group for each type of sound asset. This enables the VPE player application to provide global volume settings to end users across all tables. The default audio mixer is also responsible for reducing the volume of sound effects and music whenever a callout plays. Your table will lose these benefits if you use your own audio mixer groups. Sound Effects Sound effects are the most common type of sound asset. You should generally choose this type for any sounds other than callouts and music. In addition to those described above, sound effect assets have the following properties: Type: In a real pinball machine, would this sound come from a mechanism (Mechanical) or from the speakers (Synthetic)? When a mechanical sound effect is played, VPE uses Unity's spatial audio system to position it in the scene according to the object that triggered it. Loop: Causes the sound to loop until it is stopped according to table logic. When enabled, additional options for fading in and out are available. Volume Range and Pitch Range: Two sliders with two control knobs each that indicate a range within which volume and pitch will be randomized each time the sound is played. This is a cheap way to produce variation if only one audio clip is available, but it will not sound as good as multiple samples. Cooldown: If the sound effect is triggered again before the specified number of seconds passes, it will not be played. This is to prevent sound effects from playing twice at the same time, for example when the ball hits two drop targets at once. Callouts Callouts are short voice lines that are typically triggered when the player does something special, like starting multiball. The reason for the distinction between callouts and sound effects is that callouts tend to be much more significant to the player than other sounds. As such, their playback is managed by a table-wide Callout Coordinator component at the root of the table hierarchy that ensures callouts are played one at a time. When triggering a callout, you can select a priority. Whenever a callout is triggered while another is playing, it will be placed in a queue to be played later. New callouts will 'cut in line' in front of any lower priority callouts already in the queue. Callouts also have their own audio mixer group that lowers the volume of sound effects and music whenever a callout is played. (This is called \"ducking\" in audio technician lingo.) Music Like callouts, music is played indirectly through requests to a table-wide Music Coordinator at the root of the table hierarchy. This ensures your table never plays multiple tracks at once, so you don't have to worry about that in your game logic. Requests to the music coordinator are made with a priority. If multiple requests are active at the same time, the one with the highest priority will play. If multiple requests have the same priority, the most recent one is played. If a new track starts while another is playing, the music coordinator will cross-fade between them according to the Fade Duration setting on the music coordinator component. Music assets always loop: When an audio clip from a music asset finishes, the next clip is chosen according to the clip selection method specified in the asset. This allows you to build playlists using music assets. Playback Regardless of which game logic engine you use, VPE provides a few Unity components to trigger the playback of sound assets. Hit Sound, Coil Sound and Switch Sound are intended to trigger mechanical sound effects when the ball hits something, a coil is energized, or a switch is closed, respectively. You can add these components to any game objects that have another component to supply the appropriate events. For example, a bumper component supplies all three, because bumpers can get hit and have both a coil and a switch. If the coil or switch that should trigger the sound is part of a device with other coils or switches, you must select it in the drop-down menu on the sound component. You can have as many sound components on one object as you want. If you expect a sound to be triggered in quick succession, you may be interested in the Multi Play Mode setting. It specifies what to do when the sound is still playing when it is triggered again. These are the options: Play In Parallel: Keep playing the previous sound and start another one at the same time. Do Not Play: Keep playing the previous sound and don't start another one. Fade Out Previous: Fade out the previous sound while starting a new one. If the sound is not a looping sound or its fade out time is zero, this is the same as Stop Previous. Stop Previous: Immediately stop the previous sound and start a new one. Any sound that would come out of the speakers in a real pinball machine should be driven by your game logic engine, but there is technically nothing stopping you from triggering music or a callout when a switch is closed, for example. Additionally, VPE provides the Music Requester and Callout Requester components for testing purposes. These components will trigger callouts and music as soon as they are enabled and cancel the request when they are disabled. To get some music playing as quickly as possible, simply add a music requester component to an enabled object in your table hierarchy and assign a reference to the music asset you want to play."
  },
  "creators-guide/setup/installing-vpe.html": {
    "href": "creators-guide/setup/installing-vpe.html",
    "title": "Installing VPE | VPE Documentation",
    "keywords": "Installing VPE Unity In order to start creating or modifying tables with VPE, the first thing you'll need to do is install Unity. You will need a Unity developer account, which is free. Note As long as you don't use Unity for a game that makes $200K or more in revenue or funding a year, the free Personal plan is sufficient for you. Unity uses an application called Unity Hub to update itself, create new projects and provide quick access to them. The install process is straight-forward and documented here if you run into troubles. Unity 6.2 is the recommended Unity version at the moment. You can leave all the other options unchecked during install. Once Unity is downloaded and installed, you're ready to create a new VPE project. Click on New Project, be sure to have selected the 6.2 version at the top, and you'll see the following choices: The relevant options for VPE are: Universal 3D - Unity's URP is aimed at mobile and low-end platforms. High Definition 3D - Unity's HDRP used for high-end platforms. We recommend using HDRP. It's what we're using when developing and should be the most stable pipeline. Alternatively if you're on a laptop don't have a beefy GPU, use the URP. The built-in renderer is legacy not recommended. Next, enter a project name and a location for your project. Clicking Create project launches the Unity editor, pulls in all the dependencies for the new project, and compiles them. This will take a few minutes. HDRP Setup Once the editor has opened you can click away the HDRP Wizard that opens. You should now see an empty scene: Click on File -> New Scene and select the Basic Indoors (HDRP) template. Save it in your Assets/Scenes folder as MyTable.unity. In this scene, there are already some objects we don't need. In the Hierarchy, select the Geometry game object and delete it by pressing DEL. Your scene should now look like this: Hit Ctrl+S to save your scene. VPE Package Now that you have your project and scene set up, let's bring in the VPE libraries. VPE ships as a package that you can install using the Package Manager inside of Unity directly. However, since Unity's package registry is only used for official Unity content, we need to add our own registry first. To do that, go to Edit -> Project Settings, and select the Package Manager panel on the left. Under Scoped Registries, add the following: Name: Visual Pinball Engine URL: https://registry.visualpinball.org/ Scope(s): org.visualpinball Scope(s): com.bartofzo Also check Enable Pre-release Packages (and confirm), as well as Show dependencies. Your settings page should now look like this: Hit Save and close the window. Now you'll add VPE's HDRP package, which will automatically pull in the core package and the assets package. Open the package manager by clicking on Window -> Package Management -> Package Manager. Then click on the \"plus\" icon on the top left corner of the window, and choose Add package by name... There, enter org.visualpinball.engine.unity.hdrp and click Install. This will take a moment as Unity downloads and compiles all of VPE's dependencies and parses all the assets that we ship in our library. Warning Our patcher, which is currently part of the main package, depends on the PinMAME package. Until we move the patcher into a separate package, you will have to install the PinMAME package as well. To do that, click on the plus button again and enter org.visualpinball.engine.pinmame, then click on Add. When complete, you should now have a Pinball menu in the editor, and you should see the following new packages in the package manager (version numbers will vary): Now that VPE is installed let's import a table!"
  },
  "creators-guide/setup/running-vpe.html": {
    "href": "creators-guide/setup/running-vpe.html",
    "title": "Running VPE | VPE Documentation",
    "keywords": "Running VPE Now we can begin with some simple game play. Open Visual Pinball, create a new \"blank\" table, and save it somewhere. In Unity, go to Visual Pinball -> Import VPX and choose the .vpx file you've just created. You should now see Visual Pinball's blank table in the Editor's scene view: Now, we don't see much of our table. That's because the scene view's camera doesn't really point on it. Using the right mouse button in the Scene View and the A W S D keys while keeping right mouse button pressed, fly somewhere you have a better view of the table. Tip Check Unity's documentation on Scene view navigation for a more complete list of ways to move the camera around the scene. Now that we have the camera of the scene view somewhat aligned, we still can't see much! These orange artifacts are what Unity calls Gizmo Icons. They are enabled by default, and since VPE uses icons for its playfield elements, they are all over the place. Unity's default gizmo size is adapted for rather large scenes and we're dealing with a pinball table, let's make them smaller by clicking on the gizmo icon in the Scene view, and pull the size 3D Icons slider down until you're happy. You can additionally hide the VPE icons by clicking on Pinball -> Editor -> Disable Gizmo Icons. And while we're at it, choose Pinball -> Editor -> Setup Layouts to populate a bunch of pre-made editor layouts that give you easy access to the tooling we've added to the editor. Then, click on the top right drop down in the editor where it says Default, and choose 3) VPE Simple. Now that's better! The view in the scene tab is not the camera used in game. The Scene View really allows you to fly anywhere, zoom in on things you're working on, switch from orthagonal view to perspective, and so on. It's where you get work done. During game play, another camera is used. It's the one already in your scene hierarchy (called Main Camera), and you can look through it by switching to the Game View window. This camera can be moved using Unity's gizmos, by selecting it in the hierarchy and moving and tilting it around. Tip A quick way to fix the game camera is to align it with the scene view camera. To do that, select the camera in the hierarchy, then click on the GameObject menu and select Align with view. Let's start the game by clicking on the play button. This will run your scene. Test that the shift keys move the flippers. ENTER will launch a ball. If you expand Table1 in the hierarchy and select the Trough, you can watch its status in the inspector in real time. Cool! You can also right-click on the scene view tab and select Maximize. Tip If you want to enter play mode more quickly, you can check the experimental play mode option described here. One last thing: The game view is pretty static now. You can change that by dropping an orbit script on the camera that lets you rotate and zoom in. If you're a Unity beginner, that would be your first exercise!"
  },
  "creators-guide/tutorials/index.html": {
    "href": "creators-guide/tutorials/index.html",
    "title": "Tutorials | VPE Documentation",
    "keywords": "Tutorials Create a Playfield Create Realistic Looking Plastics Create a Backglass Make a 3D Scan Game-Ready"
  },
  "creators-guide/tutorials/make-a-3d-scan-game-ready/1-clean-up.html": {
    "href": "creators-guide/tutorials/make-a-3d-scan-game-ready/1-clean-up.html",
    "title": "Clean Up Your 3D Scan | VPE Documentation",
    "keywords": "Clean Up Open Blender and import your model. Reposition The first thing you'll see is that it's probably not correctly sized and positioned. Using the R (rotate) and G (grab) keys, place your object at the origin. Be sure to apply everything by hitting Ctrl+A in the scene view and choose All Transforms. Remove Unwanted Geometry As you can see, our scan has a bunch of artifacts that aren't actually part of the owl. We're going to focus on the bottom part. Zoom in on the part you want to remove. Toggle X-Ray, so you can select occluded geometry, and hit TAB to enter Edit Mode. In Edit Mode, hit 1 and select the vertices you want to remove. Hit X and select Delete Vertices Press 2 for edge selection, and select the boundary of the hole you've just created. Hit F to create a face and Ctrl+T to triangulate it. From Edit Mode, change into Sculpt Mode, select the Smooth tool, adjust the radius, and smoothen up the hole you've filled. Steps 1 to 6. Repeat this for all the other parts that are unwanted in your scan. Note If you have free floating geometry that you want to quickly erase, do this: In Edit Mode, select a vertex of the part you want to keep. Hit Ctrl+L to select all linked vertices Hit Ctrl+I to invert the selection. Hit X and select Delete Vertices to delete all loose parts. Decimate the Mesh This step is optional, but 1.8mio triangles is hard to handle, so we'll decimate the mesh to 10% so we have something more light to work with. 180k triangles is still plenty enough, even later when we use it to bake in the details. Go back to object mode by hitting TAB. Go to the Modifier panel on the right hand side. Add a Decimate modifier. Set the Ratio to 0.1 (Blender will probably freeze for a few seconds). From the drop down, select Apply. Finally, export the mesh as Wavefront (.obj) and name it hi-poly.obj. Now that we have a good hi-poly mesh, let's continue with the next step, retopology."
  },
  "creators-guide/tutorials/make-a-3d-scan-game-ready/2-mesh-retopology.html": {
    "href": "creators-guide/tutorials/make-a-3d-scan-game-ready/2-mesh-retopology.html",
    "title": "Mesh Retopology | VPE Documentation",
    "keywords": "Mesh Retopology For this step we'll need two additional tools: Instant Meshes (a standalone tool) RetopoFlow 3 (a Blender plug-in) Both programs are free and open source. Retopowhat? From blender.org: Retopology is the process of simplifying the topology of a mesh to make it cleaner and easier to work with. Retopology is need for mangled topology resulting from sculpting or generated topology, for example from a 3D scan. You're probably not going to rig and animate your playfield toy. However, retopology gives you the possibility to put in more geometry where it's most visible, adding more details to your mesh for the same price (=poly count). Our approach here is to let Instant Meshes handle most of the heavy work, and manually add more details where appropriate. If you want to dig deeper into topology, here is an extensive video on the topic: Base Topology Open up Instant Meshes and load hi-poly.obj. Now you need to decide the number of vertices you're aiming for. Since we're going to add more geometry later, we can aim pretty low. In our case, we're going for a thousand vertices. Set Target vertex count to 1K, then click on Solve under Orientation field. This gives you hints how the geometry will be oriented. Now, if you're doing this the first time, you probably have no idea what to look for. In general, what you're aiming for is an orientation field that is well aligned with the geometry. For example, we would like to have an orientation along each of the crawls, so we can more easily add details without having to move too much vertices around. Use the comb tool to draw new lines. Each time you add a new line, the program updates the orientation field to accommodate for the new orientation you're setting. In our example, we've added new orientations to the crawls, the wings and the face. We didn't go into too much detail for the face, since we're re-doing that one manually later anyway. Now, click on Solve under Position field. This gives you a rough idea how the polygons will be aligned. If necessary, re-comb and solve again. Click on Export Mesh and Extract Mesh. This shows you the mesh we're going fine-tune in Blender. Click on Save and export it as low-poly-base.obj. Fine-Tune Go back to Blender, and import low-poly-base.obj. Select it, and choose Object -> Shade Smooth. If you haven't yet, install the RetopoFlow 3 plugin. We won't go into too much detail on how to use RetopoFlow, but this tutorial should teach you the basics: In order to get your imported model into RetopoFlow, select the mesh, enter edit mode, click on the RetopoFlow button, and select Start RetopoFlow. Now, re-topo the parts that need more details. In our example, we've completely removed and remodeled the head, added more geometry to the feet and some to the wings. We've also aligned some vertices to better match the model. Note Quads vs Tris You're probably heard about the debate whether to use purely quads or triangles in your geometry. Here is a pretty good overview about the pros and cons of each. In short, since we're not purists and are working on game assets, some triangles are fine. So you got your mesh. Spend some time fine-tuning it. Rotate, and check if there are any important angles where the silhouette looks jagged. Add more geometry if needed, but also keep in mind the distance from which your toy will be typically rendered (probably no one will zoom-in fully on your model during game play). Now let's bring back the details of the original geometry."
  },
  "creators-guide/tutorials/make-a-3d-scan-game-ready/3-bake-texture-maps.html": {
    "href": "creators-guide/tutorials/make-a-3d-scan-game-ready/3-bake-texture-maps.html",
    "title": "Bake Texture Maps | VPE Documentation",
    "keywords": "Texture Baking In this last part, we'll use the original mesh to bake the details of the geometry into a normal map. We'll also project the original texture (diffuse map) onto our new model. UV-Unwrap But first, we need to UV-unwrap our low-poly mesh. Change to the UV Editing workspace in Blender, select the low-poly model, TAB into Edit Mode, hit A to select all, and choose UV -> Smart UV Project. Set Up Material Before we bake anything, we'll set up the material. Go to the Shading workspace and assign a new material to the low-poly mesh. Then, set up the two maps we're going to bake. In the node editor: Hit Shift+A, choose Texture -> Image Texture. With the image texture selected, hit Shift+D to duplicate On the first texture, click New, name it \"Diffuse\", and set the size to the same size as the texture of your original 3D scan. On the second texture, also click New, name it \"Normals\", same size, but enable 32-bit Float. Hit Shift+A again, and add a Normal Map node. Connect the \"Diffuse\" texture's Color to the principled BSDF node's Base Color input. Connect the \"Normal\" texture's Color to the normal map's Color input. Connect the normal map's Normal output to the BSDF node's Normal input. Your graph should now look like this: Bake Normal Map In the Outliner, make sure both the high-poly and the low-poly mesh are visible. Also, make sure that the low-poly object doesn't have any modifiers added (RetopoFlow might have added a Mirror and Displace modifier). Select in this order, while holding Ctrl: The high-poly mesh The low-poly mesh Go to Render Properties and make sure Cycles is selected as the render engine. Then, scroll down to the Bake section. Set Bake Type to Normal Check Selected to Active In the node editor, select the \"Normals\" node. Hit Bake. Depending on the size of your mesh, you'll also need to set Extrusion and Max Ray Distance. Values on 3mm and 5mm respectively worked for this example. Bake Diffuse Map Now, select the \"Diffuse\" node in the node editor. Change Bake Type to Diffuse, uncheck Direct and Indirect, and hit Bake again. That's it! Hide the high-poly mesh, and you've got your game-ready model!"
  },
  "creators-guide/tutorials/make-a-3d-scan-game-ready/index.html": {
    "href": "creators-guide/tutorials/make-a-3d-scan-game-ready/index.html",
    "title": "Make a 3D Scan Game-Ready | VPE Documentation",
    "keywords": "Make a 3D Scan Game-Ready In this tutorial we describe how to convert a 3D scan of toy into something that can be used as a game asset. It's not necessarily linked to VPE or even Unity, but there are many ways of doing it, and this flow has been working great so far. Overview In general, there are multiple characteristics of a 3D scan that make it unsuitable for importing directly into a game engine: There is often noise, i.e. elements that aren't part of the actual object. Depending on the method of the 3D scan, the poly count of the model can be extremely high. The topology of the scanned mesh often isn't ideal. This tutorial addresses all of those issues, by explaining how to: Clean up the mesh Reduce the poly count Retopologize the geometry Bake the lost geometry details into a normal map We'll be using an owl toy that you can download here (props to Dazz for ordering and scanning the model). Left: Original scan, 1.86 mio triangles, right: Game-ready conversion, 1,400 triangles. Prerequisites The 3D model you're converting. You should have a intermediate level in Blender. Workflow Clean up the mesh Retopologize the mesh Bake a normal map and a diffusion map"
  },
  "creators-guide/tutorials/realistic-backglass/1-prepare-artwork.html": {
    "href": "creators-guide/tutorials/realistic-backglass/1-prepare-artwork.html",
    "title": "Realistic Looking Backglass - Prepare Artwork | VPE Documentation",
    "keywords": "Finding Artwork Perhaps the most challenging aspect to making a working backglass is finding good artwork. The best possible art is a direct scan of the backglass but that is not always possible. There are backglass images that can be found online but it takes a fair amount of time to clean these up and remove any artifacts from them. Another possibility is to get artwork online and use that as a basis for a total redraw. Create the Color Map Once you have your artwork secured save this as a PNG file. We'll name it Backglass Albedo.png since it'll become our diffuse, or color map. Make sure that the areas for the score reels and credit reel set as transparent. Also be sure to size the backglass image to the size of the original backglass, in the case of Volley this is 19 ¾\" x 22\". Create the Thickness Mask To block the passage of light through the backglass we need to make a thickness map layer. This layer consists of pure white for the areas that are opaque and pure black for the areas that are transparent. If you have physical access to the backglass then you can scan the backside to get this mask. Otherwise, you'll have to trace what's visible on the front, and try to reconstruct elements that aren't. Elements that aren't visible are often scores that aren't part of the actual artwork. In this case, your best bet is to find a similar font to the original art and eyeball where it goes. A helpful site is WhatTheFont, which helps you identify the font in an image. Save this as a grayscale PNG file without transparency named Backglass Thickness.png. You're now ready to create a backglass mesh."
  },
  "creators-guide/tutorials/realistic-backglass/2-create-mesh.html": {
    "href": "creators-guide/tutorials/realistic-backglass/2-create-mesh.html",
    "title": "Realistic Looking Backglass - Create Mesh | VPE Documentation",
    "keywords": "Create a Backglass Mesh We're now going to edit Blender's default cube and unwrap it to fit the backglass artwork. Note: this might be the only tutorial on the internet that actually uses the default cube ;) Create the Geometry Open Blender and select the default cube. In the Scene Properties window, set units to Imperial and the length to Inches. With your mouse cursor over 3D viewport, hit N to show the transform properties of the cube. Enter the dimensions of your backglass in the Y and Z fields under Dimensions. The X value isn't really important, make it something small like 0.2\". Then, while the object is still selected, hit CTRL+A and choose Scale to apply the scale to the geometry. Unwrap the Front Surface The edges and the back side of the translite won't be visible, so we'll only unwrap the front side. Since the aspect ratio of the front side matches the aspect ratio of our maps, we can to project it entirely onto the map. Change to the UV Editing workspace. Put your mouse cursor over the right window and press numpad 3 to switch to an orthographic front view of the backglass. Make sure you're in edit mode, hit 3 for face selection and click on the front face. Select UV -> Project From View (Bounds). In order to clear the unused faces, hit CTRL+I, hover over the left side, hit 1 for point selection, type S for scale, and enter 0. Clean Up and Export Go back to the Layout workspace. Select Material Properties, click on Material and on the - button to remove it. Hit F2 and rename the Cube to Backglass. Then, with the object still selected, choose File -> Export -> FBX. Check Selected Objects only, and name it Backglass.fbx. You're now ready to import into Unity."
  },
  "creators-guide/tutorials/realistic-backglass/3-import-into-unity.html": {
    "href": "creators-guide/tutorials/realistic-backglass/3-import-into-unity.html",
    "title": "Realistic backglass - Import Into Unity | VPE Documentation",
    "keywords": "Import Into Unity Import Your Assets Open your scene in Unity and copy the Backglass.fbx into your models folder, and Backglass Albedo.png as well as Backglass Thickness.png into the textures folder. You can do that by dragging the files from the file explorer into Unity's Project window. Note We recommend storing models at Assets/<Table Name>/Models, textures at Assets/<Table Name>/Textures, and materials at Assets/<Table Name>/Materials. Add the Backglass to the Scene In the Project window, select the Backglass prefab (your FBX). In the inspector, uncheck Convert Units and hit Apply. Drag the backglass it into your scene view. Ouch, that's too large and not oriented correctly. Let's fix that. In the inspector, set Rotation to -90/180/90 and the scale to 1 on all axes. Then use the Move Tool in the scene view to position it correctly. Create the Material In the Project window, navigate to your Materials folder, right click, select Create -> Material, and name the new material Backglass. Set the following properties: Enable Alpha Clipping to make the score reels visible through the transparent areas. Material Type to Translucent Base Map to Backglass Albedo (use the small target icon to search) Smoothness to something high like 0.97 Thickness Map to Backglass Thickness For the Diffusion Profile, use the Project window and navigate to Packages/VisualPinball.Unity.Hdrp/Assets/Settings and drag and drop Translite into the slot (it cannot be searched after because it's part of an external package). Apply the Material In the Project window, navigate back to your materials, drag and drop the Backglass material onto the backglass in your 3D view, and... Voilà! To test the thickness mask, place a light source behind the backglass and move it around: Finally, in the Hierarchy window, move the Backglass game object from the root into your table structure. Best practice is to create a Back Box parent where you keep all your game objects that are part of the back box. Congratulations! You have now made a backglass that will transmit light through the color overlay and block light in any of the masked area."
  },
  "creators-guide/tutorials/realistic-backglass/index.html": {
    "href": "creators-guide/tutorials/realistic-backglass/index.html",
    "title": "Create a Backglass | VPE Documentation",
    "keywords": "Create a Backglass This tutorial runs through the workflow for making the color and mask artwork, creating a mesh in Blender and importing that mesh and artwork up in Unity to create a working backglass. Overview The result of this workflow is a pinball backglass that is properly sized and contains color artwork along with a light blocking thickness map: The final result! Prerequisites While we provide some guidelines for the artwork, we won't go into detail how to produce it. So, we assume that you have your artwork ready. You should have a entry level skills in Blender. Workflow Prepare Artwork Create mesh in Blender Import mesh into Unity Note We don't provide guidelines how to go about the light sources behind the translite, although we might will in a future tutorial."
  },
  "creators-guide/tutorials/realistic-plastics/1-prepare-artwork.html": {
    "href": "creators-guide/tutorials/realistic-plastics/1-prepare-artwork.html",
    "title": "Realistic Looking Plastics - Prepare Artwork | VPE Documentation",
    "keywords": "Prepare Artwork The goal of the first step is to prepare the artwork in a way it's easily exportable and can be re-exported without having to go through the other steps. We're going to use Adobe Illustrator for this. As mentioned in the introduction, we're aiming for a single texture that contains all plastics. The advantage is that this way, less texture data needs to be transferred to the graphics card and only one material instance must be instantiated. It also allows you to process everything together, versus having to repeat this workflow for every plastic separately. Step 1: Create Artwork There are many ways to create artwork. If you're working on an original game, you might draw it using a drawing software. For recreations where you have access to the physical machine, you might disassemble the plastics and scan them or take pictures with a good camera. If you don't have access to the physical plastics, you might get good sources by searching on the internet. Note If you're using a camera, be sure to remove any lens distortion with Camera Raw or similar software. For images found online, you will probably have to manually un-distort the image. For optimal quality, two things are important when dealing with source material not coming directly from a scanner: Distortion: You'll be extracting the 3D mesh from the outline of your 2D artwork. If the artwork is distorted, you won't be able to fit the plastic on the playfield. Colors: Since Unity is applying lights to the scene, the colors in the texture should be neutral. That means that lights that leak into the texture will negatively influence the final render. Once you have an image of the plastic, you need to decide whether you will be using it as-is, or whether you're going to redraw it. Depending on the type of artwork, redrawing might not possible or a huge effort, and \"cleaning it up\" in Photoshop will do it. The advantage of redrawing it is that you can produce arbitrary large textures and make the colors match perfectly. Note Speaking of colors, it's best to use PBR-compatible colors, meaning your texture shouldn't contain absolute blacks or whites, and the brightness of other colors should be at around 95% max. For black, we're using #272727 and for white #f4f5f0. The T2 table we're using in this tutorial contains exclusively vector art, so we've created an .ai file per plastic: Note the pink outlines. They sit on a separate layer and can be easily toggled. They should contain drill holes for the screws as well, as they are visible due to the plastic being transparent and the ink actually sitting below the plastic. Since our first step is to create the texture, hide the outlines and save all your files. Note If you're using pixel-based sources for the plastics, don't worry about the outlines just yet. ;) Step 2: Arrange Artwork Now we have one file per plastic, we'll place them into a single document that we can render out as a texture. For this, create a new, square document in Illustrator. Depending on the size and number of plastics you might want to change this later but give it a width and height of 4096 pixels for now. Let's call it Plastics.ai. Since we're creating the texture, we don't need the pink outlines. So, before continuing, open all of your source files, hide them, and save them. As we might update our original files later, we won't copy and paste our plastics into this document but link them instead. In order to do this, go to File -> Place... and select all your plastics. Then arrange them in a way so there's as little white space as possible remaining. Note In order for the plastics to have a similar pixel density, we recommend keeping the proportional size of the plastics approximately the same, i.e., larger plastics should take more space than smaller ones. Your artboard should now look something like this: Note the Links toolbox that shows the individual plastic files. Also note the pink surfaces on the right, outside the artboard. These are plastics that don't have any artwork, i.e., blank, transparent pieces. We keep them here because we want to generate meshes as well, but don't need it in the texture, which is defined by the artboard. Warning Verify that the outlines on the artboard are hidden. This is the version we'll create the texture with, and we don't want to leak the outlines onto the final texture. Step 3: Export Texture and Outlines We'll first export the texture. In Illustrator, click on File -> Export -> Export As..., and make sure Use Artboards is checked. As type, select PNG. Then, enter Plastics.png as file name and click on Export, which will result in the dialog seen in the screenshot. Since you've set the resolution to 4096 × 4096 pixels when you've created the document, and the default pixel density is 72dpi, choose 72dpi. This should result in a PNG file at 4096 × 4096 pixels. Note When I exported it when writing this tutorial, Illustrator exported it as 4097 × 4097 🤦‍♂. So, I ended up exporting it with a slightly higher resolution and sizing it down in Photoshop. Outlines The goal of having outlines in the artwork is so that we can extract the mesh from it, and it allows us to align the artwork perfectly on the surface. We're going to export the outlines as solid surfaces in the SVG format. The result we can then import into Blender. In order to do that, open all your artwork files, hide the actual artwork, and only show the outline. Make it one single solid surface per plastic, meaning if you have holes, you need to remove them from the parent curve. Note If your artwork are pixel graphics, draw your outlines directly into Plastics.ai. We recommend putting them on a separate layer, so you can toggle them easily. Your document should now look like this: Don't worry about the color, it just needs to be filled in any color. I'm using magenta because it gives a good contrast to the rest of the artwork. Click on File -> Save a Copy..., enter Plastics.svg as file name, save as type SVG and make sure Use Artboards is unchecked this time. Click on Save. In the options panel, click on More Options and make sure all the options are disabled as shown in the screenshot. You're now ready to create the meshes."
  },
  "creators-guide/tutorials/realistic-plastics/2-create-mesh.html": {
    "href": "creators-guide/tutorials/realistic-plastics/2-create-mesh.html",
    "title": "Realistic Looking Plastics - Create Mesh | VPE Documentation",
    "keywords": "Create Mesh We're now going to import the SVG created in the previous step and create a mesh that is beveled on the top. Step 1: Import Open Blender, clear the scene with A, X, Enter. Then, click on File -> Import -> Scalable Vector Graphics (.svg), navigate to where you've saved the SVG in the previous step, select Plastics.svg, and hit Import. You might not see much due to the imported size. If there were no errors, you should see your imported plastics in the Outliner. Select them and press . on the numpad (not the main keyboard) while hovering over the 3D viewport to zoom in. Note You might run into another issue due to the size of the plastics: Camera clipping. To fix that, press N with your cursor over the 3D Viewport, select View and set something like 0.001m for Clip Start. Your viewport should look like this now: Step 2: Setup The way we're going for this is to extrude and bevel our SVG on one side only. This however results in the bottom faces missing. To fix that, we'll duplicate our SVG and use one for extrusion and the other for the bottom mesh. Before we start, let's make it one single object so we can easily apply everything we do in one step. Select one element, hit A for select all, then Ctrl+J for joining all curves. Hit Shift+D, Esc to duplicate at the same position. In the Outliner, let's name our objects \"bottom\" and \"extruded\": Step 3: Extrude Select \"extruded\" in the outliner and click on the Object Properties tab in the Properties view on the right side. Under Geometry, there is an Extrude field, and a bit below a Bevel section. Now, the Extrude value is difficult to judge. If you have access to the physical plastics, you can calculate the scale between the real world and the object in Blender by physically measuring the size of a plastic and dividing it by the measured value in Blender. Then, also measure the thickness of the real-world plastic and multiply it by that factor. Personally, I just eyeballed it and ended up with 0.003 m for the Extrude value and 0.001 m for the Bevel Depth. Then there are three more properties to change: We only want to extrude the front, so set Fill Mode to Front. We don't want to make the object larger by beveling, so enter the negative value of the bevel depth under Offset. Finally, a Resolution of 0 will do. Here are all the non-default options in red: Step 4: Convert, Join and Clean As seen in the previous screenshot, our bottom object now sits in the middle of the extruded mesh. Let's fix that by typing G (move), Z (on z-axis only), and the extrude value of the previous step, in our case 0.003, followed by Enter. Then type A to select all objects, choose Object -> Convert -> Mesh, and hit Ctrl+J to join them all. Finally, clean up the duplicated vertices from the extrusion by hitting Tab for edit mode, A to select all vertices, and choose Mesh -> Clean Up -> Merge by Distance. Exit edit mode and this is how it should look: If that's the case, congrats, you're done with the meshes! Maybe now it's a good moment to save your Blender file. Ctrl+S and enter Plastics.blend. In the next part of this tutorial, we're going to UV-Map them."
  },
  "creators-guide/tutorials/realistic-plastics/3-uv-map-mesh.html": {
    "href": "creators-guide/tutorials/realistic-plastics/3-uv-map-mesh.html",
    "title": "Realistic Looking Plastics - UV-Map Mesh | VPE Documentation",
    "keywords": "UV-Map Mesh Step 1: Create Material Slots We need three material slots, for the top and bottom faces, as well as for the edges. We'll split the vertices by firstly assigning everything to an \"edge\" slot, and then re-assigning the top and bottom faces to their own slots. In object mode, open Materials properties and remove the current material slot (hit -). Add three new slots (press 3× +), and for each slot, create a new material by hitting the New button when the slot is selected. Name them \"top\", \"bottom\" and \"edge\" and set their base color to red, green, and blue respectively. Your slots should now look like in the screenshot. Set the 3D viewport to Material Preview. Select your mesh, press Tab to switch to edit mode. Press A to select all vertices, select the \"edge\" material slot, and hit Assign. Your plastics should turn blue. Press A twice to deselect everything. Then, press 7 on the numpad to switch to top view, zoom in a bit so you can clearly see the triangles, switch to Face Select and click on one face of the top surface: Click on Select -> Select Similar -> Coplanar, which should result in all top faces of all plastics being selected (but not the bottoms ones). However, you might get the bottom faces selected too, because there's a threshold that might be too large. You can check it by rotating the camera and verify that the bottom faces are not selected. If they are, expand the parameters and set the threshold to a small enough value. Then, select the \"top\" material slot and hit Assign. The top surfaces should turn red. For the bottom faces, hit 7, 9 on the numpad to switch to bottom view, and select again one face. Like before, select all coplanar faces, click the \"bottom\" material slot, and Assign. You should see the bottom faces turn green. Now, the \"edges\" material slot should only contain the edges. Check by unselecting all (A A), then selecting the \"edge\" material slot and hitting Select. This should only select the edges, like here: Your meshes should now be colored like this (from top / bottom): Step 2: UV-Map Switch to the UV Editing workspace. In the left UV Editor, choose Image -> Open, and select the exported Plastic-01.png you've created in part one. On the right, enter edit mode, click on the \"top\" material slot in the Materials property tab, and hit Select. Click on \"bottom\" and then on Select again. From the UV menu, select Cube Projection. Move your cursor to the left view and press A. You should see both the top and bottom surfaces projected onto your texture: We're now going to align the projection with the texture. You can do that by using the G and S keys. What's important is to align the outer contour with the texture, like so: Step 3: Prepare and Export Once done, switch back to the Layout workspace. Before we export, there's still a bit of a clean up to do. In edit mode, hit A to select all and choose Mesh -> Clean Up -> Limited Dissolve. Exit edit mode, go to Modifier Properties, add the Triangulate modifier, and hit Ctrl+A to apply. What we just did reduced the complexity of our topology. We triangulate at the end to avoid problems during export. From left to right: Original (102k vertices, 44k triangles) After limited dissolve (66k vertices, 30k triangles, but errors in mesh) After triangulation (66k vertices, 30k triangles) Switch to the Object Data properties, and under Normals, enable Auto Smooth. This will properly align the normals on the bevel side, giving it a more realistic refraction effect. We still have one single object, so before exporting, let's split it. In edit mode, hit A to select all and choose Mesh -> Separate -> By Loose Parts. Before exporting, feel free to rename your objects in the Outliner, it's what you'll see in Unity. Lastly, in object mode, hit A to select all objects and click on Object -> Set Origin -> Origin to Geometry. This will set the local origin of each object to the object itself, making it easier to place it. Export the plastics by selecting File -> Export -> FBX. Name it Plastics.fbx and hit Export FBX. Now let's import this into Unity!"
  },
  "creators-guide/tutorials/realistic-plastics/4-import-into-unity.html": {
    "href": "creators-guide/tutorials/realistic-plastics/4-import-into-unity.html",
    "title": "Realistic Looking Plastics - Import Into Unity | VPE Documentation",
    "keywords": "Import Into Unity Step 1: Import the FBX Open your scene in Unity and use the Project window to navigate to where you've exported your FBX. Note We recommend storing models at Assets/<Table Name>/Models, and texture at Assets/<Table Name>/Textures. If you haven't already, copy Plastics-01.png as Plastics.png and Plastics.fbx into the corresponding folders. Drag Plastics.fbx under the Playfield GameObject. Scale and rotate them until they have the approximate size. We recommend unpacking the prefab. Unpacking will still reference the meshes of your FBX, but not the position within the FBX. That way you're more flexible in positioning the plastics, and should you move them in Blender later you won't need to re-position them in Unity. In order to do that, right-click on the Plastics GameObject and select Prefab -> Unpack. Step 2: Setup Assets First, let's configure how the texture is imported. In the Project window, navigate to Assets/<Table Name>/Textures where you saved Plastics.png, and select it. In the Inspector window, check the option Alpha Is Transparent. Depending on how large you've exported it, you might need to update Max Size as well, in our case we'll use 4096 × 4096. When you're done, hit Apply at the bottom. Next, we'll create a material of our bottom surface. In the Project window, navigate to Packages/Visual Pinball Engine (HDRP)/Assets/Art/Materials/Default/Plastic, select Plastics Decal, hit Ctrl+C. Navigate to your project's Assets/<Table Name>/Materials folder, and press Ctrl+V. Select the copied Plastics Decal. In the inspector, under Surface Inputs, click on the little circle next to Base Map, and type \"Plastics\" in the search box. Select the imported texture you've created and close the picker dialog. Step 3: Assign the Materials Now we have our materials ready, let's assign them to our plastics. Select all plastics GameObjects. In the inspector, under Mesh Renderer -> Materials, you should see three empty elements. These are our material slots. Drag the Plastics Decal material you've just updated into the last slot (Element 2). Then, in the Project window, navigate to where you were before, to Packages/Visual Pinball Engine (HDRP)/Assets/Art/Materials/Default/Plastic. Drag Plastics Edges to Element 0 and Plastic Top to Element 1. Note For some reason, material slots might be different depending on the object, so you'll need to verify if all the plastics look correct, and shuffle the material slots if necessary (you can just re-order them under Materials). If all went well, it should look like that! Transparent Plastics If you had completely transparent plastics without any artwork, you'll notice that they are still textured: In order to fix that, replace the Plastics Decal material with the Plastics Top material, and it will look correct: Step 4: Alignment Use the Scene View to move each plastic to the right position. You'll also need to rotate them and probably resize them as well. Tip: Once you're happy with all positions, set height of the plastic of all objects to the same value by selecting them in the Hierarchy and putting a Z-value of Scale in the Transform panel of the Inspector. That's It! If you came across an error or have a better way of achieving this, don't hesitate to click on the Improve this Doc button on the top right side (documentation)."
  },
  "creators-guide/tutorials/realistic-plastics/index.html": {
    "href": "creators-guide/tutorials/realistic-plastics/index.html",
    "title": "Create Realistic Looking Plastics | VPE Documentation",
    "keywords": "Create Realistic Looking Plastics This tutorial runs through a workflow that has been working well for us, from exporting the art and surfaces from a vector graphics program like Adobe Illustrator, through creating the mesh in Blender, to importing it into Unity setting up the correct materials. For mesh creation, we'll use vector outlines that are part of the plastics artwork. This allows us to precisely align the artwork to the future mesh. Overview The result of this workflow is a set of GameObjects in Unity with the typical plastic look. For that, our meshes consist of three pieces, each assigned to a material slot: The top surface, acting as the semi-transparent plastic. The side faces that include a simple bevel. This is where we add the refraction effect. The bottom surface, with the normals pointing up. This is where the texture is mapped to. Every plastic will have its own GameObject. However, only one texture is shared between all the plastics. The final result! Prerequisites While we provide some guidelines for the artwork, we won't go into detail how to produce it. So, we assume that you have your artwork ready. You should be familiar with a vector graphics software such as Adobe Illustrator. You should know your way around in Blender. Beginner level is fine, but you should be able to navigate in the viewport, know what UV-mapping is and know the basics about modifiers. Workflow Prepare Artwork Create mesh in Blender UV-map texture in Blender Import mesh into Unity"
  },
  "creators-guide/tutorials/realistic-playfield/1-textures.html": {
    "href": "creators-guide/tutorials/realistic-playfield/1-textures.html",
    "title": "Create a Realistic Looking Playfield - Textures | VPE Documentation",
    "keywords": "Albedo Texture and Masks In this first step, we'll go through how to create the various textures that we will need for the next steps. Texture Layout The geometry of the playfield has three different areas: The top surface, which will occupy most of our texture The plywood edges, which will be re-used by all edges that we will place on the left side of the texture The back side of the playfield, which is virtually invisible and mainly ignored. While often you create your geometry first, and then map the texture onto it, we're going to do it the other way around, which is firstly defining the UV-layout, and then extruding the geometry based on that. This will give us perfectly accurate mapping. The best way of doing this is to load your playfield scan, extend the canvas to the left, add the plywood texture, and save the result to a new file. So, let's start! Albedo Texture We start by creating a plywood texture for the edges. Check the dimensions of your playfield scan and create a new file with the same height (it's 6750 pixels in our example). Then, get a photo from the edge of some plywood, copy it a few times to get the whole height, and paint with a blurry brush on a mask to make the copies seamless. Add some contrast if necessary and save it as plywood.png. The plywood edge texture. Get the original here or an alternative here. Then, open your playfield scan in Photoshop. Use the crop tool to extend the canvas to the left, with the width of your plywood texture. Copy the plywood texture next to the playfield. Verify that its width more or less corresponds to the playfield size, otherwise it'll be skewed. Note Tip: When cropping, make it too large. Then, paste the plywood next to the playfield, and crop it back to the plywood's border. Go ahead and save this texture as albedo.png. Wood Mask Now we'll be creating a mask that we'll export as PNG for Substance, but also as SVG so we can extrude it in Blender. Open Adobe Illustrator. Create a new document and import albedo.png. Resize the artboard to the exact size of the imported image (enable View -> Smart Guide to make Illustrator snap to the edges). Name the layer reference and lock it. Create a new layer, name it wood mask and draw solid shapes that cover the visible holes. This includes insert holes, but also holes for lamps and triggers that aren't entirely covered by another object. Here a few tips that will probably make your life easier. Click on the small circle right to the wood mask layer and set the opacity to 50%. This way, all elements in that layer are semi-transparent, allowing you to align your edges much better. Draw with no stroke and a fill color that doesn't exist in the art, like magenta. It gives you a better contrast and allows you to be more precise. Disable smart guides (CTRL+U). It's much less annoying when you manipulate the curves. Use Illustrator's Live Corners feature. Specially for inserts, draw pointed corners and use Live Corners to round them off. You can do this for each corner individually. Try to get a photo of the real playfield's back side. It gives you a better idea how narrow the inserts are cut. Often, the printed border of the insert overlaps with the hole, which isn't visible in the playfield scan. If you're unsure whether a hole will be visible or not, draw it. Poly count isn't as important in modern engines, and it'll save you a lot of time. Finally, your mask should look something like this. Now, we'll need the inverse shape of what you've just drawn. So, create a new layer, call it masks, and draw two rectangles: One that covers the playfield, and another that covers the plywood edge (turn Smart Guides back on for this, and make sure to snap to the edges of the artboard). Color them differently and name them full and plywood. Duplicate full by hitting CTRL+C and CTRL+F. Hide the copy and lock the masks layer so only the wood mask layer is unlocked. Hit CTRL+A to select all the wood mask shapes, and duplicate them with CTRL+C, CTRL+F. Unlock the masks layer, Shift-select the full rectangle, open the Path Finder tool and hit the Minus Front button. Select the masks layer, right-click on the selected shape, and click Arrange -> Send to Current Layer. Rename the new object <Compound Path> to wood. Hide the reference and wood mask layer. The result should look like this: Export this as a black on white PNG: Hide plywood and fill wood black. Click on File -> Export -> Export As, choose type PNG, check Use Artboards, and name it wood-mask. Under Resolution, choose something that is at least as large as your albedo (if you haven't resized the playfield scan after pasting into Illustrator, 72 dpi will correspond to the original resolution). Set the Background Color to White. Insert Mask Before we export the playfield as SVG for Blender, we need to create the polygons that are placed over the inserts, so we have something to render the ink on. We still have our wood mask layer, so hide everything else but this and the reference layer. Drag and drop the wood mask layer onto the \"plus\" icon at the bottom of the Layers panel to duplicate it. Name it insert mask. Hide wood mask and delete all polygons that haven't anything printed on it. For Tron, it looks like that: Now we have everything we need for the playfield mesh. Hide the reference layer, unhide the masks layer (with both wood and plywood visible), hit CTRL+A, CTRL+C, File -> New -> Create, CTRL+F. Then, resize the artboard so it fits the content. Click on File -> Save A Copy, choose type SVG, and name it playfield.svg. In the SVG Options dialog hit More Options and uncheck everything. Also, set Decimal Places to 5. Note The reason of doing it this way is that when \"exporting\" instead of \"saving a copy\", Illustrator saves the file differently, which often ends up in an erroneous import in Blender. Save A Copy also saves hidden layers which we don't want, that's why we create a new document. These three layers are exported as SVG. Ink Mask Next up is a mask that will allow us to differentiate between the ink, the wood and the alpha channel above the inserts when creating the material. If your playfield has absolutely no visible wood, just mask out the ink on the inserts. But chances are that it has, specially inside the slingshots and around the triggers. Create a new layer and name it ink mask. Draw shapes around everything that is not ink. This includes wood, inclusively any holes, and the part of the insert drawers that aren't printed on. Close up, it looks like this: Once you're done, export it as a white on black PNG: Make all shapes white, File -> Export -> Export As, name it ink-mask.png, don't forget to check Use Artboards, and choose black Background Color. This is how it looks for Tron (black background added for illustration purpose): Fake Holes Since we will not physically cut out all holes into the playfield mesh, there will be many smaller and some bigger holes where posts, pins, screws, wire guides, bumpers, and other things are attached to. Sometimes they are even visible, but not recognizable as a full-featured hole. Masking those elements out allows us to use a proper height map later when creating the materials. It also allows us to replace the scanned wood with a high-quality material, and still be able to exactly know where to position elements on the playfield. Once you're done, export this as a white on black PNG the same way you did with the ink mask just before, and name it fake-holes-mask.png (don't forget to check Use Artboards). Other Masks Tron has two special features: Mylar stickers to protect the playfield, and the Limited Edition has silver paint around the inserts. We'll draw those as well and export the masks white on black as mylar-mask.png and silver-mask.png. The reason to mask out both of these features separately, is that we can create special material properties in Substance Painter later. For example, the silver layer will have a much smoother surface than the ink, while being metallic, and the Mylar layer will have a different height and roughness. Conclusion To wrap up, we've now created an albedo texture and several masks that will allow us later to texture the playfield. This is how our folder looks now: This concludes our time in Illustrator. Let's close it and continue with Blender in the next step."
  },
  "creators-guide/tutorials/realistic-playfield/2-modeling.html": {
    "href": "creators-guide/tutorials/realistic-playfield/2-modeling.html",
    "title": "Create a Realistic Looking Playfield - The Mesh | VPE Documentation",
    "keywords": "Create the Playfield Mesh Import the Shapes Open Blender and delete everything (press A, X, D). Click on File -> Import -> Scalable Vector Graphics (.svg) and choose playfield.svg which you exported in the last step. Select wood in the outliner, move your cursor over the viewport and hit numpad . (zoom in on selected), numpad 7 (top view). If you haven't grouped your inserts, you'll have a bunch of \"Curve\" objects. Select them all and hit CTRL+J to join them. Rename the joined object to inserts. Hit A and choose Object -> Set Origin -> Origin to Geometry. You should see something like this: Make sure that all three shapes (inserts, plywood and wood) are there. Extrude Select the wood object. Under Material Properties, remove the SVGMat material so we better see the shape. Convert the shape to mesh by choosing Object -> Convert To -> Mesh. Hit Tab for edit mode, A to select all, then clean up the mesh by going to Mesh -> Cleanup -> Limited Dissolve, followed by M and By Distance (merge by distance). Hit E to extrude and eyeball it to something more or less accurate - but remember the number (you can of course always measure and type in the number). Hit Tab to go back to object mode. Smooth Since our cuts are round, let's smooth out the mesh. Select Object -> Shade Smooth. Don't panic, we'll fix the normals. Switch to edit mode (Tab) and select one of the top faces. Hit Shift+G and select Coplanar. While holding Shift, select one of the bottom faces. Hit Shift+G again and choose Coplanar. Press CTRL+I to invert the selection. Choose Select -> Select Loops -> Select Boundary Loop. You now have all edges of the inserts as well as the outer borders selected. Make these edges sharp by selecting Edge -> Mark Sharp. Hit A to select all and choose Mesh -> Normals -> Reset Vectors. You should how have a mesh with a flat, uniform top and smooth inserts. Maybe now it's a good time to save your project. Name it Playfield.blend. Convert Other Objects We don't need to extrude the other objects but convert them to a mesh so we can UV-map them. Exit edit mode with Tab and select the inserts object. Remove SVGMat, select Object -> Convert -> Mesh, and hit Tab for edit mode. Press A to select all, select Mesh -> Cleanup -> Limited Dissolve, and hit M, By Distance. Exit edit mode by pressing Tab. Since we extruded to the top, we need to align the inserts mesh. Hit G, Z, and type the distance you remembered when extruding. Finally, select the plywood object, remove its material and convert it to a mesh as well. The result should look like that: UV-Map Now we will map our objects, so they perfectly align with the masks we've created in the previous step. There is just one add-on for Blender that we need to install first, to make this quick. The add-on is called TexTools. Go to the GitHub page and download the archive of the repo. In Blender, choose Edit -> Preferences -> Add-ons, click on Install, select the downloaded archive, and enable the checkbox after installation. Then, close preferences. Seams Now we'll create seams for the plywood edges so we can easily unwrap them. We'll create them on the side facing the player, so they aren't visible when playing. Hide the inserts and plywood objects, and orbit 180° around your table in the viewport. Select wood, Tab for edit mode, 2 to select edges. Then, Shift-select one edge of each hole in the mesh. Additionally, select the four outer edges of the mesh. When done, click on UV -> Mark Seam. Hit Tab to exit edit mode, and unhide the inserts and plywood objects again. Change to the UV Editing workspace. On the right, be sure to be in object mode, hit 7 for top view, and A to select all. Then Tab for edit mode, and 3 for face selection (it's important to have all objects selected before switching to edit mode). Top Surface Let's map the top surface first. Select a face of wood's top surface, hit Shift+G and choose Coplanar. Make sure that besides the wood surface, also the inserts and the plywood mesh (but not the bottom surface or the edge faces) have been selected. Then click the UV menu and select Project from View (Bounds). The Bounds part is important, because it will spread the map across the entire tile, aligning it with our maps. Hit Tab to exit edit mode. Bottom Surface Select the wood mesh. Hit Tab for edit mode and select one of the faces of the backside. Press Shift+G and choose Coplanar to select the entire surface. Then hit 7, 9 and choose UV -> Project from View. On the left, move the mesh outside of the UV tile by selecting the island and hitting G. Plywood Edges Next are the plywood edges. With the bottom surfaces still selected, Shift-select one face of wood's top surface, Shift+G, Coplanar, followed by Ctrl+I (select inverse). Now, only the edges should be selected. From the UV menu, choose UV Unwrap. On the left, you should see all edges unwrapped as rectangles. Note If you forgot to mark a seam, you'll get circular islands like this: In this case, simply select an edge of each of the island, select UV -> Mark Seam, and UV Unwrap again. Now, on the left, hit 4 for island selection mode, and select all horizontal islands. Hit R, type 90 and Enter. Type A to select all islands, open TexTools by hitting N and selecting TexTools, expand the UV Layout section, and left align all islands. Hit G, X and move them to the left side, out of the tile. Press Tab to exit edit mode. Place the Islands Now we need to place the edge islands as well as the bottom surface back on the tile. We didn't do that before, because we need the top surface mapping visible in order to know where to place them. On the right side, hit A to select all, then Tab to enter edit mode. Move the split view a bit to the right, so you'll have more space on the left. First, by using G, R and S, place the bottom surface wherever there is a bit space left. Then, grab all the edge islands and make them fit into the plywood rectangle. It doesn't have to be super precise, since you can later align the texture in Substance, but it shouldn't overlap with the top surface and should stay inside of the UV tile. You might need to X-resize some of the edge islands. The goal is to fit them all in on top of the plywood object. Export Mesh work is nearly done :) Back in the Layout workspace, in object mode, select wood and under Modifier Properties, add the Triangulate modifier. Do the same for inserts. Then, select inserts and wood and click on File -> Export -> FBX (.fbx). Check Limit to Selected Objects. Name it Playfield.fbx and hit Export FBX. Let's texture this!"
  },
  "creators-guide/tutorials/realistic-playfield/3-texturing.html": {
    "href": "creators-guide/tutorials/realistic-playfield/3-texturing.html",
    "title": "Create a Realistic Looking Playfield - Texturing | VPE Documentation",
    "keywords": "Texturing We'll be creating a rather sophisticated material for our playfield. There will be a bunch of different materials, which altogether will result in a PBR texture set that we can use in Unity. Start up Substance Painter. Select File -> New and use the PBR - Metallic Roughness Alpha-blend template. Set the document resolution to 4096 and select the FBX file exported from Blender. Save your project as Playfield.spp. Note We don't need any baking in this tutorial, so we'll skip it to keep the file size smaller. However, if you would use any smart materials in your texturing, baking at least the curvature map and thickness map is required for the material to work correctly. Setup Let's start by masking out the top surface and the plywood edge. Under Layers, delete Layer 1 and create two folders. Name them Edges and Surface. Right-click on the Surface layer and choose Add white mask Hit F1 to see both the 3D view and UV tile Select the Polygon Fill tool Set the color under Properties or in the top toolbar to black Draw a rectangle over the UV tile's left border to fill the edge polygons Alt-click on the mask to verify that only the left border is black: Do the same for the Edges layer, but invert the mask: Right-click on the Edges layer and choose Add black mask Set the color to white Draw a rectangle over the UV tile's left border to fill the edge polygons Alt-click on the mask to verify that only the left border is white: Hit F2 to show the 3D view only, and switch back from Mask to Material in the drop-down of top right corner. Ink Material Create a new folder inside of Surface and call it Ink. Albedo Inside of Ink, create a fill layer and name it Albedo. Under Properties, Alt-click on color to make it albedo only. Grab albedo.png from your file system's explorer and drag and drop it into the Assets panel (on the left side). In the import dialog, click on undefined and select texture. At the bottom select to import to project 'Playfield'. Drag albedo from the assets panel into the Base color channel of the Albedo layer. Finally, right-click on the layer and select Add anchor point. Height and Roughness We're going to stack three effects on top of each other: In a CMYK printing process like a playfield, each color gets applied on top of each other. What we can do to mimic this effect is to grab the grayscale image of the albedo and interpret it as height map, where black is highest and white lowest. Ink is never applied perfectly evenly, so there are little bumps that should be visible. A playfield that has been in use has micro scratches from the ball. But first, let's set the base values. Just above the Albedo layer, create a new fill layer and call it Base Height/Roughness. Under properties, Alt-click on height and click on rough. Set the height to 0.004 and the roughness to 0.15. Noise and Scratches Now we're going to add another layer that contains the ink imperfections and the micro scratches. Add a new layer above Base Height/Roughness and call it Wear. In the Properties panel, Alt-click on height to make it only affect the height. Set Height as uniform color to -0.1. Right-click on the layer and add a black mask. Add a fill effect to this mask and call it Noise. Click on grayscale and search for Fractal Sum 1. Zoom in a bit and use Shift+Mouse Right to rotate the environment map. Move the light source in front of you so you see the reflection the height is causing. Now, this is way too much noise, but it allows us to tweak it better before we tune it down. The first thing to do is not to UV-project, which is the default. In general, you should only UV-project when you know that the aspect ratio of your UV mapping is correct, which isn't the case here. So, the Noise effect still selected, change the Projection under Fill to Tri-planar projection. You'll immediately notice how the noise is less skewed. Then, the size of the bumps is way too high as well. Still under Properties, look for UV transformations, and set the scale to 5. Finally, make the effect more subtle by selecting the Wear layer (not the mask), and changing the Height at the bottom of Properties from -0.1 to -0.01. That's better. Now let's add some scratches. Click on the mask of Wear again, and add another fill effect, above Noise. Call it Scratches. You'll notice that this makes the noise disappear, but that's fine for now. Under Properties, change the Projection to Tri-planar projection like before. Click on the grayscale button and search for a texture named Grunge Scratches. You'll notice that the scratches now actually pop up instead of going down. Let's fix that by setting Invert to true down under Parameters. In order to get the noise back, change the blend mode of Scratches to Linear Dodge (Add). Use the slider just besides to make the effect more subtle. Do the same for the Noise effect until you're happy with it. Here, it looks good with Noise at 70 and Scratches at 40. You can always tweak this later. Ink Height Create another fill layer above Wear and call it Ink Height. Alt-click on height to make it height-only and set the height to -0.1. Right-click on the layer add a black mask. Add a fill effect to the mask and name it Ink Alpha. Click on grayscale to select a texture, switch to the Anchor Points tab and select Albedo. Again, much too high, so select the layer again and dial in the height. Here, it looks good around -0.0088. Subtlety is key. Wood Having created an ink mask allows us to use a proper wood material for what's below the ink. Under the Ink layer, add a new folder called Wood. Now, a good wood material that works well for playfields is titled \"Oak Wood\" by Casimir Perez. It's part of Adobe's free Substance materials, and you can download it here. After downloading, drop it into the library and from the library into the Wood folder. Hide the Ink layer so we can parameterize it correctly. I've found the following setting to work well: Projection: Tri-planar projection Scale: 5 Rotation: 90° Color: #CC9166 Roughness: 0.18 Also, hit Random a few times if you don't like the pattern. Let's mask this out, since we don't want any of the channels influence the ink, and we don't want wood under the meshes that covers the inserts either. Right-click on the Wood folder add a white mask with a fill effect named Wood Mask. Drag and drop wood-mask-01.png into Assets, import it as alpha into project 'Playfield'. Then drag the imported texture on Wood Mask's grayscale. This does the inverse of what we want (i.e., it shows the wood only over the inserts). To fix this, right-click on Wood Mask, choose Add filter, click on filter, and choose Invert. Now we have masked out the inserts, but we still have wood over the ink. To fix this, create a new fill effect above the Invert filter, name it Ink Mask, import ink-mask-01.png and assign it to the fill effect. Select the blending mode to Multiply. In order to make the wood visible below the ink, do the following: Re-enable the Ink layer Add a white mask to the Ink layer Add a fill effect called Ink Mask to the mask Click on grayscale and search for ink-mask-01. On top of Ink Mask, add an Invert filter Your playfield should now have the ink properly masked out and sitting on top of the wood. Inserts Let's look at the inserts. What we want is to apply our ink mask as an alpha mask on the insert meshes. Create a new folder layer above Ink and call it Inserts. Add a white mask and a fill effect called Wood Mask. Click on grayscale and search for wood-mask-01. Within the Inserts folder, create a new fill layer and name it Opacity. Alt-click on op under its properties to only activate the opacity. Set the opacity to 0. Right-click on the Opacity layer, add a white mask with a fill effect named Ink Mask, and set the fill effect's grayscale to ink-mask-01. Unfortunately, this results in edges around the ink over the inserts, since the albedo below has been masked out by the wood mask. In order to fix that, add another fill layer below Opacity, make it color only, and assign the Albedo anchor point to its color. This should make the insert overlay to be cut out correctly. Fake Holes Remember the fake holes mask we've created so we can use them as markers on the playfield? Let's do those. Create a new folder layer above Inserts called Fake Holes. But before we add anything to it, we need to mask out a few things. Click on the mask of your Wood folder, where the Ink Mask is the top effect. Add another fill effect called Fake Holes Mask. From your file explorer, drop fake-holes-mask-01.png and import it into your project as an alpha. Assign it to the Fake Holes Mask fill effect and set the blend mode to Subtract. You should now see gray spots in your wood. Go back to your new Fake Holes layer and add a white mask with a fill effect called Fake Hole Mask. Click on grayscale and find fake-holes-mask-01. In the Fake Hole folder, add a new fill layer and call it Material. Only enable color, height and rough on it. Set the color to #050505, the height to something like -0.08, and roughness to let's say 0.7. Which holes here are fake? Edges We have ignored the edges so far. Create a new fill layer under the Edge folder. Name it Albedo and Alt-click on color to make it color-only. Click on Base color and search for albedo. This will directly apply the texture as you have mapped it in Blender. If you want to align the mapping, hit F2 to see the mapping on the UV tile, which allows you to resize and move the texture. You could also use a completely different texture of course. But let's stick with the current one. It needs a bit of adjusting. First of all, looking at it from a distance, it's kind of boring, nearly like solid colors. Right-click on the layer and choose Add filter. Click on Filter and select Sharpen. At 1 it looks better already, but tweak as you feel like. Secondly, the colors are slightly off. Add another filter effect and choose Color Balance. In our case, increasing the reds and magentas of midtones and highlights does the trick. Plunger Lane One of the drawbacks of replacing the scanned wood with a material from Substance Painter is that the plunger lane, which is typically cut into the wood, becomes invisible. So, let's add this back. Just above the Wood folder, create a new folder layer called Plunger Lane. Inside, add a new fill layer and name it Albedo. Make it color only, click on Base color, search for albedo, and choose your previously imported playfield scan. Now we have the scan replacing all our wood, which we don't want. Right-click on the Albedo layer and add a black mask. Right-click on the mask and add a paint effect. With the brush tool, use a soft brush to draw back the plunger lane of the original playfield scan. Use X to swap between painting black and white. After masking, it should look similar to this: Now, this doesn't really match the surrounding colors. Click on the left preview icon of the Albedo layer, right-click and select Add filter. Click on Filter and look for Color Balance. Manipulate the parameters so they colors match the surrounding wood. Then, add another filter, select Color Correct, and adjust the parameters to further improve. Finally, if you see that your scan is softer than the generated wood, add a Sharpen filter to compensate. The final result here looks like this: Let's also add a proper height map. I've simply drawn a triangle on the lane and exported it as PNG (download). Above the plunger lane's Albedo, create a new fill layer named Height. Alt-click on height to make it height only. Right-click on the layer, add a black mask with a fill effect. Import plunger-height.png and assign it to the fill effect. Set UV Wrap to None. Alt-click on the mask icon of the layer to visualize it, select the Fill effect again and hit F1 to place the texture over the plunger lane. On top of the fill effect, add a filter effect and select the Blur filter. Adjust it so it blurs similar to this: Hit F2 and set the viewport from Mask back to Material. Play with the layer's Height while rotating the environment lights until you're satisfied. You can also go back to the mask and adjust the amount of blurring. Wrapping Up This tutorial is already long enough, so we've created a separate page for dealing with our Mylar sticker and silver paint. Here, we're going to wrap up and get this exported. But first, there is one last thing we need to do, which is making sure our material is PBR valid. PBR valid basically means that the color of your textures isn't too light or too dark. There is no such thing as absolute black in the nature, and if we provide such values, there will be problems when rendering later. More literature about this can be found here under \"Base Color (RGB – sRGB)\". Download the free \"PBR Validate\" smart material and drop it at the very top of all the layers. Here, it looks like that: Red means there's a problem. This is most definitely the playfield's albedo that is too dark. Adding a Levels effect to the ink's albedo and pushing up the lower boundary to 0.01 already solves most of the problems. The rest seems related to the fake holes. Looks like #050505 was way too dark. Pushing up to #1E1E1E turns the rest of the playfield green. Here our fully textured playfield. Export First of all, if you have come so far, congrats. That was quite a ride. The rest is a lot easier. What Unity needs is a set of maps. In HDRP, those maps are the base map (aka albedo), a mask map, and a normal map. Substance Painter can generate those automatically. However, since Painter usually deals with multiple materials, it will add the material name into each map's file name. For the playfield, we don't want that, because we only have one material. If you go to File -> Export Textures, a dialog pops up where you can edit the output templates. Click on the tab called Output Templates and find the one called Unity HD Render Pipeline (Metallic Standard). Click the duplicate icon on the top, and double click the copy to rename. I just called it Unity HDRP. Rename the three maps to: $mesh_BaseMap(_$colorSpace)(.$udim) $mesh_MaskMap(_$colorSpace)(.$udim) $mesh_Normal(_$colorSpace)(.$udim) I've removed the fourth map, the emissive map, because we don't need it. Hit Save Settings to close, because we want to do one last thing before exporting. In the Texture Set Settings panel, disable the lock icon and set the texture resolution to 2048×4096. This will not squeeze your 2:1 playfield into a 1:1 texture anymore but use a more appropriate aspect ratio. Now, to export, click again on File -> Export Textures, select the folder where you want to put your textures in (usually in your Unity project folder at Assets/<table name>/Textures), change the output template to Unity HDRP (the one you created before), and hit Export. Note If you happen to have an 8K playfield scan, you can set the Size to 8192 before exporting. This will write your maps at 4096×8192. On first sight, the result doesn't look like much, so let's bring this into Unity!"
  },
  "creators-guide/tutorials/realistic-playfield/3b-more-texturing.html": {
    "href": "creators-guide/tutorials/realistic-playfield/3b-more-texturing.html",
    "title": "Create a Realistic Looking Playfield - Texturing (advanced) | VPE Documentation",
    "keywords": "Texturing (details) Most projects probably don't have Mylar stickers or silver paint on the playfield, which is why we decided to dedicate a separate page for this. If you have something similar to add to your playfield, do it before the Wrapping Up section of Texturing. Mylar Stickers We find those in-between the bumpers and at a few other places, and their texture is obviously different than the rest of the playfield. First of all, we don't want the wear of the ink to influence our stickers. So go down to Ink and click on the mask of the Wear layer. Add a new fill effect above Scratches and name it Mylar Mask. Set the blend mode to Subtract. Import mylar-mask-01.png as alpha and assign it to the fill effect's grayscale. The sticker is already visible: Go up to the top and create another folder layer above our existing Fake Holes layer and call it Mylar. Add a white mask and a fill effect named Mylar Mask, and search for mylar-mask-01 for its grayscale. We're going to create two fill layers in here. One for the general height and roughness, and another for the texture. Name the first Base Height/Roughness and the second Texture. The second sits above the first. Base Height/Roughness Select this layer and disable all channels but height and rough. We want the sticker to come up, so set the height to something small like 0.0016. In terms of roughness, we want the sticker to be \"less glossy\" than the ink besides it, so 0.17 looks like a good value. Texture The texture should only be applied to height, so Alt-click on it. For its values, I've gone for Directional Noise 4 with Tri-planar Projection and otherwise default parameters. At 100% this effect is way too high, so I've set the view mode of the layers to Height in order to be able to turn down the opacity to 4. The final result looks like this: Silver Paint The silver paint goes around the inserts, where our Pro playfield scan has normal ink. Due to our height map, which means a slight downwards bevel, where it actually should go up. Let's fix that. Under the Ink layer, we have another Ink Height layer, which has Ink Alpha on its mask. Add another fill effect above and name it Silver Height. Set the blending mode to Subtract. For the grayscale values, import silver-mask-01.png and assign it. Then, add another fill layer above Ink Height and name it Silver Paint. Make it apply to color, height, rough and metal with the following values: Color: #E7E7E7 Height: 0.02 Roughness: 0.0837 Metallic: 1 Finally, apply the silver mask to the layer. The result is a nicely reflective material around the inserts:"
  },
  "creators-guide/tutorials/realistic-playfield/4-import-into-unity.html": {
    "href": "creators-guide/tutorials/realistic-playfield/4-import-into-unity.html",
    "title": "Create a Realistic Looking Playfield - Unity | VPE Documentation",
    "keywords": "Import Into Unity In the last part of this tutorial, we'll import and place the model into the Unity scene, create materials and assign them to the model. Import Files First, let's bring our files into the Unity project. There are four files that go into the Assets folder: The three maps and the FXB file. Copy the FBX file into Assets/Tron/Models and the textures into Assets/Tron/Textures/Playfield. While the import options for the FBX file are fine, we need to adjust them for the textures. Select the base texture and change the following options in the Inspector: Alpha Is Transparency: enabled Max Size: 4096 (or 8192 if you exported at 8K in Substance) Hit Apply. The mask map: sRGB (Color Texture): disabled Max Size: 4096 (or 8192 if you exported at 8K in Substance) Hit Apply. The normal map: Texture Type: Normal map Max Size: 4096 (or 8192 if you exported at 8K in Substance) Compression: High Quality Hit Apply. Now we got our files ready. Let's bring in the model. Import Model The idea here is to put the model at the same position as the original playfield, and then hide the original playfield. Since this is the probably the first tutorial for many, we'll go a bit more into details of how Unity works and its quirks. This is our starting point. The playfield is the original import from a VPX file, and all the other elements are hidden. You can hide elements by selecting them and unchecking the top-left checkbox in the Inspector. Note Crash course in Scene navigation Move the camera like in a first-person shooter. Hold the right mouse button, then use the WASD keys for horizontal movement, Q and E for vertical movement. The mouse wheel changes the movement speed. Just panning the screen is done while holding the middle mouse button. Full documentation here. In the Project panel you see our FBX file. It's a tree structure because Unity imported it and found out that it contains two objects and two meshes. Drag the entire Playfield object from the Project panel into the Hierarchy and drop it over the Playfield GameObject. You'll probably see... nothing. That's because the scale of the playfield model is completely off the charts. While your new Playfield GameObject is selected (which, by the way, I'd like to move to the top among its siblings), move your mouse over the Scene (the 3D viewport), and press F for focus. Unity now zooms in (our out?) to your imported playfield. It does it with an animation, so that gives you a hint whether the imported playfield is too large or too tiny to be seen. In our case, it zoomed in, but it's still too tiny to be visible. In this case, an approach is to click on the parent GameObject (also called Playfield), hit F to zoom out again, and start increasing the Scale of our imported model in the Inspector. Before doing that, click the little chain icon to lock the proportions. At scale 1000 we're starting to see something. However, it's oriented incorrectly. Setting the X-rotation to -90 and Z to 180 fixes that. Now, we need to align the model over the existing one. For that, let's switch into orthogonal camera view by clicking on the small Persp icon in the top right corner of the Scene view, followed by a click on the Y axis of the 3D gizmo to switch to Top View. Click the shading mode icon and choose Wireframe. This allows you to align the playfield without anything being hidden. Using the move (W) and scale (R) gizmos to align the imported playfield with the existing one. Warning When the camera is in orthogonal mode, it can happen that nothing is rendered or that meshes start disappearing. This is due to camera clipping. To fix, move the camera back by pressing S while holding the right mouse button. Once done, switch the shading mode back to Shaded, select the parent Playfield GameObject in the Hierarchy and uncheck the Playfield Mesh component in the Inspector. Now, to the fun part. Create Materials We'll need two materials. A solid one for the body and a translucent one for the insert overlays. Select (or create) the Materials folder under Assets in the Project window, right-click on the right and select Create -> Material. Name it Playfield. In the Inspector, under Surface Inputs, you'll see multiple slots for maps. While the Playfield material is still selected, change to the Textures/Playfield folder where your maps are stored. Then, drag and drop each map to the corresponding slot in the Inspector. Your material should look like this: In the Project view, switch back to Materials, select Playfield and hit CTRL+D to duplicate. Name the new material Playfield Inserts. While selected, change the Material Type in the Inspector from Standard to Translucent. Additionally, enable the Alpha Clipping checkbox. Still in the inspector, scroll down to find Diffusion Profile (right below the maps under Surface Inputs). Then, in the Project window, expand Packages and navigate to Visual Pinball Engine (HDRP) -> Assets -> Settings -> Diffusion Profiles. Drag the Plastics profile into the material's diffusion profile slot in the Inspector. Assign Materials Select the wood GameObject. In the Inspector, inside the Mesh Renderer component, expand Materials and drag the Playfield material from the Project panel into the slot where currently DefaultHDMaterial is shown. Select the inserts GameObject and do the same with the Playfield Inserts material. This looks pretty good already, but when zooming in, the structure in the reflection is a bit too extreme. This is quickly fixed by decreasing the Normal Map parameter in both playfield materials. Here, 0.5 does its job just fine. Future Changes So, you're all happy with your playfield, when suddenly you realize that you need to change something. Here a few hints of what you'll need to do depending on what you need to change. Material Updates - Updates in Substance Painter are the quickest - Make changes and re-export the textures, that's it. Unity will automatically pick up the changes. Mask/Texture Corrections - These are pretty painless too - re-import the new image into Painter, then click the Resource Updater icon in the left toolbar and hit the Update button where it's orange. Then, re-export. Missing Hole or any geometry changes - This is the annoying one. Since our workflow in Blender is destructive, you'll probably need to recreate the mesh. If you decide to fix the geometry of the existing mesh, make sure you update the wood mask accordingly. Before exporting to FBX, make sure you name your objects in Blender the same as before, so Substance Painter can pick them up. If you kept a material in Blender, its name must be the same too for Substance Painter to recognize it. Then, in Painter, select Edit -> Project Configuration -> Select... to update your model, and Painter will re-apply the layers on the new model. Finally, re-export the textures and copy the new FBX to Unity's asset folder. That's It! We hope you've enjoyed this tutorial. It might have been one of the first ones you went through. If you were stuck somewhere, please let us know in the forum so we can fix it. If you have improvements, use the button on the top right side on each page. More info about that here. Enjoy, and we're looking forward to what you're coming up with!"
  },
  "creators-guide/tutorials/realistic-playfield/index.html": {
    "href": "creators-guide/tutorials/realistic-playfield/index.html",
    "title": "Create a Realistic Looking Playfield | VPE Documentation",
    "keywords": "Create a Realistic Looking Playfield Every table build starts with the playfield. You'll be looking at it a whole lot of time, so let's make it worthwhile. We'll use Photoshop to create the albedo source texture, Adobe Illustrator to mask out the materials, Blender to create the 3D model, and Substance Painter for the texturing. Note We're aware that most of the software used here is commercial and not free. While Illustrator can be easily replaced with Inkscape and Photoshop by any pixel-based image editor, there isn't a good free alternative for Painter yet. Good news is that Blender will invest significantly in texturing tools this year (2022), but until then, you may be able to use the trial version of Painter. There is also a non-subscription-based version at Steam. Technically, the playfield is purely for visualization, i.e., its geometry doesn't affect gameplay in any way. The advantage of VPE over Visual Pinball is that material properties such as reflection apply to all objects equally, so there is no need for a special \"playfield object\". In this tutorial, we'll assume that your playfield is flat. If that's not the case and you'll need a custom mesh for ball collision, we will provide an extension of this tutorial in the future. Overview The result of this workflow is two GameObjects. The first is the wood with holes cut out for inserts and where otherwise visible. The geometry is watertight, and the material is solid. The other GameObject contains the printed ink above the inserts. It consists of polygons that fit perfectly into the insert cut-outs of the wood. Its material uses the same textures as the wood, but it's translucent. The highlighted polygons represent the ink, elevated for illustration purposes (they will be co-planar with the playfield surface). The material we'll be creating takes into account the different surface types of the wood and the ink, irregularities of the ink as well as some micro scratches. We won't get too much into adding wear, tough. We'll be using the Limited Edition of Stern's Tron: Legacy as an example. It has two additional properties you might not see on every table: Mylar protection stickers on the playfield and silver paint around the inserts. We'll cover these on a page separate from the main tutorial. The final result in Unity. Prerequisites A playfield scan. It should be at least 2000×4000 pixels of size, and of decent quality, meaning that dust and other artifacts from the scan should have been removed. It doesn't have to PBR-valid, since we'll be dealing with that in Substance Painter. You should be familiar with a vector graphics software such as Adobe Illustrator and have basic Photoshop skills. You should know your way around in Blender. Beginner level is fine, but you should be able to navigate in the viewport, transform objects, know what UV-mapping is and know the basics about modifiers. You should have a basic understanding of how Substance Painter works, i.e., what layers and effects are and how they blend together. Workflow Create albedo texture and masks Create the mesh in Blender Texture the mesh in Substance Painter (Mylar and silver guide) Import mesh and material into Unity"
  },
  "creators-guide/vpe.html": {
    "href": "creators-guide/vpe.html",
    "title": "VPE Manual | VPE Documentation",
    "keywords": "Features Tutorial VPE Manual Game Items Pinball Mechanisms Scripting Physics Plugins About VPE About this Documentation Authors License and Copyright FAQ Glossary Contributing to VPE"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | VPE Documentation",
    "keywords": "Welcome to the documentation of the Start here with the creator's guide. Be aware we're at the very beginning of writing documentation. You'll see weird content."
  },
  "plugins/index.html": {
    "href": "plugins/index.html",
    "title": "Plugins | VPE Documentation",
    "keywords": "Plugins VPE has a plug-in system that allows other software to integrate with it. Plugins are typically required on a per-table basis. VPE ships with a number of default plugins which are documented here. PinMAME PinMAME is an emulator written in C which supports most of the hardware found in pinball machines the mid 1970's until 2014. Visual Scripting For original games or EM machines, we recommend using our visual scripting package which extends Unity's Visual Scripting. Mission Pinball Framework The Mission Pinball Framework is software written in Python that is used to drive real pinball machines. It integrates with VPE as a gamelogic engine."
  },
  "plugins/mpf/configuration.html": {
    "href": "plugins/mpf/configuration.html",
    "title": "Configuration | VPE Documentation",
    "keywords": "Configuration The MpfGamelogicEngine component offers many configuration options. For a brief description, you can refer to the tooltips that are displayed when you hover your cursor above an option in the Unity inspector. Executable source Select which version of MPF VPE should launch on startup. Included: Use the version of MPF included in VPE. It is slightly different from the official version. Manually Installed: Use the locally installed version of MPF available through the system PATH environment variable. Assume Running: Do not launch MPF at all. Assume it is running already. This option is intended for debugging MPF. Manual installation Warning If you choose manual installation of MPF, anyone who wants to play your table will need to install MPF first. If you want to use a version of MPF other than the included one, you can install it manually. Refer to the official installation instructions. The earliest version of MPF compatible with VPE is v0.55.0-dev.12. Startup behavior Select how VPE establishes a connection with MPF. Ping Until Ready: Repeatedly send a Ping message to MPF until it responds. This is the preferred method, but it only works with the included version of MPF. If MPF does not respond within the timeframe specified by the Connect Timeout option, VPE will give up and cause an error. Delay Connection: Delay the Start message by a number of seconds specified by the Connect Delay option assuming MPF is ready to receive it by then. If MPF is not ready, startup will fail and the table will not work. If MPF starts up faster, this delay slows startup needlessly. This method is compatible with all version of MPF since v0.55.0-dev.12. Machine folder The file path to the machine folder of your table. When the package is first installed, it will create a default machine folder in the Assets/StreamingAssets directory of your Unity project. The path to this directory is the default setting. You can store your machine folder elsewhere, but be aware that the StreamingAssets directory is special. Unlike files located in other parts of your Unity project, Unity will not convert its contents into a binary format when you build your Unity project into a standalone application. It will therefore remain readable for MPF. It will also not go missing if you move your Unity project or a build of your Unity project to another computer. Media controller Select the media controller MPF should attempt to connect to on startup. None: Do not connect to any media controller Godot or Legacy MC: Use the officially supported media controller of whatever MPF version is running. MPF versions since v0.80 will attempt to start and connect to the new Godot-based media controller. MPF versions prior to v0.80 will attempt to start and connect to the legacy Kivvy-based media controller. The version of MPF included in VPE is v0.80.0, so it will use Godot. If you choose this option, you must manually install the appropriate media controller. Included: Use the media controller included with VPE's MPF plugin. If selected, you can also configure the port through which the media controller will communicate with MPF and whether or not to log sent and received messages to the Unity console. See Media Controller for more information. Other: Do not start any particular media controller, but attempt to connect to an already running media controller. The IP and port to connect to can be configured in MPF. If you choose this option, you are responsible for starting a media controller. Output type Select the format and presentation of MPFs output. None: MPF will not produce any live output. It will still produce log files. Table in terminal: A command line table view that shows you the active modes and the states of your switches. Log in terminal: Log events and errors to a terminal window as they happen. Log in Unity console: Log events and errors to the Unity console as they happen. Errors may not always be labeled as such. Verbose logging Enable this option to get additional information from MPF. Sometimes useful for debugging. Not advisable on Windows in combination with the Table in terminal Output type because the Windows terminal is slow. Cache config files Whether or not to cache config files to speed up the next startup. MPF will always parse config files that have been changed. Force reload config From the MPF documentation: Forces MPF to reload the config from the actual YAML config files, rather than from cache. MPF contains a caching mechanism that caches YAML config files, and if the original files haven't changed since the last time MPF was run, it loads them from cache instead. Cached files are stored in your machine's temp folder which varies depending on your system. Force load all assets on start From the MPF documentation: Forces MPF to load all assets at start (rather than the default behavior where some assets can be loaded only when modes start or based on other events). This is useful during development to ensure that all assets are valid and loadable."
  },
  "plugins/mpf/index.html": {
    "href": "plugins/mpf/index.html",
    "title": "Mission Pinball Framework | VPE Documentation",
    "keywords": "Mission Pinball Framework MPF is an open-source framework written in Python to drive real pinball machines. It has a \"configuration over code\" approach, meaning that 90% of what you'd do in a pinball game can be achieved through configuration (YAML files) rather than implementing it in code. When you read MPF's Getting Started page, you'll notice a banner stating that \"MPF is not a simulator.\" Well, you've found the simulator. ;) This project lets you use MPF to drive game logic in VPE, a pinball simulator based on Unity. It does this by spawning a Python process running MPF and communicating with VPE through gRPC. MPF is available on Windows, macOS, and Linux."
  },
  "plugins/mpf/media-controller.html": {
    "href": "plugins/mpf/media-controller.html",
    "title": "Media Controller | VPE Documentation",
    "keywords": "Note The VPE media controller is very basic compared to the fully featured Kivvy and Godot based media controllers by the MPF developers. Media Controller MPF is designed with real pinball machines in mind and those typically have a specialized circuit board for controlling the playfield hardware. To allow MPF to control your virtual playfield, VPE connects to MPF as if it was a stupid little circuit board that can do nothing but turn coils and lights on and off. As a result, MPF only gives simple orders to VPE without providing any information about the larger context within the current game, like what modes are active, how many players there are, or even what the score is. To get this information, VPE connects to MPF through a separate channel designed for controlling the displays and speakers in the backbox. Text To display variables from MPF (such as the current player's score) in a text field, you can use one of the following components: MPF Current Player Text shows the number of the player whose turn it is. MPF Player Count Text shows the number of players in the current game. MPF Machine Variable Text and MPF Player Variable Text show machine and player variables, respectively. For technical reasons, they each have three variants: String for text variables including symbols other than numeric digits Int for whole numbers Float for decimal numbers You can find these components under Pinball -> MPF Media Controller in the Add Component menu. Each component needs a text field to show the text. To create one, right-click in your hierarchy and select UI -> Text - Text Mesh Pro. If prompted, import the TMP Essential Resources, then drag the game object of the newly created text field into the Text Field box on the MPF text component. To learn about positioning and styling text fields and other UI elements, refer to the Unity documentation. Formatting By default, the text field will display the variable as it was received from MPF, but you can optionally specify a format string to customize how the value from MPF is converted to text. The most basic way to use this feature is to add additional text before or after the variable. For example, enter P{0} into the Format field of an MPF Current Player Text component to prefix the player number with the letter 'P.' Using more advanced format string features, it is possible to separate every third digit of the score number with a comma or round to a certan number of decimal places. You could learn how to do that and much more in Microsoft's introduction to string formatting in .NET. Or you could take the easy route and just ask some LLM to write your format strings for you. Sound To play a sound effect when the player unlocks an achievement or to add a soundtrack for a specific mode, use the MPF Event Sound and MPF Mode Sound components. Each one allows you to specify the name of an event or mode from MPF and a sound it should trigger. MPF Mode Sound has additional options for stopping the sound that are useful for music. Toggling Objects VPE's media controller can enable and disable game objects in the Unity scene whenever events occur or modes are triggered in MPF. While it is a far cry from what is possible with MPF's new Godot based media controller, this feature allows you to at least show and hide some graphics or videos when things happen in MPF without having to split your table across two game engines. The Enable During MPF Mode component enables its parent object during the specified MPF mode and disables it otherwise. The Toggle On MPF Event component enables its parent object when the Enable Event occurs and disables it when the Disable Event occurs. You do not have to specify both. If both are set to the same event, that event will enable the object if it is disabled and enable it when it is disabled. The MPF documentation contains a list of all events built into MPF. In addition, you can define your own. Lastly, make sure the objects you add these components to are intially enabled. They cannot begin receiving events until their parent object is enabled. If the object should be disabled initially, do not just disable it in the scene. For objects controlled by a Toggle On MPF Event component, use its Enabled On Start checkbox. Objects with an Enable During MPF Mode component will always be disabled on startup, at least until MPF starts the first mode."
  },
  "plugins/mpf/setup.html": {
    "href": "plugins/mpf/setup.html",
    "title": "MPF Setup | VPE Documentation",
    "keywords": "Setup Note You will need to have our scoped registry added in order for Unity to find the MPF package. How to do this is documented in the general setup section. Mission Pinball Framework integration comes as a UPM package. In Unity, add it by choosing Window -> Package Manager -> Add package from git URL: Then, input org.visualpinball.engine.missionpinball and click Add or press Enter. This will download and add MPF itself and VPE's MPF integration to the project. So let's test it."
  },
  "plugins/mpf/technical-details.html": {
    "href": "plugins/mpf/technical-details.html",
    "title": "Technical details | VPE Documentation",
    "keywords": "Technical details VPE connects to MPF using gRPC, which is a high-performance, low-latency RPC framework. When using MPF, VPE acts as a hardware controller. MPF does not \"know\" there is no real playfield. When VPE starts up, it will: Launch MPF as a Python process Create a gRPC client Connect to MPF Inform MPF about the starting states of all switches Query the machine description and check whether it matches the description saved earlier Tell MPF to start the game At runtime: VPE sends an update to MPF whenever a switch is opened or closed MPF sends commands to VPE to control coils, lights, and displays The MpfGamelogicEngine executes those commands When VPE shuts down, it will: Notify MPF that it is shutting down Disconnect from MPF and shut down the client Wait until MPF shuts down (or kill the process if it does not shut down within one second) Included MPF binaries VPEs MPF integration comes with a custom prebuilt version of MPF that is slightly different from the official version. VPEs version of MPF supports a Ping RPC that allows VPE to check whether MPF is ready without any side effects (like starting the game). This way, the game can start as soon as MPF is ready, regardless of how long MPF takes to start up. We have proposed this change to the MPF developers, but as of February 2025 they have not yet gotten around to including it in the official version. Therefore, you will need to set the Startup Behaviour of the MpfGamelogicEngine to Delay Connection if you want to use any official version of MPF. Hardware rules VPE supports MPF's hardware rules, which are dynamic connections between coils and switches that are handled by the hardware controller boards in real pinball machines in order to reduce latency, but they are useful for VPE as well. For example, when the player presses the flipper button on the keyboard, VPE already knows that the flipper coil should be activated and does not need to wait for a response from MPF, because MPF has previously told VPE that the flipper switch should activate the flipper coil. When the table goes into attract mode, MPF removes the rule and the flippers no longer work. This means that even though MPF runs in a separate process, using it to control your VPE table does not increase latency."
  },
  "plugins/mpf/usage.html": {
    "href": "plugins/mpf/usage.html",
    "title": "MPF Usage | VPE Documentation",
    "keywords": "Usage MPF support is implemented as a Gamelogic Engine. It's a Unity Component, so all you have to do is add it to the root GameObject of your table. To do this: Select the table in the hierarchy Click Add Component in the inspector Select Pinball -> Game Logic Engine -> Mission Pinball Framework. If there is already another game logic engine component attached, remove it. There can be only one. The machine folder All files that MPF needs to run your table are contained in the so-called machine folder. When the package is first installed, it will create a default machine folder in the Assets/StreamingAssets directory of your Unity project. This folder is already set up for use with VPE and contains the necessary configuration to allow MPF to drive the default VPX 'blank' table. This is all you need to know to get started, but if you are serious about creating a table using MPF, you should learn how to use it. The best way to do that is to follow the official MPF tutorial. Retrieve machine description Note While VPE could read the MPF machine config itself, we let MPF handle it. That means we run MPF with the given machine config and then query its hardware. While this is a bit slower, it has the advantage of coherent behavior between edit time and runtime, and doesn't add an additional maintenance burden. Since the game logic engine is the part of VPE that provides switch, coil, and lamp definitions so VPE can link them to the table during gameplay, you'll need to retrieve them from MPF. You can do this by clicking Get Machine Description in the MpfGamelogicEngine inspector. If VPE successfully retrieved the machine description from MPF, you will see the coils, switches and lamps defined in your MPF config file show up in the MpfGamelogicEngine inspector. The description will be stored in the component. You will only need to do this again when you update the MPF machine config or replace the MpfGamelogicEngine component. Visual Pinball Engine compares its stored machine description with the one used by MPF every time you start the game. Look out for this warning in the Unity console: Wire it up Now that VPE knows which switches, coils, and lamps MPF expects, you'll need to associate them with the appropriate game items on your playfield in Unity. Click on Populate Hardware in the MpfGamelogicEngine inspector and use the switch, coil, and lamp manager to create the neccessary references. You can watch the entire process in a quick video here: Note The MPF integration package has been updated since the recording of this video, so the user interface will look different for you, but the process is still the same."
  },
  "plugins/pinmame/index.html": {
    "href": "plugins/pinmame/index.html",
    "title": "PinMAME | VPE Documentation",
    "keywords": "PinMAME VPE integrates with PinMAME using a .NET wrapper called pinmame-dotnet, which under the hood uses a cross-platform build called libpinmame."
  },
  "plugins/pinmame/mechs.html": {
    "href": "plugins/pinmame/mechs.html",
    "title": "PinMAME Mech Handlers | VPE Documentation",
    "keywords": "PinMAME Mech Handlers A pinball table contains many mechanisms that interact with the ball. Classic examples are the flippers, kickers, or the trough. However, when we refer to PinMAME Mechs, we refer to very specific mechanisms involving a motor - usually toys of some sort. Mechs come in all forms and complexities. Some like the pole dancers in the Sopranos are for show only, while many others serve a very specifc purpose during gameplay. A few more examples are Rudy's eyes in Funhouse, the cannon in Terminator 2, the glove in Johnny Mnemonic which has full player control, or the spinning wheels in Whirlwind. To understand how PinMAME handles mechs, a bit of history is needed. Before there even was PinMAME (it was called WPCMAME at the time, because it would only emulate WPC games), the dev team needed some way to \"play\" the game so they could check the sounds and the animations of the ROM. So, what they did is they wrote a simulator that would close and open switches at the appropriate times to fool the game into thinking everything works as designed. For example, when T2's cannon is rotating and you push the fire button, it would literally calculate the position of the gun, and which drop target the ball would hit and enable the switch of that target after a short delay. Of course, PinMAME doesn't include a physical simulation that includes geometry and gravity and such, so the simulation of the ball trajectory was quite approximative. Then came along Visual Pinball, and \"physical\" simulation was not needed anymore. However, some calculations done by PinMAME's simulator were still of interest. Let's take again T2's cannon. The game starts the motor, which will then start rotating the cannon. At certain rotation angles, a physical switch tells the game how far the cannon has rotated. There is also an end position at which the movement changes direction, rotating the cannon back in the opposite direction. Just for knowing the rotation angle of the cannon there's a lot of math and timing involved. That's why PinMAME offers a way to provide the result of these calculations back to Visual Pinball with the GetMech() API. In the table script, you would tell PinMAME which mechs to simulate and regularly retrieve the result in order to just update the rendered elements on the playfield. Switches and coils involving the mech would also be handled by PinMAME. However, this worked only for a handful of fully simulated WPC games, and even for those, parameters needed to be tweaked, which was impossible with this approach. So, something more generic was needed. And this finally brings us back to our original topic: Custom mechs handlers, or PinMAME Mech Handlers as we call them. They work like the internal simulation but can be configured through an API. To sum it up, in Visual Pinball, there are three approaches today to deal with mechs: Use PinMAME's internal simulation - nearly never used. Configure a custom mech handler - occasionally used. Use timers and handle everything in the table script - the most common approach. This page is about approach #2 and describes how you can configure and use PinMAME mech handlers in VPE. Note Some toys like High Roller Casino's slot machine toy are too complex to be simulated with a PinMAME mech handler. Understanding how the toy works is key here. We will try our best to provide components that are able to cover most of your mech needs. Setup PinMAME can simulate up to five custom mechs. You create one by adding the PinMAME Mech component onto a game object. Note If you come from Visual Pinball, this component has the same function as the cvpmMech class in core.vbs. Type This defines how the mech is controlled. There are four options: One Solenoid - The motor turns in one direction only, and the solenoid turns it on and off. Example: Sopranos pole dancers. One Directional Solenoid - Two solenoids, one for enabling the motor, one for setting the direction. Example: The cannon in T2. Two Directional Solenoids - The first solenoid controls clockwise movement and the second solenoid controls counter-clockwise movement. Example: The soccer ball in World Cup Soccer '94. Two Stepper Solenoids - Two solenoids that control a stepper motor. Example: Drag strip cars in Corvette. Four Stepper Solenoids - Four solenoids that control a stepper motor. Only the first solenoid is defined and PinMAME assumes that the three remaining solenoids are the following coil numbers. Repeat How the mech behaves when the end of the range of motion is reached. There are three options: Circle - Loops, i.e., starts the motion again from the beginning. Reverse - Reverses the direction, i.e., moves back to the beginning. Stop at End - Automatically stops when the end has reached. Length The length is the amount of time, in milliseconds, that the specified solenoids must be enabled for, to move a single step in the progression from the start to end position. It indirectly defines the speed. Steps This is the total number of steps from the start to the end position. Every time a new step is reached the mech is updated with a new value. Movement, Speed and Output Value Check Linear Movement (default) if you need to simulate a linear movement, as opposed to non-linear movement. Check Fast Updates if the calculations should be updated at 240Hz, as opposed to 60Hz (default). Check Result by Length if you want the result to be based on the length, as opposed to the number of steps (default). Acceleration and Retardation By default set to 0, acceleration defines the amount of time in milliseconds required to reach full speed, while retardation defines the time required to come to a stop, in relation to acceleration. For example, setting of Acceleration = 50 and Retardation = 0.2 corresponds to 50ms to reach full speed and comes to a stop 10ms after the solenoid turns off. Both values are 0 per default. Switches A PinMAME mech can handle up to 20 switches. Depending on the type, they have different behavior and different parameters: A switch set to Enable Between will be closed by PinMAME when the mech position is between a range of defined steps. A switch set to Always Pulse is constantly closed and opened when the motor is running. You configure the frequency and the duration it stays closed. A switch set to Pulse Between is pulsed for one step with a configurable frequency during a range of steps. Note If you come from Visual Pinball, Enable Between corresponds to AddSw, Always Pulse to AddPulseSw, and Pulse Between to AddPulseSwNew. Switch and Coil Assignments As described above, a mech comes with at least one solenoid and up to 20 switches. In order to tell PinMAME which solenoid to listen to and which switches to trigger, we use the Coil Manager and the Switch Manager. Here is an example configuration that drives the gun in T2: Here, the PinMAME Mech Handler sits on a game object named \"Cannon\". Note The reason VPE uses the managers to assign the right number (as opposed to letting you specify it directly in the component) is that everything switch or coil related is at one place, and that the same principle can be re-used for other GLEs or components. Runtime During gameplay, PinMAME executes callback for each mech with the current step position."
  },
  "plugins/visual-scripting/complementary-usage.html": {
    "href": "plugins/visual-scripting/complementary-usage.html",
    "title": "Visual Scripting - Complementary Usage | VPE Documentation",
    "keywords": "Complementary Usage So far, we have talked about visual scripting driving the logic of a pinball game. But what if we need to add logic to an existing gamelogic engine, without replacing it entirely? For example, Rock (Premier 1978) isn't entirely emulated in PinMAME; the start-up light sequence is handled by an auxiliary board, and we're only getting control signals, but not signals for every individual light. In this case, we'd like to keep PinMAME as the driving GLE, but add a visual script that handles the light sequence properly. Setup In order to give VPE's visual scripting nodes access to your game logic engine, we provide what we call a Visual Scripting Bridge. It's a component that you'll need to add to your table's game object, along with your original gamelogic engine. You can do that by selecting the game object, clicking Add Component in the inspector, and choosing Pinball -> Gamelogic Engine -> Visual Scripting Game Logic. This will give you access to most of the nodes. For example, the On Lamp Changed event will now be triggered by whatever other gamelogic engine you're using. Nodes There are a few nodes you cannot rely on because they need the visual scripting gamelogic engine and won't work with the bridge. These nodes currently are: The display node The variable nodes All other nodes (coils, switches, lamps and events) are available for use."
  },
  "plugins/visual-scripting/index.html": {
    "href": "plugins/visual-scripting/index.html",
    "title": "Visual Scripting | VPE Documentation",
    "keywords": "Visual Scripting Unity has a powerful visual scripting feature that VPE leverages for creating game logic without having to write code. It uses a node system which VPE extends to significantly simplify common tasks in a pinball game. Note Visual scripting was previously named Bolt and was a commercial product in Unity's asset store. In 2020, Unity acquired Bolt and made it freely available. Why? VPE provides many tools that help you create pinball games. Our goal is to make it as easy as possible, so also non-technical people can pour their creativity into making original games. Looking at Visual Pinball, which uses VBScript for not only the game logic but also all the physical logic, people often ask which scripting language VPE will use. We don't have an answer to that yet. While Unity uses C#, and you can code whatever you want with it, there are a few obstacles that we need to overcome before recommending C#, namely: APIs - The VPE code base is quite large, and we haven't put any effort into declaring which of the interfaces are internal and which are public. This is important, because internals can be changed and refactored in future updates, while public interfaces must stay the same in order not to break backwards compatibility. Thus, these APIs need to be well defined and documented. Compilation - Unlike VBS, C# is technically not a scripting language but needs to be compiled. With VPE being cross-platform, this is problematic when shipping in a modding-friendly format. Additionally, Unity's AssetBundles don't allow assemblies to be included, so we'll need a way of working around that as well. Visual scripting doesn't have the above problems. It doesn't need to be compiled, and the VPE APIs are the nodes that we provide. Note Personal note: As software developers, we're obviously skeptical about anything that is supposed to replace code. So, we started implementing an EM game in visual scripting. After putting some effort into creating the right kind of nodes to bring down the graph size significantly, we're happy and we think it's an awesome way of creating game logic. How? If you're coming from Visual Pinball, you're probably used to doing everything in VBScript, including physics hacks and transforming objects on the playfield. VPE is different in that it separates the physical aspect of the table from the logical part (the \"game logic\"). We use visual scripting exclusively as a Gamelogic Engine. This approach already reduces a lot what visual scripting must be able to do. It basically boils down to triggering coils and lamps based on switch events. Of course, there are a few more things like updating the display and for more complicated games, triggering entire light shows and sounds, but in a nutshell it's very simple. For more details about visual scripting in general, check out Unity's documentation. You will learn about graphs, and about script and state machines. Installation Visual scripting comes as an UPM package. In Unity, add it by choosing Window -> Package Manager -> Add package from git URL: Then, input org.visualpinball.engine.unity.visualscripting and click Add or press Enter. This will download and add visual scripting to the project. Note You will need to have our scoped registry added in order for Unity to find the visual scripting package. How to do this is documented in the general setup section. Once the visual scripting package is installed, you can set up the gamelogic engine for it. Disclaimer We've successfully used this package in a single player EM game. Its logic was relatively simple, and there are two important distinctions between an EM game and a modern era game: Modern games have light shows that need to be programmed Modern games have a display like a DMD or even a high-resolution LCD that needs content in form of pixel data. Visual scripting does neither of that. As mentioned above, it's good at reading switch changes and triggering coils and single lamps. Driving a segment display or score reel is very well feasible too, but don't expect to recreate JJP's Guns N' Roses just yet. For this you'll need a proper light sequencer and a video engine. Both are tools that will eventually be created, but today that's not yet the case."
  },
  "plugins/visual-scripting/lamps.html": {
    "href": "plugins/visual-scripting/lamps.html",
    "title": "Lamps | VPE Documentation",
    "keywords": "Lamps Lamps a bit more complex than coils and switches, because besides of simply being turned on or off, they have an intensity and a color. Additionally, they have a blinking state. This means that all our lamp nodes include a dropdown indicating how it should be driven, with the input (or output) types changing accordingly: Status corresponds to a enum, one of On, Off and Blinking. On/Off is a boolean, where true corresponds to the On status, and false to the Off status. Intensity corresponds to a float, and is the brightness of the lamp. Color has its own Color type. These four modes allow you to completely control a lamp (with On/Off being sugar for setting the status using a boolean). However, there is a second factor that defines how the lamp will actually react, and that is its mapping type in the Lamp Manager. See, VPE supports a wide range of gamelogic engines, and they often don't have an internal API as rich as our visual scripting package. For example, when PinMAME sets a light to the value of 255, it doesn't know whether it just \"turned it on\" from 0 or whether it was \"faded in\" from a previous non-0 value. That's information we have to manually set in the Lamp Manager (in this example, the mapping type would be Single On|Off or Single Fading respectively). That said, the only mode that might leads to confusion is Intensity, mainly because it's the only value that PinMAME emits. So if you choose Intensity, here is how the value is treated depending each mapping type: Single On|Off sets the status of the lamp to On if the value is greater than 0, and to Off otherwise. Single Fading sets the intensity to the value divided by maximal intensity. We recommend setting the maximal intensity to 100 in the Lamp Manager and use values from 0 to 100 in the visual scripting nodes. RGB sets the intensity, where the value is between 0 and 1. RGB Multi you probably won't use. It sets the channel defined in the mapping to the value divided by 255 (yes, it's very PinMAME specific)."
  },
  "plugins/visual-scripting/node-reference.html": {
    "href": "plugins/visual-scripting/node-reference.html",
    "title": "Visual Scripting Node Reference | VPE Documentation",
    "keywords": "Node Reference This page details all the VPE-specific nodes that we have created for visual scripting. You can recognize VPE nodes easily by their color: they are orange. When creating new nodes, VPE event nodes can be found under Events/Pinball, and other nodes simply under the root's Visual Pinball. Besides the simple read/write/event nodes, there are a bunch of nodes that solve common patterns in pinball games. While you could implement the same logic using Unity's standard nodes, we recommend using these custom nodes, because they save you space and thus increase the readability of your graphs. However, it's hard to use them without knowing about them, so we recommend reading through this page in order to familiarize with them. Coils On Coil Enabled This event is triggered when the status of any coil in a list of coils is enabled. On Coil Changed This coil event triggers when the status of a coil in a list of coils changes. On All Coils Enabled This coil event triggers when all coils in a list of coils are enabled. Set Coil This node assigns a given value to one or multiple coils and keeps that value. This is useful when both the enabled and disabled status are important. Otherwise, use the Pulse Coil node, which enables a coil, and automatically disables it after a short delay. A typical use case for this node is linking the flipper coil to a switch event. Here an example of a game that has an upper flipper and a lower flipper, both linked to the same left flipper switch. As seen in the screenshot, you can set the number of affected coils in the header of the node. Increasing the number will add additional ports below. Pulse Coil This node enables one or multiple coils and disables them after a given delay. This is useful when you only care about the \"enabled\" event, which often the case. Here is an example of the eject coil of the trough being pulsed when the running state is entered. Get Coil Value This node returns the current coil status of a given coil. While usually you should rely on player and table variables for saving and retrieving status, it still has its usage. For example, you might need to see if a coil is still enabled after a period of time. Switches On Switch Enabled This is probably the most common switch event you will use. It triggers when any switch in a list of switches is enabled. Here is an example of the drain switch increasing the current ball variable. On Switch Changed The other switch event triggers in both cases, when the switch is enabled, and when it gets disabled. The classic example already mentioned above is the flipper buttons. On All Switches Enabled This switch event triggers when all switches in a list of switches are enabled. Set Switch This node enables or disables one or multiple switches. Pulse Switch This node enables one or multiple switches and disables them after a given delay. Get Switch Value This node returns the current switch value of a given switch. While usually you should rely on player and table variables for saving and retrieving status, it still has its usage. For example, you might want to not add the state of a kicker to the variables and rely on the kicker switch directly instead. You can also add multiple switches, in which case the output is only true if all switches are enabled. Lamps Lamps are a bit more complex than coils and switches, because besides simply being on or off, they have an intensity and a color. Additionally, they can be set to a blinking state. This means that all our lamp nodes include a dropdown indicating how it should be driven, with the port types changing accordingly: Status corresponds to an enum, one of On, Off and Blinking. On/Off is a bool, where true corresponds to the On status, and false to the Off status. Intensity corresponds to a float and is explained in more detail below. Color has its own Color type. These four modes allow you to completely control a lamp (with On/Off setting the status using a bool). However, there is a second factor that defines how the lamp will actually react, and that is its mapping type in the lamp manager. See, VPE supports a wide range of gamelogic engines, and they often don't have an internal API as rich as our visual scripting package. For example, when PinMAME sets a light to the value of 255, it doesn't know whether it just \"turned it on\" from 0 or whether it was \"faded in\" from a previous non 0 value. That's information we have to manually set in the lamp manager (in this example, the mapping type would be Single On|Off and Single Fading respectively). That said, the only mode that might lead to confusion is Intensity, mainly because it's the only value that PinMAME emits. So, if you choose Intensity, here is how the value is treated depending on each mapping type: Single On|Off sets the status of the lamp to On if the value is greater than 0, and to Off otherwise. Single Fading sets the intensity to the value divided by maximal intensity. We recommend setting the maximum intensity to 100 in the lamp manager and use values from 0 to 100 in the visual scripting nodes. RGB sets the intensity, where the value is between 0 and 1. RGB Multi you probably will not use. It sets the channel defined in the mapping to the value divided by 255 (yes, it's very PinMAME specific). Note When creating your proper game logic, you should rely on variables instead of lamp status in your logic. However, since you can also use visual scripting along with different gamelogic engine such as PinMAME, where you can't access the internal state, we also provide nodes for lamp events and retrieving their value. Let's jump to the nodes. Set Lamp This node assigns a given value to a lamp defined by its mapped ID. This also triggers the lamp changed event. In the example, we have defined a player variable of type bool called Yellow Bank Lit. We synchronize the lamp status with the variable by setting the lamp with the ID l_yellow_bank to the value of the variable when it changes. Get Lamp Value This node retrieves the current value of a lamp by its mapped ID. As described before, the type of the output port depends on which mode has been selected. A typical usage is to check whether a lamp has previously been set, where no variable is available. That's the case if you're expanding PinMAME with additional logic. This is an example from the table Rock (Premier 1985), where PinMAME doesn't emulate the starting light sequence. The graph above checks if lamp 01 is lit and turns off a bunch of lamps if that's not the case (otherwise, it's more complicated). It does this when lamp 01, 12 or 13 changes, and at the beginning of the game. On Lamp Changed This node triggers when any of the defined lamps changes state. Its application is quite similar to the previous get lamp value node, where the example covers this node as well. Lamp Sequence This node takes in a list of lamps and loops through each lamp with a given step size, while applying a given value to the active lamp(s) and another value to the inactive lamps. The counter is internal to the node and increases each time the node is processed. The inputs are the following: Lamps - The list of lamps to loop through. Note that light groups are flattened, i.e., split into single lamps. Step - By how much the internal counter increases when the node is processed. It's also how many lamps are active. Value - The value that is applied to the active lamps Non Step Value - The value that is applied to inactive lamps. As an example, here is a loop that gets triggered when lamp 13 gets lit and repeats until lamp 13 is unlit. On each iteration, two lamps get turned on, while the others are turned off. It starts with the first two lamps, then the second two lamps, then lamp 5 and 6, and so on. All these lamps are part of the l_auxiliary light group, which contains 20 lamps. After lamp 19 and 20 were turned on, it goes back to lamp 1 and 2. After each iteration, the loop pauses for 60ms before continuing. Finally, when lamp 13 is turned off, the loop exits, and the entire light group is turned off as well. Switch Lamp This node takes in a list of lamps, matches them based on an input, and updates them based on the match. In the following example we enable the lamp on an EM backglass which indicates the current ball in play. As an input we get an integer representing the ball number, and we toggle the respective lamp based on that value. You don't need to populate all possible input values with your lamps. Here is an example that matches only if the current ball number is 0 (no game running), in which case the GAME OVER lamp is set to blinking. Variables See Variables for an overview on how variables work. We will be using examples for player variables, but apart from creation and changing, they work the same way as table variables. Create Player State This node adds variables for a new player. If the game starts and you want to use player variables, you need to create a player state, even if your game has only one player. You would typically do it when the game starts. Multiplayer games would execute this node when start is pressed during the first ball. This node has the following options: Auto-Increment automatically sets the player ID. It does that by increasing the largest existing player ID by one. Player ID is only visible if auto-increment is not set, and lets you specify the player ID. Set as Active will make the newly created player state the current state. This makes sense when a new game is started, but not when new players are added. Destroy Previous deletes all player states before creating the new one. This is useful when starting a new game. Here an example of the player state being created right after the state machine enters the game state, i.e., when the game starts. Note This is one of two nodes that doesn't exist for table variables. Change Player State This node swaps out the current player variables with the ones from another player. You do this when a player has finished playing and it's the next player's turn. The following options are available: Next Player automatically choses the next player. If the current player is the last player, the next player is the first player. You typically enable this option when using auto-increment during player state creation. It means that VPE handles the player IDs. Player ID lets you explicitly set the ID of the player you want to change to (only visible of Next Player is disabled). The following is an example of a multiplayer game with infinite balls (i.e., remaining balls are not checked). The flow starts with the drain switch, which then checks whether the current player has any extra balls left. If that's not the case, then the player state is changed to the next player, otherwise the number of extra balls is decreased instead, and finally the eject coil of the trough is pulsed. Note This the second node that doesn't exist for table variables. Get Player ID This node gives you access to the player ID. There are three different modes: Current returns the ID of the current player First return the smallest player ID Last returns the largest player ID A typical example is shown in the next section. Get Variable This node returns the value of a given variable. To build on the previous example, let's do a check whether we should end the game if a ball was drained. To do that, we retrieve the player variable Current Ball Number and check if it's the same as the global variable Balls per Game. If that's the case, we assume that it's the last ball. Then we compare the current player ID to the last player ID. The final And node checks if both conditions are true, and what comes out is whether we should end the game or not. Set Variable This node applies a given value to a variable. It's very straightforward. Here an example of a trigger enabling the lit status of a bumper. Increase Variable More often than not, you want to increase a variable by a given value rather than setting an absolute value. This node does exactly that, for integer and float typed variables. For string types, it concatenates the value to the current one. For Boolean types, it inverts the current value, if the input value is true. A typical example for this node is scoring. This example adds 1000 points to the score when the bumper switch is enabled. On Variable Changed One of the main advantages of using VPE's variable system is that you get events when they change. That makes it easy to separate how the variable is updated from what effect updating it causes. That's great, because you shouldn't care why a variable was updated, only when and to which value (see also Synchronizing State). In this example, we listen to the score variable and fetch it into our Update Display node, which sends the data to our score reel component, which then rotates the reels accordingly. Note that you'll also get the previous value of the variable before it changed. Events Trigger Pinball Event This node triggers an event that was previously defined in the inspector of the visual scripting gamelogic engine. It can be fed with an any number of arguments. In this example we don't set the score directly but emit an event so we can have centralized logic dealing with scores (it's for an EM, and while the reel motor is on, no scoring is skipped): On Pinball Event On the receiving end, this is the event node that is triggered when a pinball event node with the same event is executed. To continue the previous example, here the graph was triggered by a pinball event, which updates the score if the score reel motor is not running. Displays Creating original graphical content for displays is not yet supported by VPE. We're looking into leveraging Unity's 2D engine to create content and send the result to the different output devices VPE supports. This will most likely be a system independent from visual scripting. Even if we have nothing that creates the graphical content, we've defined the APIs used to pass the data around. This allows us to already have a working system that supports number and text data. Clear Display This node clears a display defined in the GLE. Update Display This node takes in some data and sends it to one of the displays defined in the GLE. VPE supports segment displays and score reels, so the data can be numeric (score reels and segment displays) or alphanumeric (segment displays). This example shows how the display is updated for a simple one player EM machine. The score reel animation is handled by the component driving the reel. It's also on component level where you can define the speed and delays of the score reel animation and associate a score motor. On Display Changed This event is triggered when a display defined in the GLE is updated by Clear Display or Update Display. It is useful for EM machines that use a score motor and need to capture the score in a player variable."
  },
  "plugins/visual-scripting/setup.html": {
    "href": "plugins/visual-scripting/setup.html",
    "title": "Visual Scripting Setup | VPE Documentation",
    "keywords": "Setup In order to use visual scripting as your gamelogic engine, you need to add it as a component to your table. In order to do that, navigate in your hierarchy to the root node of your table, where you most likely still have the Default Gamelogic Engine added. If that's the case, remove it by clicking on the three dots and choose Remove Component. Then, add the visual scripting GLE component by (still in the inspector) clicking on Add Component -> Pinball -> Gamelogic Engine -> Visual Scripting Game Logic. Configuration Remember that a gamelogic engine doesn't know about your playfield. It communicates with the game through IDs that you assign in editor. We acknowledge that visual scripting is tied somewhat more closely to the playfield than, let's say, PinMAME, because it's equally created in the editor. However, there are multiple reasons to use the same pattern as in other GLEs, which is what visual scripting does. So instead of interacting with playfield items directly, you need to define the displays, switches, coils, and lamps in the visual scripting component. Once added, you can link them with the respective editors to the playfield. Displays The first configuration you'll see in the inspector is which type of displays your game expects to find on the playfield. You can have multiple displays. For each display, you define the size and which type of formats it must be able to handle. These are the possible types: DMD2, DMD4, DMD8 and DMD24 is pixel data, where the number is the number of bits: 2, 4 and 8 bits equal 4, 16 and 256 respectively gray tones 24 means RGB24, standing for 16mio colors. Segment are segment displays, which take in an array of binary data, where each two bytes represent the segments of one digit. Alphanumeric are displays that can render text on one line. Numeric displays only render digits. The display components that VPE provides understand multiple formats, e.g., our segment display component takes in segment data, but also text and numeric data. In the future, we'll also add a simple numeric and text renderer for DMDs. Switches In this section you define the switches that appear in the Switch Manager when you auto-populate them. It's also the source for all the switch-related nodes that VPE provides within your visual scripting graphs. Coils Here you define your coils. Same concept as for switches. These are the coils you'll see in the Coil Manager, and they are the source when looking up IDs in visual scripting's coil nodes. Lamps Same goes for the lamps. They appear in the Lamp Manager and are used in the lamp nodes that VPE provides. It's worth noting that VPE currently doesn't provide any tools for creating light shows. Once we do, we'll provide additional lamp nodes to trigger and blend them together. Events Unity provides Custom Events which allow you to globally pass data across graphs. While this is a valid approach, VPE provides its own event nodes called Pinball Events, which allow you to declare your events. This has the benefit of being able to simply pick an event from a drop-down when configuring the nodes, as opposed to having to remember or separately document existing event names. Variables It's worth describing variables more in detail, which we do in the next section."
  },
  "plugins/visual-scripting/variables.html": {
    "href": "plugins/visual-scripting/variables.html",
    "title": "Visual Scripting Variables | VPE Documentation",
    "keywords": "Variables As you create your game logic, you'll want to read and write data such as the player's score, or the number of balls per game. There are two ways of doing that: Using VPE's game- and player variables. Using Unity's visual scripting variables. VPE Variables A common pattern in pinball games is the notion of multiple players: Player one starts the game, scores some points, drains the ball, then player two starts with zero points, scores some as well, drains the ball, and when it's back to player one, player one's score should be displayed again. This means that we need something that tracks the score (and many other things) per player. We should then be able to easily switch from one player to another, and we want the playfield and the display to be automatically updated when that happens. VPE provides its own type of variables for that, and they come in two flavors: Player Variables are as described above, scoped per player. Here, you would be storing data such as the current score. Table Variables are global to the table. You would use them for things like balls per game. In the visual scripting GLE, you can define the structure of both types of variables. Then, in the graph, you'll get events for every defined variable that you can use to trigger the desired action. If you're testing gameplay in the editor, the current values of both player and table variables are shown in the inspector and get updated in real time. Note In the future, table variables could also be marked as editable, so the player app could allow the user to change them. Setup In the hierarchy, select the GameObject where you added the visual scripting GLE (usually the root node of the table). In there, you'll find two sections, Player Variables and Table Variables. You can define as many as you want for each. You'll need a name and a variable type, for which string, int, float and bool are supported. Note You can use any human-readable name (with spaces and so on), since variables are referenced by an internal ID. You can also rename them later but changing the type later might result in issues. Accessing Variables Once you have declared your variables, you can use them in your graphs. In the graph editor, those nodes can be found under Pinball/Variables and Events/Pinball for the event node. There are two sets of nodes, one for player variables and one for table variables. They are identical apart from two additional player variable nodes described in the Player State section below. Get Variable contains an output with the current value of your variable. Set Variable contains an input with the new value of your variable. When executed, it applies that value to the variable. Increase Variable adds a number to a variable of type float or integer. On Variable Changed is an event node that triggers when a given variable changes. Player State We call player state the set of player variables assigned to a player. There are as many player states as there are players in a running game, but only one active state. You can create new states whenever you want (typically when the start button is pressed during the first ball, and there are enough credits). When creating a new state, you can either explicitly define a player ID (it's an integer), or automatically create one. You can then switch states by either indicating the player ID, or just \"the next\" player (which will cycle to the first player if the last player is active). You currently cannot explicitly destroy player states, but you can tell the player state creation node to destroy all previous states prior to creation. This is because typically, your player state persists even after the game and gets reset only when a new game begins. Synchronizing State In most of your graphs, you should be reading and writing variables only. For example, if you increase the player's score, you shouldn't have to worry about updating the display where the score is shown. You just update the score player variable, that's it. The idea here is to separate the pure game logic from what's going on the playfield and the display. This is where events come in. As described earlier, there is an On Variable Changed event that you can put in any graph. This event triggers every time you change the value of a given player- or table variable, no matter from which subgraph. So, in this example, you would have one subgraph that would handle display updates. This graph would contain event nodes for all relevant variables that have any effect on the display and update the display accordingly. Note In computer science, this is called SoC, or Separation of concerns. It means that each section (in our case, a subgraph) should only care about one specific thing, and not about any of the side effects. Besides not having to think about all the consequences every time you change a variable, this patterns also gives you a free perk: When you switch players, VPE will automatically trigger events for all player variables that changed, which will result in the display showing the correct score, without the need of any further logic from your side. Here is an example of the graph that synchronizes the light variables of Gottlieb's Volley with the lamps on the playfield: Persisting Variables You might want to persist state across launches, i.e., have them written to disk. Examples are high scores or game settings. This is still work in progress. Unity Visual Scripting Variables For everything game related, we recommend using VPE variables as described above. However, there is a use case where using Unity's built-in variable system might be necessary. Imagine you have created somewhat complex in a graph, and you want to re-use that logic in different ways, by passing different arguments to that graph. Like a function that takes in parameters. In this case you should rely on the graph's data ports that allow passing data to graphs, which you then can access through the Input node."
  }
}