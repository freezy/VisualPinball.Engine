<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NetVips</name>
    </assembly>
    <members>
        <member name="T:NetVips.Connection">
            <summary>
            The abstract base Connection class.
            </summary>
        </member>
        <member name="M:NetVips.Connection.#ctor(System.IntPtr)">
            <inheritdoc cref="T:NetVips.GObject"/>
        </member>
        <member name="M:NetVips.Connection.GetFileName">
            <summary>
            Get the filename associated with a connection. Return <see langword="null"/> if there
            is no associated file.
            </summary>
            <returns>The filename associated with this connection or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Connection.GetNick">
            <summary>
            Make a human-readable name for a connection suitable for error
            messages.
            </summary>
            <returns>The human-readable name for this connection.</returns>
        </member>
        <member name="T:NetVips.Enums">
            <summary>
            This module contains the various libvips enums as C# classes
            Enums values are represented in NetVips as strings. These classes contain the valid strings for each enum.
            </summary>
        </member>
        <member name="T:NetVips.Enums.Access">
            <summary>
            The type of access an operation has to supply.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Tilecache(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean})"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Access.Random">
            <summary>Requests can come in any order.</summary>
        </member>
        <member name="F:NetVips.Enums.Access.Sequential">
            <summary>
            Means requests will be top-to-bottom, but with some
            amount of buffering behind the read point for small non-local
            accesses.
            </summary>
        </member>
        <member name="F:NetVips.Enums.Access.SequentialUnbuffered">
            <summary>Top-to-bottom without a buffer.</summary>
        </member>
        <member name="T:NetVips.Enums.Align">
            <summary>
            Various types of alignment.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Join(NetVips.Image,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Double[],System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Align.Low">
            <summary>Align on the low coordinate edge.</summary>
        </member>
        <member name="F:NetVips.Enums.Align.Centre">
            <summary>Align on the centre.</summary>
        </member>
        <member name="F:NetVips.Enums.Align.High">
            <summary>Align on the high coordinate edge.</summary>
        </member>
        <member name="T:NetVips.Enums.Angle">
            <summary>
            Various fixed 90 degree rotation angles.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Rot(System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Angle.D0">
            <summary>No rotate.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle.D90">
            <summary>90 degrees clockwise.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle.D180">
            <summary>180 degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle.D270">
            <summary>90 degrees anti-clockwise.</summary>
        </member>
        <member name="T:NetVips.Enums.Angle45">
            <summary>
            Various fixed 45 degree rotation angles.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Rot45(System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Angle45.D0">
            <summary>No rotate.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle45.D45">
            <summary>45 degrees clockwise.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle45.D90">
            <summary>90 degrees clockwise.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle45.D135">
            <summary>135 degrees clockwise.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle45.D180">
            <summary>180 degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle45.D225">
            <summary>135 degrees anti-clockwise.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle45.D270">
            <summary>90 degrees anti-clockwise.</summary>
        </member>
        <member name="F:NetVips.Enums.Angle45.D315">
            <summary>45 degrees anti-clockwise.</summary>
        </member>
        <member name="T:NetVips.Enums.BandFormat">
            <summary>
            The format of image bands.
            </summary>
            <remarks>
            The format used for each band element. Each corresponds to a native C type
            for the current machine.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Uchar">
            <summary>unsigned char format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Char">
            <summary>char format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Ushort">
            <summary>unsigned short format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Short">
            <summary>short format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Uint">
            <summary>unsigned int format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Int">
            <summary>int format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Float">
            <summary>float format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Complex">
            <summary>complex (two floats) format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Double">
            <summary>double float format.</summary>
        </member>
        <member name="F:NetVips.Enums.BandFormat.Dpcomplex">
            <summary>double complex (two double) format.</summary>
        </member>
        <member name="T:NetVips.Enums.BlendMode">
             <summary>
             The various Porter-Duff and PDF blend modes. See <see cref="M:NetVips.Image.Composite2(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean})"/>.
             </summary>
             <remarks>
             The Cairo docs have a nice explanation of all the blend modes:
             https://www.cairographics.org/operators
            
             The non-separable modes are not implemented.
             </remarks>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Clear">
            <summary>Where the second object is drawn, the first is removed.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Source">
            <summary>The second object is drawn as if nothing were below.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Over">
            <summary>The image shows what you would expect if you held two semi-transparent slides on top of each other.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.In">
            <summary>The first object is removed completely, the second is only drawn where the first was.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Out">
            <summary>The second is drawn only where the first isn't.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Atop">
            <summary>This leaves the first object mostly intact, but mixes both objects in the overlapping area.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Dest">
            <summary>Leaves the first object untouched, the second is discarded completely.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.DestOver">
            <summary>Like Over, but swaps the arguments.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.DestIn">
            <summary>Like In, but swaps the arguments.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.DestOut">
            <summary>Like Out, but swaps the arguments.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.DestAtop">
            <summary>Like Atop, but swaps the arguments.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Xor">
            <summary>Something like a difference operator.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Add">
            <summary>A bit like adding the two images.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Saturate">
            <summary>A bit like the darker of the two.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Multiply">
            <summary>At least as dark as the darker of the two inputs.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Screen">
            <summary>At least as light as the lighter of the inputs.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Overlay">
            <summary>Multiplies or screens colors, depending on the lightness.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Darken">
            <summary>The darker of each component.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Lighten">
            <summary>The lighter of each component.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.ColourDodge">
            <summary>Brighten first by a factor second.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.ColourBurn">
            <summary>Darken first by a factor of second.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.HardLight">
            <summary>Multiply or screen, depending on lightness.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.SoftLight">
            <summary>Darken or lighten, depending on lightness.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Difference">
            <summary>Difference of the two.</summary>
        </member>
        <member name="F:NetVips.Enums.BlendMode.Exclusion">
            <summary>Somewhat like Difference, but lower-contrast.</summary>
        </member>
        <member name="T:NetVips.Enums.Coding">
            <summary>
            How pixels are coded.
            </summary>
            <remarks>
            Normally, pixels are uncoded and can be manipulated as you would expect.
            However some file formats code pixels for compression, and sometimes it's
            useful to be able to manipulate images in the coded format.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Coding.None">
            <summary>Pixels are not coded.</summary>
        </member>
        <member name="F:NetVips.Enums.Coding.Labq">
            <summary>Pixels encode 3 float CIELAB values as 4 uchar.</summary>
        </member>
        <member name="F:NetVips.Enums.Coding.Rad">
            <summary>Pixels encode 3 float RGB as 4 uchar (Radiance coding).</summary>
        </member>
        <member name="T:NetVips.Enums.Combine">
            <summary>
            How to combine passes.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Compass(NetVips.Image,System.Nullable{System.Int32},System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Combine.Max">
            <summary>Take the maximum of all values.</summary>
        </member>
        <member name="F:NetVips.Enums.Combine.Sum">
            <summary>Take the sum of all values.</summary>
        </member>
        <member name="F:NetVips.Enums.Combine.Min">
            <summary>Take the minimum value.</summary>
        </member>
        <member name="T:NetVips.Enums.CombineMode">
            <summary>
            How to combine pixels.
            </summary>
            <remarks>
            Operations like <see cref="M:NetVips.Image.DrawImage(NetVips.Image,System.Int32,System.Int32,System.String)"/> need to be told how to
            combine images from two sources. See also <see cref="M:NetVips.Image.Join(NetVips.Image,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Double[],System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.CombineMode.Set">
            <summary>Set pixels to the new value.</summary>
        </member>
        <member name="F:NetVips.Enums.CombineMode.Add">
            <summary>Add pixels.</summary>
        </member>
        <member name="T:NetVips.Enums.CompassDirection">
            <summary>
            A direction on a compass. Used for <see cref="M:NetVips.Image.Gravity(System.String,System.Int32,System.Int32,System.String,System.Double[])"/>, for example.
            </summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.Centre">
            <summary>Centre</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.North">
            <summary>North</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.East">
            <summary>East</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.South">
            <summary>South</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.West">
            <summary>West</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.NorthEast">
            <summary>North-east</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.SouthEast">
            <summary>South-east</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.SouthWest">
            <summary>South-west</summary>
        </member>
        <member name="F:NetVips.Enums.CompassDirection.NorthWest">
            <summary>North-west</summary>
        </member>
        <member name="T:NetVips.Enums.DemandStyle">
            <summary>
            A hint about the kind of demand geometry VIPS images prefer.
            </summary>
        </member>
        <member name="F:NetVips.Enums.DemandStyle.Smalltile">
            <summary>Demand in small (typically 64x64 pixel) tiles.</summary>
        </member>
        <member name="F:NetVips.Enums.DemandStyle.Fatstrip">
            <summary>Demand in fat (typically 10 pixel high) strips.</summary>
        </member>
        <member name="F:NetVips.Enums.DemandStyle.Thinstrip">
            <summary>Demand in thin (typically 1 pixel high) strips.</summary>
        </member>
        <member name="T:NetVips.Enums.Direction">
            <summary>
            A direction.
            </summary>
            <remarks>
            Operations like <see cref="M:NetVips.Image.Flip(System.String)"/> need to be told whether to flip
            left-right or top-bottom.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Direction.Horizontal">
            <summary>left-right.</summary>
        </member>
        <member name="F:NetVips.Enums.Direction.Vertical">
            <summary>top-bottom.</summary>
        </member>
        <member name="T:NetVips.Enums.Extend">
            <summary>
            How to extend image edges.
            </summary>
            <remarks>
            When the edges of an image are extended, you can specify how you want
            the extension done. See <see cref="M:NetVips.Image.Embed(System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Double[])"/>, <see cref="M:NetVips.Image.Conv(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>, <see cref="M:NetVips.Image.Affine(System.Double[],NetVips.GObject,System.Int32[],System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.String)"/>
            and so on.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Extend.Black">
            <summary>New pixels are black, ie. all bits are zero.</summary>
        </member>
        <member name="F:NetVips.Enums.Extend.Copy">
            <summary>Each new pixel takes the value of the nearest edge pixel.</summary>
        </member>
        <member name="F:NetVips.Enums.Extend.Repeat">
            <summary>The image is tiled to fill the new area.</summary>
        </member>
        <member name="F:NetVips.Enums.Extend.Mirror">
            <summary>The image is reflected and tiled to reduce hash edges.</summary>
        </member>
        <member name="F:NetVips.Enums.Extend.White">
            <summary>New pixels are white, ie. all bits are set.</summary>
        </member>
        <member name="F:NetVips.Enums.Extend.Background">
            <summary>Colour set from the @background property.</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignDzContainer">
            <summary>
            The container type of the pyramid.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Dzsave(System.String,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.String,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.ForeignDzContainer.Fs">
            <summary>Write tiles to the filesystem.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzContainer.Zip">
            <summary>Write tiles to a zip file.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzContainer.Szi">
            <summary>Write to a szi file.</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignDzDepth">
            <summary>
            How many pyramid layers to create.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Dzsave(System.String,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.String,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.ForeignDzDepth.Onepixel">
            <summary>Create layers down to 1x1 pixel.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzDepth.Onetile">
            <summary>Create layers down to 1x1 tile.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzDepth.One">
            <summary>Only create a single layer.</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignDzLayout">
            <summary>
            What directory layout and metadata standard to use.
            </summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzLayout.Dz">
            <summary>Use DeepZoom directory layout.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzLayout.Zoomify">
            <summary>Use Zoomify directory layout.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzLayout.Google">
            <summary>Use Google maps directory layout.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignDzLayout.Iiif">
            <summary>Use IIIF directory layout.</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignHeifCompression">
            <summary>
            The compression format to use inside a HEIF container.
            </summary>
        </member>
        <member name="F:NetVips.Enums.ForeignHeifCompression.Hevc">
            <summary>x265</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignHeifCompression.Avc">
            <summary>x264</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignHeifCompression.Jpeg">
            <summary>JPEG</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignHeifCompression.Av1">
            <summary>AOM</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignTiffCompression">
            <summary>
            The compression types supported by the tiff writer.
            </summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.None">
            <summary>No compression.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.Jpeg">
            <summary>JPEG compression.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.Deflate">
            <summary>Deflate (zip) compression.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.Packbits">
            <summary>Packbits compression.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.Ccittfax4">
            <summary>Fax4 compression.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.Lzw">
            <summary>LZW compression.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.Webp">
            <summary>WebP compression.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffCompression.Zstd">
            <summary>ZSTD compression.</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignTiffPredictor">
            <summary>
            The predictor can help deflate and lzw compression.
            The values are fixed by the tiff library.
            </summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffPredictor.None">
            <summary>No prediction.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffPredictor.Horizontal">
            <summary>Horizontal differencing.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffPredictor.Float">
            <summary>Float predictor.</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignTiffResunit">
            <summary>
            Use inches or centimeters as the resolution unit for a tiff file.
            </summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffResunit.Cm">
            <summary>Use centimeters.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignTiffResunit.Inch">
            <summary>Use inches.</summary>
        </member>
        <member name="T:NetVips.Enums.ForeignWebpPreset">
            <summary>
            Tune lossy encoder settings for different image types.
            </summary>
        </member>
        <member name="F:NetVips.Enums.ForeignWebpPreset.Default">
            <summary>Default preset.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignWebpPreset.Picture">
            <summary>Digital picture, like portrait, inner shot.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignWebpPreset.Photo">
            <summary>Outdoor photograph, with natural lighting.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignWebpPreset.Drawing">
            <summary>Hand or line drawing, with high-contrast details.</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignWebpPreset.Icon">
            <summary>Small-sized colorful images/</summary>
        </member>
        <member name="F:NetVips.Enums.ForeignWebpPreset.Text">
            <summary>Text-like.</summary>
        </member>
        <member name="T:NetVips.Enums.Intent">
            <summary>
            The rendering intent.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.IccTransform(System.String,System.String,System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32})"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Intent.Perceptual">
            <summary>Perceptual rendering intent.</summary>
        </member>
        <member name="F:NetVips.Enums.Intent.Relative">
            <summary>Relative colorimetric rendering intent.</summary>
        </member>
        <member name="F:NetVips.Enums.Intent.Saturation">
            <summary>Saturation rendering intent.</summary>
        </member>
        <member name="F:NetVips.Enums.Intent.Absolute">
            <summary>Absolute colorimetric rendering intent.</summary>
        </member>
        <member name="T:NetVips.Enums.Interesting">
            <summary>
            Pick the algorithm vips uses to decide image "interestingness".
            This is used by <see cref="M:NetVips.Image.Smartcrop(System.Int32,System.Int32,System.String)"/>, for example, to decide what parts of the image to keep.
            </summary>
        </member>
        <member name="F:NetVips.Enums.Interesting.None">
            <summary>Do nothing.</summary>
        </member>
        <member name="F:NetVips.Enums.Interesting.Centre">
            <summary>Just take the centre.</summary>
        </member>
        <member name="F:NetVips.Enums.Interesting.Entropy">
            <summary>Use an entropy measure.</summary>
        </member>
        <member name="F:NetVips.Enums.Interesting.Attention">
            <summary>Look for features likely to draw human attention.</summary>
        </member>
        <member name="F:NetVips.Enums.Interesting.Low">
            <summary>Position the crop towards the low coordinate.</summary>
        </member>
        <member name="F:NetVips.Enums.Interesting.High">
            <summary>Position the crop towards the high coordinate.</summary>
        </member>
        <member name="T:NetVips.Enums.Interpretation">
            <summary>
            How the values in an image should be interpreted.
            </summary>
            <remarks>
            For example, a three-band float image of type LAB should have its
            pixels interpreted as coordinates in CIE Lab space.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Multiband">
            <summary>Generic many-band image.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Bw">
            <summary>Some kind of single-band image.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Histogram">
            <summary>A 1D image, eg. histogram or lookup table.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Xyz">
            <summary>The first three bands are CIE XYZ.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Lab">
            <summary>Pixels are in CIE Lab space.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Cmyk">
            <summary>The first four bands are in CMYK space.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Labq">
            <summary>Implies #VIPS_CODING_LABQ.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Rgb">
            <summary>Generic RGB space.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Cmc">
            <summary>A uniform colourspace based on CMC(1:1).</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Lch">
            <summary>Pixels are in CIE LCh space.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Labs">
            <summary>CIE LAB coded as three signed 16-bit values.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Srgb">
            <summary>Pixels are sRGB.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Yxy">
            <summary>Pixels are CIE Yxy.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Fourier">
            <summary>Image is in fourier space.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Rgb16">
            <summary>Generic 16-bit RGB.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Grey16">
            <summary>Generic 16-bit mono.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Matrix">
            <summary>A matrix.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Scrgb">
            <summary>Pixels are scRGB.</summary>
        </member>
        <member name="F:NetVips.Enums.Interpretation.Hsv">
            <summary>Pixels are HSV.</summary>
        </member>
        <member name="T:NetVips.Enums.Kernel">
            <summary>
            A resizing kernel. One of these can be given to operations like
            <see cref="M:NetVips.Image.Reduce(System.Double,System.Double,System.String,System.Nullable{System.Boolean})"/> or <see cref="M:NetVips.Image.Resize(System.Double,System.String,System.Nullable{System.Double})"/> to select the resizing kernel to use.
            </summary>
        </member>
        <member name="F:NetVips.Enums.Kernel.Nearest">
            <summary>Nearest-neighbour interpolation.</summary>
        </member>
        <member name="F:NetVips.Enums.Kernel.Linear">
            <summary>Linear interpolation.</summary>
        </member>
        <member name="F:NetVips.Enums.Kernel.Cubic">
            <summary>Cubic interpolation.</summary>
        </member>
        <member name="F:NetVips.Enums.Kernel.Mitchell">
            <summary>TODO</summary>
        </member>
        <member name="F:NetVips.Enums.Kernel.Lanczos2">
            <summary>Two-lobe Lanczos.</summary>
        </member>
        <member name="F:NetVips.Enums.Kernel.Lanczos3">
            <summary>Three-lobe Lanczos.</summary>
        </member>
        <member name="T:NetVips.Enums.OperationBoolean">
            <summary>
            Boolean operations.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Boolean(NetVips.Image,System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationBoolean.And">
            <summary>&amp;</summary>
        </member>
        <member name="F:NetVips.Enums.OperationBoolean.Or">
            <summary>|</summary>
        </member>
        <member name="F:NetVips.Enums.OperationBoolean.Eor">
            <summary>^</summary>
        </member>
        <member name="F:NetVips.Enums.OperationBoolean.Lshift">
            <summary>&lt;&lt;</summary>
        </member>
        <member name="F:NetVips.Enums.OperationBoolean.Rshift">
            <summary>&gt;&gt;</summary>
        </member>
        <member name="T:NetVips.Enums.OperationComplex">
            <summary>
            Operations on complex images.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Complex(System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationComplex.Polar">
            <summary>Convert to polar coordinates.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationComplex.Rect">
            <summary>Convert to rectangular coordinates.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationComplex.Conj">
            <summary>Complex conjugate.</summary>
        </member>
        <member name="T:NetVips.Enums.OperationComplex2">
            <summary>
            Binary operations on complex images.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Complex2(NetVips.Image,System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationComplex2.CrossPhase">
            <summary>Convert to polar coordinates.</summary>
        </member>
        <member name="T:NetVips.Enums.OperationComplexget">
            <summary>
            Components of complex images.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Complexget(System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationComplexget.Real">
            <summary>Get real component.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationComplexget.Imag">
            <summary>Get imaginary component.</summary>
        </member>
        <member name="T:NetVips.Enums.OperationMath">
            <summary>
            Various math functions on images.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Math(System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Sin">
            <summary>sin(), angles in degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Cos">
            <summary>cos(), angles in degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Tan">
            <summary>tan(), angles in degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Asin">
            <summary>asin(), angles in degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Acos">
            <summary>acos(), angles in degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Atan">
            <summary>atan(), angles in degrees.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Log">
            <summary>log base e.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Log10">
            <summary>log base 10.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Exp">
            <summary>e to the something.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath.Exp10">
            <summary>10 to the something.</summary>
        </member>
        <member name="T:NetVips.Enums.OperationMath2">
            <summary>
            Various math functions on images.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Math(System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationMath2.Pow">
            <summary>pow( left, right ).</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMath2.Wop">
            <summary>pow( right, left ).</summary>
        </member>
        <member name="T:NetVips.Enums.OperationMorphology">
            <summary>
            Morphological operations.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Morph(NetVips.Image,System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationMorphology.Erode">
            <summary>true if all set.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationMorphology.Dilate">
            <summary>true if one set.</summary>
        </member>
        <member name="T:NetVips.Enums.OperationRelational">
            <summary>
            Various relational operations.
            </summary>
            <remarks>
            See <see cref="M:NetVips.Image.Relational(NetVips.Image,System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.OperationRelational.Equal">
            <summary>==</summary>
        </member>
        <member name="F:NetVips.Enums.OperationRelational.Noteq">
            <summary>!=</summary>
        </member>
        <member name="F:NetVips.Enums.OperationRelational.Less">
            <summary>&lt;</summary>
        </member>
        <member name="F:NetVips.Enums.OperationRelational.Lesseq">
            <summary>&lt;=</summary>
        </member>
        <member name="F:NetVips.Enums.OperationRelational.More">
            <summary>&gt;</summary>
        </member>
        <member name="F:NetVips.Enums.OperationRelational.Moreeq">
            <summary>&gt;=</summary>
        </member>
        <member name="T:NetVips.Enums.OperationRound">
            <summary>
            Round operations.
            </summary>
        </member>
        <member name="F:NetVips.Enums.OperationRound.Rint">
            <summary>Round to nearest.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationRound.Ceil">
            <summary>The smallest integral value not less than.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationRound.Floor">
            <summary>Largest integral value not greater than.</summary>
        </member>
        <member name="T:NetVips.Enums.PCS">
            <summary>
            Set Profile Connection Space.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.IccImport(System.String,System.String,System.Nullable{System.Boolean},System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.PCS.Lab">
            <summary>CIE Lab space.</summary>
        </member>
        <member name="F:NetVips.Enums.PCS.Xyz">
            <summary>CIE XYZ space.</summary>
        </member>
        <member name="T:NetVips.Enums.Precision">
            <summary>
            Computation precision.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Conv(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Precision.Integer">
            <summary>Integer.</summary>
        </member>
        <member name="F:NetVips.Enums.Precision.Float">
            <summary>Floating point.</summary>
        </member>
        <member name="F:NetVips.Enums.Precision.Approximate">
            <summary>Compute approximate result.</summary>
        </member>
        <member name="T:NetVips.Enums.RegionShrink">
            <summary>
            How to calculate the output pixels when shrinking a 2x2 region.
            </summary>
        </member>
        <member name="F:NetVips.Enums.RegionShrink.Mean">
            <summary>Use the average.</summary>
        </member>
        <member name="F:NetVips.Enums.RegionShrink.Median">
            <summary>Use the median.</summary>
        </member>
        <member name="F:NetVips.Enums.RegionShrink.Mode">
            <summary>Use the mode.</summary>
        </member>
        <member name="T:NetVips.Enums.Saveable">
            <summary>
            Some hints about the image saver.
            </summary>
        </member>
        <member name="F:NetVips.Enums.Saveable.Mono">
            <summary>1 band (eg. CSV)</summary>
        </member>
        <member name="F:NetVips.Enums.Saveable.Rgb">
            <summary>1 or 3 bands (eg. PPM)</summary>
        </member>
        <member name="F:NetVips.Enums.Saveable.Rgba">
            <summary>1, 2, 3 or 4 bands (eg. PNG)</summary>
        </member>
        <member name="F:NetVips.Enums.Saveable.RgbaOnly">
            <summary>3 or 4 bands (eg. WEBP)</summary>
        </member>
        <member name="F:NetVips.Enums.Saveable.RgbCmyk">
            <summary>1, 3 or 4 bands (eg.JPEG)</summary>
        </member>
        <member name="F:NetVips.Enums.Saveable.Any">
            <summary>Any number of bands (eg. TIFF)</summary>
        </member>
        <member name="T:NetVips.Enums.Size">
            <summary>
            Controls whether an operation should upsize, downsize, both up and downsize, or force a size.
            </summary>
            <remarks>
            See for example <see cref="M:NetVips.Image.Thumbnail(System.String,System.Int32,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.String,System.String)"/>.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Size.Both">
            <summary>Size both up and down.</summary>
        </member>
        <member name="F:NetVips.Enums.Size.Up">
            <summary>Only upsize.</summary>
        </member>
        <member name="F:NetVips.Enums.Size.Down">
            <summary>Only downsize.</summary>
        </member>
        <member name="F:NetVips.Enums.Size.Force">
            <summary>Force size, that is, break aspect ratio.</summary>
        </member>
        <member name="T:NetVips.Enums.LogLevelFlags">
            <summary>
            Flags specifying the level of log messages.
            </summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.FlagRecursion">
            <summary>Internal flag.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.FlagFatal">
            <summary>internal flag.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.Error">
            <summary>log level for errors.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.Critical">
            <summary>log level for critical warning messages.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.Warning">
            <summary>log level for warnings.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.Message">
            <summary>log level for messages.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.Info">
            <summary>log level for informational messages.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.Debug">
            <summary>log level for debug messages.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.AllButFatal">
            <summary>All log levels except fatal.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.AllButRecursion">
            <summary>All log levels except recursion.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.All">
            <summary>All log levels.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.FlagMask">
            <summary>Flag mask.</summary>
        </member>
        <member name="F:NetVips.Enums.LogLevelFlags.LevelMask">
            <summary>A mask including all log levels..</summary>
        </member>
        <member name="T:NetVips.Enums.ArgumentFlags">
            <summary>
            Flags we associate with each object argument.
            </summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.NONE">
            <summary>No flags.</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.REQUIRED">
            <summary>Must be set in the constructor.</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.CONSTRUCT">
            <summary>Can only be set in the constructor.</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.SET_ONCE">
            <summary>Can only be set once.</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.SET_ALWAYS">
            <summary>Don't do use-before-set checks.</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.INPUT">
            <summary>Is an input argument (one we depend on).</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.OUTPUT">
            <summary>Is an output argument (depends on us).</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.DEPRECATED">
            <summary>Just there for back-compat, hide.</summary>
        </member>
        <member name="F:NetVips.Enums.ArgumentFlags.MODIFY">
            <summary>The input argument will be modified.</summary>
        </member>
        <member name="T:NetVips.Enums.OperationFlags">
            <summary>
            Flags we associate with an <see cref="T:NetVips.Operation"/>.
            </summary>
        </member>
        <member name="F:NetVips.Enums.OperationFlags.NONE">
            <summary>No flags.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationFlags.SEQUENTIAL">
            <summary>Can work sequentially with a small buffer.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationFlags.SEQUENTIAL_UNBUFFERED">
            <summary>Can work sequentially without a buffer.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationFlags.NOCACHE">
            <summary>Must not be cached.</summary>
        </member>
        <member name="F:NetVips.Enums.OperationFlags.DEPRECATED">
            <summary>A compatibility thing.</summary>
        </member>
        <member name="T:NetVips.Enums.Signals">
            <summary>
            Signals that can be used on an <see cref="T:NetVips.Image"/>. See <see cref="M:NetVips.GObject.SignalConnect(System.String,System.Delegate,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:NetVips.Enums.Signals.PreEval">
            <summary>Evaluation is starting.</summary>
            <remarks>
            The preeval signal is emitted once before computation of <see cref="T:NetVips.Image"/>
            starts. It's a good place to set up evaluation feedback.
            </remarks>
        </member>
        <member name="F:NetVips.Enums.Signals.Eval">
             <summary>Evaluation progress.</summary>
             <remarks>
             The eval signal is emitted once per work unit (typically a 128 x
             128 area of pixels) during image computation.
            
             You can use this signal to update user-interfaces with progress
             feedback. Beware of updating too frequently: you will usually
             need some throttling mechanism.
             </remarks>
        </member>
        <member name="F:NetVips.Enums.Signals.PostEval">
            <summary>Evaluation is ending.</summary>
            <remarks>
            The posteval signal is emitted once at the end of the computation
            of <see cref="T:NetVips.Image"/>. It's a good place to shut down evaluation feedback.
            </remarks>
        </member>
        <member name="T:NetVips.ExtensionMethods">
            <summary>
            Useful extension methods that we use in our codebase.
            </summary>
        </member>
        <member name="M:NetVips.ExtensionMethods.Remove(NetVips.VOption,System.String,System.Object@)">
            <summary>
            Removes the element with the specified key from the <see cref="T:NetVips.VOption"/>
            and retrieves the value to <paramref name="target"/>.
            </summary>
            <param name="self">The <see cref="T:NetVips.VOption"/> to remove from.</param>
            <param name="key">>The key of the element to remove.</param>
            <param name="target">The target to retrieve the value to.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Merge(NetVips.VOption,NetVips.VOption)">
            <summary>
            Merges 2 <see cref="T:NetVips.VOption"/>s.
            </summary>
            <param name="self">The <see cref="T:NetVips.VOption"/> to merge into.</param>
            <param name="merge">The <see cref="T:NetVips.VOption"/> to merge from.</param>
        </member>
        <member name="M:NetVips.ExtensionMethods.Dereference``1(System.IntPtr)">
            <summary>
            Dereferences data from an unmanaged block of memory
            to a newly allocated managed object of the specified type.
            </summary>
            <typeparam name="T">The type of object to be created. This object
            must represent a formatted class or a structure.</typeparam>
            <param name="ptr">A pointer to an unmanaged block of memory.</param>
            <returns>A newly allocated managed object of the specified type.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Call(NetVips.Image,System.String)">
            <summary>
            Call a libvips operation.
            </summary>
            <param name="image">A <see cref="T:NetVips.Image"/> used as guide.</param>
            <param name="operationName">Operation name.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Call(NetVips.Image,System.String,System.Object[])">
            <summary>
            Call a libvips operation.
            </summary>
            <param name="image">A <see cref="T:NetVips.Image"/> used as guide.</param>
            <param name="operationName">Operation name.</param>
            <param name="args">An arbitrary number and variety of arguments.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Call(NetVips.Image,System.String,NetVips.VOption)">
            <summary>
            Call a libvips operation.
            </summary>
            <param name="image">A <see cref="T:NetVips.Image"/> used as guide.</param>
            <param name="operationName">Operation name.</param>
            <param name="kwargs">Optional arguments.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Call(NetVips.Image,System.String,NetVips.VOption,System.Object[])">
            <summary>
            Call a libvips operation.
            </summary>
            <param name="image">A <see cref="T:NetVips.Image"/> used as guide.</param>
            <param name="operationName">Operation name.</param>
            <param name="kwargs">Optional arguments.</param>
            <param name="args">An arbitrary number and variety of arguments.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.PrependImage``1(``0[],NetVips.Image)">
            <summary>
            Prepends <paramref name="image"/> to <paramref name="args"/>.
            </summary>
            <param name="args">The <see cref="T:NetVips.Image"/> array.</param>
            <param name="image">The <see cref="T:NetVips.Image"/> to prepend to <paramref name="args"/>.</param>
            <returns>A new object array.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.ToUtf8String(System.IntPtr,System.Boolean,System.Int32)">
            <summary>
            Marshals a GLib UTF8 char* to a managed string.
            </summary>
            <param name="utf8Str">Pointer to the GLib string.</param>
            <param name="freePtr">If set to <see langword="true"/>, free the GLib string.</param>
            <param name="size">Size of the GLib string, use 0 to read until the null character.</param>
            <returns>The managed string.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.ToReadableBytes(System.UInt64)">
            <summary>
            Convert bytes to human readable format.
            </summary>
            <param name="value">The number of bytes.</param>
            <returns>The readable format of the bytes.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Negate(System.Double[])">
            <summary>
            Negate all elements in an array.
            </summary>
            <param name="array">An array of doubles.</param>
            <returns>The negated array.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Negate(System.Int32[])">
            <summary>
            Negate all elements in an array.
            </summary>
            <remarks>
            It will output an array of doubles instead of integers.
            </remarks>
            <param name="array">An array of integers.</param>
            <returns>The negated array.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Invert(System.Double[])">
            <summary>
            Invert all elements in an array.
            </summary>
            <param name="array">An array of doubles.</param>
            <returns>The inverted array.</returns>
        </member>
        <member name="M:NetVips.ExtensionMethods.Invert(System.Int32[])">
            <summary>
            Invert all elements in an array.
            </summary>
            <remarks>
            It will output an array of doubles instead of integers.
            </remarks>
            <param name="array">An array of integers.</param>
            <returns>The inverted array.</returns>
        </member>
        <member name="T:NetVips.GObject">
            <summary>
            Manage <see cref="T:NetVips.Internal.GObject"/> lifetime.
            </summary>
        </member>
        <member name="F:NetVips.GObject._handles">
            <summary>
            We have to record all of the <see cref="M:NetVips.GObject.SignalConnect(System.String,System.Delegate,System.IntPtr)"/> delegates to
            prevent them from being re-located or disposed of by the garbage collector.
            </summary>
        </member>
        <member name="F:NetVips.GObject.MemoryPressure">
            <summary>
            Hint of how much native memory is actually occupied by the object.
            </summary>
        </member>
        <member name="E:NetVips.GObject.OnUnref">
            <summary>
            A delegate that is called when the object's reference count is decreased.
            </summary>
        </member>
        <member name="M:NetVips.GObject.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:NetVips.GObject"/> class
            with the specified pointer to wrap around.
            </summary>
            <remarks>
            Wraps a GObject instance around an underlying GValue. When the
            instance is garbage-collected, the underlying object is unreferenced.
            </remarks>
            <param name="pointer">The pointer to wrap around.</param>
        </member>
        <member name="M:NetVips.GObject.SignalConnect(System.String,System.Delegate,System.IntPtr)">
            <summary>
            Connects a callback function (<paramref name="callback"/>) to a signal on this object.
            </summary>
            <remarks>
            The callback will be triggered every time this signal is issued on this instance.
            </remarks>
            <param name="detailedSignal">A string of the form "signal-name::detail".</param>
            <param name="callback">The callback to connect.</param>
            <param name="data">Data to pass to handler calls.</param>
            <returns>The handler id.</returns>
            <exception cref="T:System.Exception">If it failed to connect the signal.</exception>
        </member>
        <member name="M:NetVips.GObject.ReleaseHandle">
            <summary>
            Decreases the reference count of object.
            When its reference count drops to 0, the object is finalized (i.e. its memory is freed).
            </summary>
            <returns><see langword="true"/> if the handle is released successfully; otherwise,
            in the event of a catastrophic failure, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.GObject.ObjectRef">
            <summary>
            Increases the reference count of object.
            </summary>
        </member>
        <member name="P:NetVips.GObject.IsInvalid">
            <summary>
            Gets a value indicating whether the handle is invalid.
            </summary>
            <returns><see langword="true"/> if the handle is not valid; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="P:NetVips.GObject.RefCount">
            <summary>
            Get the reference count of object. Handy for debugging.
            </summary>
        </member>
        <member name="T:NetVips.GValue">
             <summary>
             Wrap <see cref="T:NetVips.Internal.GValue"/> in a C# class.
             </summary>
             <remarks>
             This class wraps <see cref="T:NetVips.Internal.GValue"/> in a convenient interface. You can use
             instances of this class to get and set <see cref="T:NetVips.GObject"/> properties.
            
             On construction, <see cref="T:NetVips.Internal.GValue"/> is all zero (empty). You can pass it to
             a get function to have it filled by <see cref="T:NetVips.GObject"/>, or use init to
             set a type, set to set a value, then use it to set an object property.
            
             GValue lifetime is managed automatically.
             </remarks>
        </member>
        <member name="F:NetVips.GValue.Struct">
            <summary>
            The specified struct to wrap around.
            </summary>
        </member>
        <member name="F:NetVips.GValue._disposed">
            <summary>
            Track whether Dispose has been called.
            </summary>
        </member>
        <member name="F:NetVips.GValue.FundamentalShift">
            <summary>
            Shift value used in converting numbers to type IDs.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GBoolType">
            <summary>
            The fundamental type corresponding to gboolean.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GIntType">
            <summary>
            The fundamental type corresponding to gint.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GUint64Type">
            <summary>
            The fundamental type corresponding to guint64.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GEnumType">
            <summary>
            The fundamental type from which all enumeration types are derived.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GFlagsType">
            <summary>
            The fundamental type from which all flags types are derived.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GDoubleType">
            <summary>
            The fundamental type corresponding to gdouble.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GStrType">
            <summary>
            The fundamental type corresponding to null-terminated C strings.
            </summary>
        </member>
        <member name="F:NetVips.GValue.GObjectType">
            <summary>
            The fundamental type for GObject.
            </summary>
        </member>
        <member name="F:NetVips.GValue.ImageType">
            <summary>
            The fundamental type for VipsImage.
            </summary>
        </member>
        <member name="F:NetVips.GValue.ArrayIntType">
            <summary>
            The fundamental type for VipsArrayInt.
            </summary>
        </member>
        <member name="F:NetVips.GValue.ArrayDoubleType">
            <summary>
            The fundamental type for VipsArrayDouble.
            </summary>
        </member>
        <member name="F:NetVips.GValue.ArrayImageType">
            <summary>
            The fundamental type for VipsArrayImage.
            </summary>
        </member>
        <member name="F:NetVips.GValue.RefStrType">
            <summary>
            The fundamental type for VipsRefString.
            </summary>
        </member>
        <member name="F:NetVips.GValue.BlobType">
            <summary>
            The fundamental type for VipsBlob.
            </summary>
        </member>
        <member name="F:NetVips.GValue.BandFormatType">
            <summary>
            The fundamental type for VipsBandFormat. See <see cref="T:NetVips.Enums.BandFormat"/>.
            </summary>
        </member>
        <member name="F:NetVips.GValue.BlendModeType">
            <summary>
            The fundamental type for VipsBlendMode. See <see cref="T:NetVips.Enums.BlendMode"/>.
            </summary>
        </member>
        <member name="F:NetVips.GValue.SourceType">
            <summary>
            The fundamental type for VipsSource. See <see cref="T:NetVips.Source"/>.
            </summary>
        </member>
        <member name="F:NetVips.GValue.TargetType">
            <summary>
            The fundamental type for VipsTarget. See <see cref="T:NetVips.Target"/>.
            </summary>
        </member>
        <member name="F:NetVips.GValue._memoryPressure">
            <summary>
            Hint of how much native memory is actually occupied by the object.
            </summary>
        </member>
        <member name="M:NetVips.GValue.ToEnum(System.IntPtr,System.Object)">
            <summary>
            Turn a string or integer into an enum value ready to be passed into libvips.
            </summary>
            <param name="gtype">The GType.</param>
            <param name="value">The string or integer to convert.</param>
            <returns>An enum value ready to be passed into libvips.</returns>
        </member>
        <member name="M:NetVips.GValue.FromEnum(System.IntPtr,System.Int32)">
            <summary>
            Turn an int back into an enum string.
            </summary>
            <param name="gtype">The GType.</param>
            <param name="enumValue">The integer to convert.</param>
            <returns>An enum value as string.</returns>
        </member>
        <member name="M:NetVips.GValue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetVips.GValue"/> class.
            </summary>
        </member>
        <member name="M:NetVips.GValue.#ctor(NetVips.Internal.GValue.Struct)">
            <summary>
            Initializes a new instance of the <see cref="T:NetVips.GValue"/> class
            with the specified struct to wrap around.
            </summary>
            <param name="value">The specified struct to wrap around.</param>
        </member>
        <member name="M:NetVips.GValue.SetType(System.IntPtr)">
             <summary>
             Set the type of a GValue.
             </summary>
             <remarks>
             GValues have a set type, fixed at creation time. Use SetType to set
             the type of a GValue before assigning to it.
            
             GTypes are 32 or 64-bit integers (depending on the platform). See
             TypeFind.
             </remarks>
             <param name="gtype">Type the GValue should hold values of.</param>
        </member>
        <member name="M:NetVips.GValue.AddMemoryPressure(System.Int64)">
            <summary>
            Ensure that the GC knows the true cost of the object during collection.
            </summary>
            <remarks>
            If the object is actually bigger than the managed size reflects, it may
            be a candidate for quick(er) collection.
            </remarks>
            <param name="bytesAllocated">The amount of unmanaged memory that has been allocated.</param>
        </member>
        <member name="M:NetVips.GValue.Set(System.Object)">
            <summary>
            Set a GValue.
            </summary>
            <remarks>
            The value is converted to the type of the GValue, if possible, and
            assigned.
            </remarks>
            <param name="value">Value to be set.</param>
        </member>
        <member name="M:NetVips.GValue.Get">
            <summary>
            Get the contents of a GValue.
            </summary>
            <remarks>
            The contents of the GValue are read out as a C# type.
            </remarks>
            <returns>The contents of this GValue.</returns>
        </member>
        <member name="M:NetVips.GValue.GetTypeOf">
            <summary>
            Get the GType of this GValue.
            </summary>
            <returns>The GType of this GValue.</returns>
        </member>
        <member name="M:NetVips.GValue.Finalize">
            <summary>
            Finalizes an instance of the <see cref="T:NetVips.GValue"/> class.
            </summary>
            <remarks>
            Allows an object to try to free resources and perform other cleanup
            operations before it is reclaimed by garbage collection.
            </remarks>
        </member>
        <member name="M:NetVips.GValue.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><see langword="true"/> to release both managed and unmanaged resources;
            <see langword="false"/> to release only unmanaged resources.</param>
        </member>
        <member name="M:NetVips.GValue.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing,
            or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:NetVips.Image">
            <summary>
            Wrap a <see cref="T:NetVips.Internal.VipsImage"/> object.
            </summary>
        </member>
        <member name="T:NetVips.Image.EvalDelegate">
            <summary>
            A evaluation delegate that can be used on the
            <see cref="F:NetVips.Enums.Signals.PreEval"/>, <see cref="F:NetVips.Enums.Signals.Eval"/> and
            <see cref="F:NetVips.Enums.Signals.PostEval"/> signals.
            </summary>
            <remarks>
            Use <see cref="M:NetVips.Image.SetProgress(System.Boolean)"/> to enable progress reporting on an image.
            </remarks>
        </member>
        <member name="M:NetVips.Image.#ctor(System.IntPtr)">
            <inheritdoc cref="T:NetVips.VipsObject"/>
        </member>
        <member name="M:NetVips.Image.RunCmplx(System.Func{NetVips.Image,NetVips.Image},NetVips.Image)">
            <summary>
            Run a complex function on a non-complex image.
            </summary>
            <remarks>
            The image needs to be complex, or have an even number of bands. The input
            can be int, the output is always float or double.
            </remarks>
            <param name="func">A complex function.</param>
            <param name="image">A non-complex image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:System.Exception">If image doesn't have an even number of bands.</exception>
        </member>
        <member name="M:NetVips.Image.Imageize(NetVips.Image,System.Object)">
            <summary>
            Turn a constant (eg. 1, "12", new[] {1, 2, 3}, new[] {new[] {1}}) into an image using
            <paramref name="matchImage"/> as a guide.
            </summary>
            <param name="matchImage">Image guide.</param>
            <param name="value">A constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FindLoad(System.String)">
            <summary>
            Find the name of the load operation vips will use to load a file.
            </summary>
            <remarks>
            For example "VipsForeignLoadJpegFile". You can use this to work out what
            options to pass to <see cref="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="filename">The file to test.</param>
            <returns>The name of the load operation, or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FindLoadBuffer(System.Byte[])">
            <summary>
            Find the name of the load operation vips will use to load a buffer.
            </summary>
            <remarks>
            For example "VipsForeignLoadJpegBuffer". You can use this to work out what
            options to pass to <see cref="M:NetVips.Image.NewFromBuffer(System.Byte[],System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="data">The buffer to test.</param>
            <returns>The name of the load operation, or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FindLoadBuffer(System.String)">
            <summary>
            Find the name of the load operation vips will use to load a buffer.
            </summary>
            <remarks>
            For example "VipsForeignLoadJpegBuffer". You can use this to work out what
            options to pass to <see cref="M:NetVips.Image.NewFromBuffer(System.String,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="data">The buffer to test.</param>
            <returns>The name of the load operation, or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FindLoadBuffer(System.Char[])">
            <summary>
            Find the name of the load operation vips will use to load a buffer.
            </summary>
            <remarks>
            For example "VipsForeignLoadJpegBuffer". You can use this to work out what
            options to pass to <see cref="M:NetVips.Image.NewFromBuffer(System.Char[],System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="data">The buffer to test.</param>
            <returns>The name of the load operation, or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FindLoadSource(NetVips.Source)">
            <summary>
            Find the name of the load operation vips will use to load a source.
            </summary>
            <remarks>
            For example "VipsForeignLoadJpegSource". You can use this to work out what
            options to pass to <see cref="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="source">The source to test.</param>
            <returns>The name of the load operation, or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FindLoadStream(System.IO.Stream)">
            <summary>
            Find the name of the load operation vips will use to load a stream.
            </summary>
            <remarks>
            For example "VipsForeignLoadJpegSource". You can use this to work out what
            options to pass to <see cref="M:NetVips.Image.NewFromStream(System.IO.Stream,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="stream">The stream to test.</param>
            <returns>The name of the load operation, or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)">
             <summary>
             Load an image from a file.
             </summary>
             <remarks>
             This method can load images in any format supported by vips. The
             filename can include load options, for example:
             <code language="lang-csharp">
             var image = Image.NewFromFile("fred.jpg[shrink=2]");
             </code>
             You can also supply options as keyword arguments, for example:
             <code language="lang-csharp">
             var image = Image.NewFromFile("fred.jpg", new VOption
             {
                 {"shrink", 2}
             });
             </code>
             The full set of options available depend upon the load operation that
             will be executed. Try something like:
             <code language="lang-shell">
             $ vips jpegload
             </code>
             at the command-line to see a summary of the available options for the
             JPEG loader.
            
             Loading is fast: only enough of the image is loaded to be able to fill
             out the header. Pixels will only be decompressed when they are needed.
             </remarks>
             <param name="vipsFilename">The disc file to load the image from, with
             optional appended arguments.</param>
             <param name="memory">If set to <see langword="true"/>, load the image
             via memory rather than via a temporary disc file. See <see cref="M:NetVips.Image.NewTempFile(System.String)"/>
             for notes on where temporary files are created. Small images are loaded via memory
             by default, use `VIPS_DISC_THRESHOLD` to set the definition of small.</param>
             <param name="access">Hint the expected access pattern for the image.</param>
             <param name="fail">If set to <see langword="true"/>, the loader will fail
             with an error on the first serious error in the file. By default, libvips
             will attempt to read everything it can from a damaged image.</param>
             <param name="kwargs">Optional options that depend on the load operation.</param>
             <returns>A new <see cref="T:NetVips.Image"/>.</returns>
             <exception cref="T:NetVips.VipsException">If unable to load from <paramref name="vipsFilename"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromBuffer(System.Byte[],System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)">
            <summary>
            Load a formatted image from memory.
            </summary>
            <remarks>
            This behaves exactly as <see cref="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>, but the image is
            loaded from the memory object rather than from a file. The memory
            object can be a string or buffer.
            </remarks>
            <param name="data">The memory object to load the image from.</param>
            <param name="strOptions">Load options as a string. Use <see cref="F:System.String.Empty"/> for no options.</param>
            <param name="access">Hint the expected access pattern for the image. See <see cref="T:NetVips.Enums.Access"/>.</param>
            <param name="fail">If set True, the loader will fail with an error on
            the first serious error in the file. By default, libvips
            will attempt to read everything it can from a damaged image.</param>
            <param name="kwargs">Optional options that depend on the load operation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to load from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromBuffer(System.String,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)">
            <summary>
            Load a formatted image from memory.
            </summary>
            <remarks>
            This behaves exactly as <see cref="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>, but the image is
            loaded from the memory object rather than from a file. The memory
            object can be a string or buffer.
            </remarks>
            <param name="data">The memory object to load the image from.</param>
            <param name="strOptions">Load options as a string. Use <see cref="F:System.String.Empty"/> for no options.</param>
            <param name="access">Hint the expected access pattern for the image.</param>
            <param name="fail">If set True, the loader will fail with an error on
            the first serious error in the file. By default, libvips
            will attempt to read everything it can from a damaged image.</param>
            <param name="kwargs">Optional options that depend on the load operation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to load from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromBuffer(System.Char[],System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)">
            <summary>
            Load a formatted image from memory.
            </summary>
            <remarks>
            This behaves exactly as <see cref="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>, but the image is
            loaded from the memory object rather than from a file. The memory
            object can be a string or buffer.
            </remarks>
            <param name="data">The memory object to load the image from.</param>
            <param name="strOptions">Load options as a string. Use <see cref="F:System.String.Empty"/> for no options.</param>
            <param name="access">Hint the expected access pattern for the image.</param>
            <param name="fail">If set True, the loader will fail with an error on
            the first serious error in the file. By default, libvips
            will attempt to read everything it can from a damaged image.</param>
            <param name="kwargs">Optional options that depend on the load operation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to load from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)">
            <summary>
            Load a formatted image from a source.
            </summary>
            <remarks>
            This behaves exactly as <see cref="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>, but the image is
            loaded from a source rather than from a file.
            At least libvips 8.9 is needed.
            </remarks>
            <param name="source">The source to load the image from.</param>
            <param name="strOptions">Load options as a string. Use <see cref="F:System.String.Empty"/> for no options.</param>
            <param name="access">Hint the expected access pattern for the image.</param>
            <param name="fail">If set True, the loader will fail with an error on
            the first serious error in the file. By default, libvips
            will attempt to read everything it can from a damaged image.</param>
            <param name="kwargs">Optional options that depend on the load operation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to load from <paramref name="source"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromStream(System.IO.Stream,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)">
            <summary>
            Load a formatted image from a stream.
            </summary>
            <remarks>
            This behaves exactly as <see cref="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>, but the image is
            loaded from a stream rather than from a source.
            At least libvips 8.9 is needed.
            </remarks>
            <param name="stream">The stream to load the image from.</param>
            <param name="strOptions">Load options as a string. Use <see cref="F:System.String.Empty"/> for no options.</param>
            <param name="access">Hint the expected access pattern for the image.</param>
            <param name="fail">If set True, the loader will fail with an error on
            the first serious error in the file. By default, libvips
            will attempt to read everything it can from a damaged image.</param>
            <param name="kwargs">Optional options that depend on the load operation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to load from <paramref name="stream"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromArray``1(``0[0:,0:],System.Double,System.Double)">
            <summary>
            Create an image from a 2D array.
            </summary>
            <remarks>
            A new one-band image with <see cref="F:NetVips.Enums.BandFormat.Double"/> pixels is
            created from the array. These image are useful with the libvips
            convolution operator <see cref="M:NetVips.Image.Conv(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>.
            </remarks>
            <param name="array">Create the image from these values.</param>
            <param name="scale">Default to 1.0. What to divide each pixel by after
            convolution. Useful for integer convolution masks.</param>
            <param name="offset">Default to 0.0. What to subtract from each pixel
            after convolution. Useful for integer convolution masks.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to make image from <paramref name="array"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromArray``1(``0[][],System.Double,System.Double)">
            <summary>
            Create an image from a 2D array.
            </summary>
            <remarks>
            A new one-band image with <see cref="F:NetVips.Enums.BandFormat.Double"/> pixels is
            created from the array. These image are useful with the libvips
            convolution operator <see cref="M:NetVips.Image.Conv(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>.
            </remarks>
            <param name="array">Create the image from these values.</param>
            <param name="scale">Default to 1.0. What to divide each pixel by after
            convolution. Useful for integer convolution masks.</param>
            <param name="offset">Default to 0.0. What to subtract from each pixel
            after convolution. Useful for integer convolution masks.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to make image from <paramref name="array"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromArray``1(``0[],System.Double,System.Double)">
            <summary>
            Create an image from a 1D array.
            </summary>
            <remarks>
            A new one-band image with <see cref="F:NetVips.Enums.BandFormat.Double"/> pixels is
            created from the array. These image are useful with the libvips
            convolution operator <see cref="M:NetVips.Image.Conv(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>.
            </remarks>
            <param name="array">Create the image from these values.
            1D arrays become a single row of pixels.</param>
            <param name="scale">Default to 1.0. What to divide each pixel by after
            convolution. Useful for integer convolution masks.</param>
            <param name="offset">Default to 0.0. What to subtract from each pixel
            after convolution. Useful for integer convolution masks.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to make image from <paramref name="array"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromMemory(System.Array,System.Int32,System.Int32,System.Int32,System.String)">
             <summary>
             Wrap an image around a memory array.
             </summary>
             <remarks>
             Wraps an Image around an area of memory containing a C-style array. For
             example, if the `data` memory array contains four bytes with the
             values 1, 2, 3, 4, you can make a one-band, 2x2 uchar image from
             it like this:
             <code language="lang-csharp">
             var image = Image.NewFromMemory(data, 2, 2, 1, "uchar");
             </code>
             A reference is kept to the data object, so it will not be
             garbage-collected until the returned image is garbage-collected.
            
             This method is useful for efficiently transferring images from GDI+
             into libvips.
            
             See <see cref="M:NetVips.Image.WriteToMemory"/> for the opposite operation.
            
             Use <see cref="M:NetVips.Image.Copy(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.String,System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Int32},System.Nullable{System.Int32})"/> to set other image attributes.
             </remarks>
             <param name="data">A memory object.</param>
             <param name="width">Image width in pixels.</param>
             <param name="height">Image height in pixels.</param>
             <param name="bands">Number of bands.</param>
             <param name="format">Band format.</param>
             <returns>A new <see cref="T:NetVips.Image"/>.</returns>
             <exception cref="T:NetVips.VipsException">If unable to make image from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromMemoryCopy(System.IntPtr,System.UInt64,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Like <see cref="M:NetVips.Image.NewFromMemory(System.Array,System.Int32,System.Int32,System.Int32,System.String)"/>, but VIPS will make a copy of the memory area.
            This means more memory use and an extra copy operation, but is much simpler and safer.
            </summary>
            <param name="data">A unmanaged block of memory.</param>
            <param name="size">Length of memory.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="bands">Number of bands.</param>
            <param name="format">Band format.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to make image from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewTempFile(System.String)">
             <summary>
             Make a new temporary image.
             </summary>
             <remarks>
             Returns an image backed by a temporary file. When written to with
             <see cref="M:NetVips.Image.Write(NetVips.Image)"/>, a temporary file will be created on disc in the
             specified format. When the image is closed, the file will be deleted
             automatically.
            
             The file is created in the temporary directory. This is set with
             the environment variable `TMPDIR`. If this is not set, then on
             Unix systems, vips will default to `/tmp`. On Windows, vips uses
             `GetTempPath()` to find the temporary directory.
            
             vips uses `g_mkstemp()` to make the temporary filename. They
             generally look something like `vips-12-EJKJFGH.v`.
             </remarks>
             <param name="format">The format for the temp file, for example
             `%s.v` for a vips format file. The `%s` is
             substituted by the file path.</param>
             <returns>A new <see cref="T:NetVips.Image"/>.</returns>
             <exception cref="T:NetVips.VipsException">If unable to make temp file from <paramref name="format"/>.</exception>
        </member>
        <member name="M:NetVips.Image.NewFromImage(NetVips.Image)">
            <summary>
            Make a new image from an existing one.
            </summary>
            <remarks>
            A new image is created which has the same size, format, interpretation
            and resolution as `this`, but with every pixel set to `value`.
            </remarks>
            <param name="value">The value for the pixels. Use a
            single number to make a one-band image; use an array constant
            to make a many-band image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.NewFromImage(System.Double[])">
            <summary>
            Make a new image from an existing one.
            </summary>
            <remarks>
            A new image is created which has the same size, format, interpretation
            and resolution as `this`, but with every pixel set to `value`.
            </remarks>
            <param name="doubles">The value for the pixels. Use a
            single number to make a one-band image; use an array constant
            to make a many-band image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.NewFromImage(System.Int32[])">
            <summary>
            Make a new image from an existing one.
            </summary>
            <remarks>
            A new image is created which has the same size, format, interpretation
            and resolution as `this`, but with every pixel set to `value`.
            </remarks>
            <param name="ints">The value for the pixels. Use a
            single number to make a one-band image; use an array constant
            to make a many-band image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.CopyMemory">
            <summary>
            Copy an image to memory.
            </summary>
            <remarks>
            A large area of memory is allocated, the image is rendered to that
            memory area, and a new image is returned which wraps that large memory
            area.
            </remarks>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to copy to memory.</exception>
        </member>
        <member name="M:NetVips.Image.WriteToFile(System.String,NetVips.VOption)">
             <summary>
             Write an image to a file on disc.
             </summary>
             <remarks>
             This method can save images in any format supported by vips. The format
             is selected from the filename suffix. The filename can include embedded
             save options, see <see cref="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            
             For example:
             <code language="lang-csharp">
             image.WriteToFile("fred.jpg[Q=95]");
             </code>
             You can also supply options as keyword arguments, for example:
             <code language="lang-csharp">
             image.WriteToFile("fred.jpg", new VOption
             {
                 {"Q", 95}
             });
             </code>
             The full set of options available depend upon the save operation that
             will be executed. Try something like:
             <code language="lang-shell">
             $ vips jpegsave
             </code>
             at the command-line to see a summary of the available options for the
             JPEG saver.
             </remarks>
             <param name="vipsFilename">The disc file to save the image to, with
             optional appended arguments.</param>
             <param name="kwargs">Optional options that depend on the save operation.</param>
             <exception cref="T:NetVips.VipsException">If unable to write to <paramref name="vipsFilename"/>.</exception>
        </member>
        <member name="M:NetVips.Image.WriteToBuffer(System.String,NetVips.VOption)">
             <summary>
             Write an image to a formatted string.
             </summary>
             <remarks>
             This method can save images in any format supported by vips. The format
             is selected from the suffix in the format string. This can include
             embedded save options, see <see cref="M:NetVips.Image.NewFromFile(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            
             For example:
             <code language="lang-csharp">
             var data = image.WriteToBuffer(".jpg[Q=95]");
             </code>
             You can also supply options as keyword arguments, for example:
             <code language="lang-csharp">
             var data = image.WriteToBuffer(".jpg", new VOption
             {
                 {"Q", 95}
             });
             </code>
             The full set of options available depend upon the load operation that
             will be executed. Try something like:
             <code language="lang-shell">
             $ vips jpegsave_buffer
             </code>
             at the command-line to see a summary of the available options for the
             JPEG saver.
             </remarks>
             <param name="formatString">The suffix, plus any string-form arguments.</param>
             <param name="kwargs">Optional options that depend on the save operation.</param>
             <returns>An array of bytes.</returns>
             <exception cref="T:NetVips.VipsException">If unable to write to buffer.</exception>
        </member>
        <member name="M:NetVips.Image.WriteToTarget(NetVips.Target,System.String,NetVips.VOption)">
            <summary>
            Write an image to a target.
            </summary>
            <remarks>
            This behaves exactly as <see cref="M:NetVips.Image.WriteToFile(System.String,NetVips.VOption)"/>, but the image is
            written to a target rather than a file.
            At least libvips 8.9 is needed.
            </remarks>
            <param name="target">Write to this target.</param>
            <param name="formatString">The suffix, plus any string-form arguments.</param>
            <param name="kwargs">Optional options that depend on the save operation.</param>
            <exception cref="T:NetVips.VipsException">If unable to write to target.</exception>
        </member>
        <member name="M:NetVips.Image.WriteToStream(System.IO.Stream,System.String,NetVips.VOption)">
            <summary>
            Write an image to a stream.
            </summary>
            <remarks>
            This behaves exactly as <see cref="M:NetVips.Image.WriteToTarget(NetVips.Target,System.String,NetVips.VOption)"/>, but the image is
            written to a stream rather than a target.
            At least libvips 8.9 is needed.
            </remarks>
            <param name="stream">Write to this stream.</param>
            <param name="formatString">The suffix, plus any string-form arguments.</param>
            <param name="kwargs">Optional options that depend on the save operation.</param>
            <exception cref="T:NetVips.VipsException">If unable to write to stream.</exception>
        </member>
        <member name="M:NetVips.Image.WriteToMemory(System.UInt64@)">
            <summary>
            Write the image to memory as a simple, unformatted C-style array.
            </summary>
            <remarks>
            The caller is responsible for freeing this memory with <see cref="M:NetVips.NetVips.Free(System.IntPtr)"/>.
            </remarks>
            <param name="size">Output buffer length.</param>
            <returns>A <see cref="T:System.IntPtr"/> pointing to an unformatted C-style array.</returns>
            <exception cref="T:NetVips.VipsException">If unable to write to memory.</exception>
        </member>
        <member name="M:NetVips.Image.WriteToMemory">
             <summary>
             Write the image to a large memory array.
             </summary>
             <remarks>
             A large area of memory is allocated, the image is rendered to that
             memory array, and the array is returned as a buffer.
            
             For example, if you have a 2x2 uchar image containing the bytes 1, 2,
             3, 4, read left-to-right, top-to-bottom, then:
             <code language="lang-csharp">
             var buf = image.WriteToMemory();
             </code>
             will return a four byte buffer containing the values 1, 2, 3, 4.
             </remarks>
             <returns>An array of bytes.</returns>
             <exception cref="T:NetVips.VipsException">If unable to write to memory.</exception>
        </member>
        <member name="M:NetVips.Image.Write(NetVips.Image)">
            <summary>
            Write an image to another image.
            </summary>
            <remarks>
            This function writes `this` to another image. Use something like
            <see cref="M:NetVips.Image.NewTempFile(System.String)"/> to make an image that can be written to.
            </remarks>
            <param name="other">The <see cref="T:NetVips.Image"/> to write to.</param>
            <exception cref="T:NetVips.VipsException">If unable to write to image.</exception>
        </member>
        <member name="M:NetVips.Image.GetTypeOf(System.String)">
            <summary>
            Get the GType of an item of metadata.
            </summary>
            <remarks>
            Fetch the GType of a piece of metadata, or <see cref="F:System.IntPtr.Zero"/> if the named
            item does not exist. See <see cref="T:NetVips.GValue"/>.
            </remarks>
            <param name="name">The name of the piece of metadata to get the type of.</param>
            <returns>A new instance of <see cref="T:System.IntPtr"/> initialized to the GType or
            <see cref="F:System.IntPtr.Zero"/> if the property does not exist.</returns>
        </member>
        <member name="M:NetVips.Image.Contains(System.String)">
            <summary>
            Check if the underlying image contains an property of metadata.
            </summary>
            <param name="name">The name of the piece of metadata to check for.</param>
            <returns><see langword="true"/> if the metadata exits; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Get(System.String)">
            <summary>
            Get an item of metadata.
            </summary>
            <remarks>
            Fetches an item of metadata as a C# value. For example:
            <code language="lang-csharp">
            var orientation = image.Get("orientation");
            </code>
            would fetch the image orientation.
            </remarks>
            <param name="name">The name of the piece of metadata to get.</param>
            <returns>The metadata item as a C# value.</returns>
            <exception cref="T:NetVips.VipsException">If unable to get <paramref name="name"/>.</exception>
        </member>
        <member name="M:NetVips.Image.GetFields">
            <summary>
            Get a list of all the metadata fields on an image.
            </summary>
            <remarks>
            At least libvips 8.5 is needed.
            </remarks>
            <returns>An array of strings or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Set(System.IntPtr,System.String,System.Object)">
            <summary>
            Set the type and value of an item of metadata.
            </summary>
            <remarks>
            Sets the type and value of an item of metadata. Any old item of the
            same name is removed. See <see cref="T:NetVips.GValue"/> for types.
            </remarks>
            <param name="gtype">The GType of the metadata item to create.</param>
            <param name="name">The name of the piece of metadata to create.</param>
            <param name="value">The value to set as a C# value. It is
            converted to the GType, if possible.</param>
        </member>
        <member name="M:NetVips.Image.Set(System.String,System.Object)">
            <summary>
            Set the value of an item of metadata.
            </summary>
            <remarks>
            Sets the value of an item of metadata. The metadata item must already
            exist.
            </remarks>
            <param name="name">The name of the piece of metadata to set the value of.</param>
            <param name="value">The value to set as a C# value. It is
            converted to the type of the metadata item, if possible.</param>
            <exception cref="T:System.Exception">If metadata item <paramref name="name"/> does not exist.</exception>
        </member>
        <member name="M:NetVips.Image.Remove(System.String)">
            <summary>
            Remove an item of metadata.
            </summary>
            <remarks>
            The named metadata item is removed.
            </remarks>
            <param name="name">The name of the piece of metadata to remove.</param>
            <returns><see langword="true"/> if the metadata is successfully removed; 
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ToString">
            <summary>
            Returns a string that represents the current image.
            </summary>
            <returns>A string that represents the current image.</returns>
        </member>
        <member name="M:NetVips.Image.ScaleImage(System.Nullable{System.Double},System.Nullable{System.Boolean})">
            <summary>
            Scale an image to 0 - 255.
            </summary>
            <remarks>
            This is the libvips `scale` operation, renamed to avoid a clash with
            the `scale` for convolution masks.
            </remarks>
            <example>
            <code language="lang-csharp">
            Image @out = in.Scale(exp: double, log: bool);
            </code>
            </example>
            <param name="exp">Exponent for log scale.</param>
            <param name="log">Log scale.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Ifthenelse(System.Object,System.Object,System.Nullable{System.Boolean})">
            <summary>
            Ifthenelse an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = cond.Ifthenelse(in1, in2, blend: bool);
            </code>
            </example>
            <param name="in1">Source for TRUE pixels.</param>
            <param name="in2">Source for FALSE pixels.</param>
            <param name="blend">Blend smoothly between then and else parts.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Case(System.Double[])">
            <summary>
            Use pixel values to pick cases from an array of constants.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = index.Case(10.5, 20.5);
            </code>
            </example>
            <param name="doubles">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Case(System.Int32[])">
            <summary>
            Use pixel values to pick cases from an array of constants.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = index.Case(10, 20);
            </code>
            </example>
            <param name="ints">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Case(NetVips.Image[])">
            <summary>
            Use pixel values to pick cases from an array of images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = index.Case(images);
            </code>
            </example>
            <param name="images">Array of case images.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Case(System.Object[])">
            <summary>
            Use pixel values to pick cases from an a set of mixed images and constants.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = index.Case(image, 10);
            </code>
            </example>
            <param name="objects">Array of mixed images and constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandjoin(System.Double[])">
            <summary>
            Append a set of constants bandwise.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandjoin(127.5, 255.0);
            </code>
            </example>
            <param name="doubles">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandjoin(System.Int32[])">
            <summary>
            Append a set of constants bandwise.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandjoin(255, 128);
            </code>
            </example>
            <param name="ints">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandjoin(NetVips.Image[])">
            <summary>
            Append a set of images bandwise.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandjoin(image2, image3);
            </code>
            </example>
            <param name="images">Array of images.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandjoin(System.Object[])">
            <summary>
            Append a set of mixed images and constants bandwise.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandjoin(image2, 255);
            </code>
            </example>
            <param name="objects">Array of mixed images and constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandrank(System.Double[],System.Nullable{System.Int32})">
            <summary>
            Band-wise rank a set of constants.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandrank(other, index: int);
            </code>
            </example>
            <param name="doubles">Array of constants.</param>
            <param name="index">Select this band element from sorted list.</param>
            <returns>A new <see cref="T:NetVips.Image"/></returns>
        </member>
        <member name="M:NetVips.Image.Bandrank(System.Int32[],System.Nullable{System.Int32})">
            <summary>
            Band-wise rank a set of constants.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandrank(other, index: int);
            </code>
            </example>
            <param name="ints">Array of constants.</param>
            <param name="index">Select this band element from sorted list.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandrank(NetVips.Image[],System.Nullable{System.Int32})">
            <summary>
            Band-wise rank a set of images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandrank(other, index: int);
            </code>
            </example>
            <param name="images">Array of input images.</param>
            <param name="index">Select this band element from sorted list.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandrank(NetVips.Image,System.Nullable{System.Int32})">
            <summary>
            Band-wise rank a image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandrank(other, index: int);
            </code>
            </example>
            <param name="other">Input image.</param>
            <param name="index">Select this band element from sorted list.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandrank(System.Object[],System.Nullable{System.Int32})">
            <summary>
            Band-wise rank a set of mixed images and constants.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Bandrank(new object[] { image2, 255 }, index: int);
            </code>
            </example>
            <param name="objects">Array of mixed images and constants.</param>
            <param name="index">Select this band element from sorted list.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Composite(NetVips.Image[],System.Int32[],System.Int32[],System.Int32[],System.String,System.Nullable{System.Boolean})">
            <summary>
            Blend an array of images with an array of blend modes.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Composite(images, modes, x: int[], y: int[], compositingSpace: string, premultiplied: bool);
            </code>
            </example>
            <param name="images">Array of input images.</param>
            <param name="modes">Array of VipsBlendMode to join with.</param>
            <param name="x">Array of x coordinates to join at.</param>
            <param name="y">Array of y coordinates to join at.</param>
            <param name="compositingSpace">Composite images in this colour space.</param>
            <param name="premultiplied">Images have premultiplied alpha.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Composite(NetVips.Image[],System.String[],System.Int32[],System.Int32[],System.String,System.Nullable{System.Boolean})">
            <summary>
            Blend an array of images with an array of blend modes.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = image.Composite(images, modes, x: int[], y: int[], compositingSpace: string, premultiplied: bool);
            </code>
            </example>
            <param name="images">Array of input images.</param>
            <param name="modes">Array of VipsBlendMode to join with.</param>
            <param name="x">Array of x coordinates to join at.</param>
            <param name="y">Array of y coordinates to join at.</param>
            <param name="compositingSpace">Composite images in this colour space.</param>
            <param name="premultiplied">Images have premultiplied alpha.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Composite(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean})">
            <summary>
            A synonym for <see cref="M:NetVips.Image.Composite2(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean})"/>.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = base.Composite(overlay, mode, x: int, y: int, compositingSpace: string, premultiplied: bool);
            </code>
            </example>
            <param name="overlay">Overlay image.</param>
            <param name="mode">VipsBlendMode to join with.</param>
            <param name="x">x position of overlay.</param>
            <param name="y">y position of overlay.</param>
            <param name="compositingSpace">Composite images in this colour space.</param>
            <param name="premultiplied">Images have premultiplied alpha.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Crop(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            A synonym for <see cref="M:NetVips.Image.ExtractArea(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = input.Crop(left, top, width, height);
            </code>
            </example>
            <param name="left">Left edge of extract area.</param>
            <param name="top">Top edge of extract area.</param>
            <param name="width">Width of extract area.</param>
            <param name="height">Height of extract area.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaxPos">
            <summary>
            Return the coordinates of the image maximum.
            </summary>
            <returns>An array of doubles.</returns>
        </member>
        <member name="M:NetVips.Image.MinPos">
            <summary>
            Return the coordinates of the image minimum.
            </summary>
            <returns>An array of doubles.</returns>
        </member>
        <member name="M:NetVips.Image.Real">
            <summary>
            Return the real part of a complex image.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Imag">
            <summary>
            Return the imaginary part of a complex image.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Polar">
            <summary>
             Return an image converted to polar coordinates.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rect">
            <summary>
            Return an image converted to rectangular coordinates.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Conj">
            <summary>
            Return the complex conjugate of an image.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Sin">
            <summary>
            Return the sine of an image in degrees.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Cos">
            <summary>
            Return the cosine of an image in degrees.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Tan">
            <summary>
            Return the tangent of an image in degrees.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Asin">
            <summary>
            Return the inverse sine of an image in degrees.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Acos">
            <summary>
            Return the inverse cosine of an image in degrees.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Atan">
            <summary>
            Return the inverse tangent of an image in degrees.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Log">
            <summary>
            Return the natural log of an image.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Log10">
            <summary>
            Return the log base 10 of an image.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Exp">
            <summary>
            Return e ** pixel.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Exp10">
            <summary>
            Return 10 ** pixel.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pow(NetVips.Image)">
            <summary>
            Raise to power of an image.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pow(System.Double)">
            <summary>
            Raise to power of an constant.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pow(System.Double[])">
            <summary>
            Raise to power of an array.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pow(System.Int32[])">
            <summary>
            Raise to power of an array.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Wop(NetVips.Image)">
            <summary>
            Raise to power of an image, but with the arguments reversed.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Wop(System.Double)">
            <summary>
            Raise to power of an constant, but with the arguments reversed.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Wop(System.Double[])">
            <summary>
            Raise to power of an array, but with the arguments reversed.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Wop(System.Int32[])">
            <summary>
            Raise to power of an array, but with the arguments reversed.
            </summary>
            <param name="other">To the power of this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Erode(NetVips.Image)">
            <summary>
            Erode with a structuring element.
            </summary>
            <param name="mask">The structuring element.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Dilate(NetVips.Image)">
            <summary>
            Dilate with a structuring element.
            </summary>
            <param name="mask">The structuring element.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Median(System.Int32)">
            <summary>
            size x size median filter.
            </summary>
            <param name="size">The median filter.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FlipHor">
            <summary>
            Flip horizontally.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FlipVer">
            <summary>
            Flip vertically.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rot90">
            <summary>
            Rotate 90 degrees clockwise.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rot180">
            <summary>
            Rotate 180 degrees.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rot270">
            <summary>
            Rotate 270 degrees clockwise.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Floor">
            <summary>
            Return the largest integral value not greater than the argument.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Ceil">
            <summary>
            Return the largest integral value not greater than the argument.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rint">
            <summary>
            Return the nearest integral value.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.BandAnd">
            <summary>
            AND image bands together.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.BandOr">
            <summary>
            OR image bands together.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.BandEor">
            <summary>
            EOR image bands together.
            </summary>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Equal(NetVips.Image)">
            <summary>
            This operation compares two images on equality.
            </summary>
            <param name="right">A <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Equal(System.Double[])">
            <summary>
            This operation compares two images on equality.
            </summary>
            <param name="right">A double array to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Equal(System.Int32[])">
            <summary>
            This operation compares two images on equality.
            </summary>
            <param name="right">A integer array to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Equal(System.Double)">
            <summary>
            This operation compares two images on equality.
            </summary>
            <param name="right">A double constant to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.NotEqual(NetVips.Image)">
            <summary>
            This operation compares two images on inequality.
            </summary>
            <param name="right">A <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.NotEqual(System.Double)">
            <summary>
            This operation compares two images on inequality.
            </summary>
            <param name="right">A double constant  to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.NotEqual(System.Double[])">
            <summary>
            This operation compares two images on inequality.
            </summary>
            <param name="right">A double array to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.NotEqual(System.Int32[])">
            <summary>
            This operation compares two images on inequality.
            </summary>
            <param name="right">A integer array to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HasAlpha">
            <summary>
            Does this image have an alpha channel?
            </summary>
            <remarks>
            Uses colour space interpretation with number of channels to guess
            this.
            </remarks>
            <returns><see langword="true"/> if this image has an alpha channel;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.Image.IsKilled">
            <summary>
            If image has been killed (see <see cref="M:NetVips.Image.SetKill(System.Boolean)"/>), set an error message,
            clear the `kill` flag and return <see langword="true"/>.
            Otherwise return <see langword="false"/>.
            </summary>
            <remarks>
            Handy for loops which need to run sets of threads which can fail.
            At least libvips 8.8 is needed. If this version requirement is not met,
            it will always return <see langword="false"/>.
            </remarks>
            <returns><see langword="true"/> if image has been killed; 
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SetKill(System.Boolean)">
            <summary>
            Set the `kill` flag on an image. Handy for stopping sets of threads.
            </summary>
            <remarks>
            At least libvips 8.8 is needed.
            </remarks>
            <param name="kill">The kill state.</param>
        </member>
        <member name="M:NetVips.Image.SetProgress(System.Boolean)">
            <summary>
            Enable progress reporting on an image.
            </summary>
            <remarks>
            When progress reporting is enabled, evaluation of the most downstream
            image from this image will report progress using the <see cref="F:NetVips.Enums.Signals.PreEval"/>,
            <see cref="F:NetVips.Enums.Signals.Eval"/> and <see cref="F:NetVips.Enums.Signals.PostEval"/> signals.
            </remarks>
            <param name="progress"><see langword="true"/> to enable progress reporting;
            otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:NetVips.Image.SetProgress(System.IProgress{System.Int32},System.Threading.CancellationToken)">
             <summary>
             Attach progress feedback, if required.
             </summary>
             <remarks>
             You can use this function to update user-interfaces with
             progress feedback, for example:
             <code language="lang-csharp">
             var image = Image.NewFromFile("huge.jpg", access: Enums.Access.Sequential);
            
             var progress = new Progress&lt;int&gt;(percent =>
             {
                 Console.Write($"\r{percent}% complete");
             });
             image.SetProgress(progress);
            
             image.Dzsave("image-pyramid");
             </code>
            
             If a cancellation has been requested for this token (see <paramref name="token"/>)
             it will block the evaluation of this image on libvips >= 8.8 (see <see cref="M:NetVips.Image.SetKill(System.Boolean)"/>).
             If this version requirement is not met, it will only stop updating the progress.
             </remarks>
             <param name="progress">A provider for progress updates.</param>
             <param name="token">Cancellation token to block evaluation on this image.</param>
        </member>
        <member name="P:NetVips.Image.PageHeight">
            <summary>
            Multi-page images can have a page height.
            If page-height is not set, it defaults to the image height.
            </summary>
            <remarks>
            At least libvips 8.8 is needed.
            </remarks>
        </member>
        <member name="M:NetVips.Image.BandExists(System.Int32)">
            <summary>
            Does band exist in image.
            </summary>
            <param name="i">The index to fetch.</param>
            <returns>true if the index exists.</returns>
        </member>
        <member name="P:NetVips.Image.Item(System.Int32)">
            <summary>
            Overload `[]`.
            </summary>
            <remarks>
            Use `[]` to pull out band elements from an image. For example:
            <code language="lang-csharp">
            var green = rgbImage[1];
            </code>
            Will make a new one-band image from band 1 (the middle band).
            </remarks>
            <param name="i">The band element to pull out.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="P:NetVips.Image.Item(System.Int32,System.Int32)">
            <summary>
            A synonym for <see cref="M:NetVips.Image.Getpoint(System.Int32,System.Int32)"/>.
            </summary>
            <example>
            <code language="lang-csharp">
            double[] outArray = in[x, y];
            </code>
            </example>
            <param name="x">Point to read.</param>
            <param name="y">Point to read.</param>
            <returns>An array of doubles.</returns>
        </member>
        <member name="M:NetVips.Image.Bandsplit">
            <summary>
            Split an n-band image into n separate images.
            </summary>
            <returns>An array of <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Equals(NetVips.Image)">
            <summary>
            Compares the hashcode of two images.
            </summary>
            <param name="other">The <see cref="T:NetVips.Image"/> to compare.</param>
            <returns><see langword="true"/> if equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current image.
            </summary>
            <param name="obj">The object to compare with the current image.</param>
            <returns><see langword="true"/> if the specified object is equal
            to the current image; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.Image.GetHashCode">
            <summary>
            Serves as the default hash function.
            </summary>
            <returns>A hash code for the current image.</returns>
        </member>
        <member name="M:NetVips.Image.Abs">
            <summary>
            Absolute value of an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Abs();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Add(NetVips.Image)">
            <summary>
            Add two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Add(right);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Affine(System.Double[],NetVips.GObject,System.Int32[],System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.String)">
            <summary>
            Affine transform of an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Affine(matrix, interpolate: GObject, oarea: int[], odx: double, ody: double, idx: double, idy: double, background: double[], extend: string);
            </code>
            </example>
            <param name="matrix">Transformation matrix.</param>
            <param name="interpolate">Interpolate pixels with this.</param>
            <param name="oarea">Area of output to generate.</param>
            <param name="odx">Horizontal output displacement.</param>
            <param name="ody">Vertical output displacement.</param>
            <param name="idx">Horizontal input displacement.</param>
            <param name="idy">Vertical input displacement.</param>
            <param name="background">Background value.</param>
            <param name="extend">How to generate the extra pixels.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Analyzeload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load an Analyze6 image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Analyzeload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Analyzeload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load an Analyze6 image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Analyzeload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Arrayjoin(NetVips.Image[],System.Nullable{System.Int32},System.Nullable{System.Int32},System.Double[],System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Join an array of images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Arrayjoin(@in, across: int, shim: int, background: double[], halign: string, valign: string, hspacing: int, vspacing: int);
            </code>
            </example>
            <param name="in">Array of input images.</param>
            <param name="across">Number of images across grid.</param>
            <param name="shim">Pixels between images.</param>
            <param name="background">Colour for new pixels.</param>
            <param name="halign">Align on the left, centre or right.</param>
            <param name="valign">Align on the top, centre or bottom.</param>
            <param name="hspacing">Horizontal spacing between images.</param>
            <param name="vspacing">Vertical spacing between images.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Autorot">
            <summary>
            Autorotate image by exif tag.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Autorot();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Autorot(System.String@)">
            <summary>
            Autorotate image by exif tag.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Autorot(out var angle);
            </code>
            </example>
            <param name="angle">Angle image was rotated by.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Avg">
            <summary>
            Find image average.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Avg();
            </code>
            </example>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Bandbool(System.String)">
            <summary>
            Boolean operation across image bands.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Bandbool(boolean);
            </code>
            </example>
            <param name="boolean">boolean to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandfold(System.Nullable{System.Int32})">
            <summary>
            Fold up x axis into bands.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Bandfold(factor: int);
            </code>
            </example>
            <param name="factor">Fold by this factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.BandjoinConst(System.Double[])">
            <summary>
            Append a constant band to an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.BandjoinConst(c);
            </code>
            </example>
            <param name="c">Array of constants to add.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandmean">
            <summary>
            Band-wise average.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Bandmean();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Bandunfold(System.Nullable{System.Int32})">
            <summary>
            Unfold image bands into x axis.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Bandunfold(factor: int);
            </code>
            </example>
            <param name="factor">Unfold by this factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Black(System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Make a black image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Black(width, height, bands: int);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="bands">Number of bands in image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Boolean(NetVips.Image,System.String)">
            <summary>
            Boolean operation on two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Boolean(right, boolean);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <param name="boolean">boolean to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.BooleanConst(System.String,System.Double[])">
            <summary>
            Boolean operations against a constant.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.BooleanConst(boolean, c);
            </code>
            </example>
            <param name="boolean">boolean to perform.</param>
            <param name="c">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Buildlut">
            <summary>
            Build a look-up table.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Buildlut();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Byteswap">
            <summary>
            Byteswap an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Byteswap();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Cache(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Cache an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Cache(maxTiles: int, tileHeight: int, tileWidth: int);
            </code>
            </example>
            <param name="maxTiles">Maximum number of tiles to cache.</param>
            <param name="tileHeight">Tile height in pixels.</param>
            <param name="tileWidth">Tile width in pixels.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Canny(System.Nullable{System.Double},System.String)">
            <summary>
            Canny edge detector.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Canny(sigma: double, precision: string);
            </code>
            </example>
            <param name="sigma">Sigma of Gaussian.</param>
            <param name="precision">Convolve with this precision.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Cast(System.String,System.Nullable{System.Boolean})">
            <summary>
            Cast an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Cast(format, shift: bool);
            </code>
            </example>
            <param name="format">Format to cast to.</param>
            <param name="shift">Shift integer values up and down.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.CMC2LCh">
            <summary>
            Transform LCh to CMC.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.CMC2LCh();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.CMYK2XYZ">
            <summary>
            Transform CMYK to XYZ.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.CMYK2XYZ();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Colourspace(System.String,System.String)">
            <summary>
            Convert to a new colorspace.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Colourspace(space, sourceSpace: string);
            </code>
            </example>
            <param name="space">Destination color space.</param>
            <param name="sourceSpace">Source color space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Compass(NetVips.Image,System.Nullable{System.Int32},System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Convolve with rotating mask.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Compass(mask, times: int, angle: string, combine: string, precision: string, layers: int, cluster: int);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <param name="times">Rotate and convolve this many times.</param>
            <param name="angle">Rotate mask by this much between convolutions.</param>
            <param name="combine">Combine convolution results like this.</param>
            <param name="precision">Convolve with this precision.</param>
            <param name="layers">Use this many layers in approximation.</param>
            <param name="cluster">Cluster lines closer than this in approximation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Complex(System.String)">
            <summary>
            Perform a complex operation on an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Complex(cmplx);
            </code>
            </example>
            <param name="cmplx">complex to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Complex2(NetVips.Image,System.String)">
            <summary>
            Complex binary operations on two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Complex2(right, cmplx);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <param name="cmplx">binary complex operation to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Complexform(NetVips.Image)">
            <summary>
            Form a complex image from two real images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Complexform(right);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Complexget(System.String)">
            <summary>
            Get a component from a complex image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Complexget(get);
            </code>
            </example>
            <param name="get">complex to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Composite2(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean})">
            <summary>
            Blend a pair of images with a blend mode.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = base.Composite2(overlay, mode, x: int, y: int, compositingSpace: string, premultiplied: bool);
            </code>
            </example>
            <param name="overlay">Overlay image.</param>
            <param name="mode">VipsBlendMode to join with.</param>
            <param name="x">x position of overlay.</param>
            <param name="y">y position of overlay.</param>
            <param name="compositingSpace">Composite images in this colour space.</param>
            <param name="premultiplied">Images have premultiplied alpha.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Conv(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Convolution operation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Conv(mask, precision: string, layers: int, cluster: int);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <param name="precision">Convolve with this precision.</param>
            <param name="layers">Use this many layers in approximation.</param>
            <param name="cluster">Cluster lines closer than this in approximation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Conva(NetVips.Image,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Approximate integer convolution.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Conva(mask, layers: int, cluster: int);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <param name="layers">Use this many layers in approximation.</param>
            <param name="cluster">Cluster lines closer than this in approximation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Convasep(NetVips.Image,System.Nullable{System.Int32})">
            <summary>
            Approximate separable integer convolution.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Convasep(mask, layers: int);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <param name="layers">Use this many layers in approximation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Convf(NetVips.Image)">
            <summary>
            Float convolution operation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Convf(mask);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Convi(NetVips.Image)">
            <summary>
            Int convolution operation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Convi(mask);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Convsep(NetVips.Image,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Seperable convolution operation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Convsep(mask, precision: string, layers: int, cluster: int);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <param name="precision">Convolve with this precision.</param>
            <param name="layers">Use this many layers in approximation.</param>
            <param name="cluster">Cluster lines closer than this in approximation.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Copy(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.String,System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Copy an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Copy(width: int, height: int, bands: int, format: string, coding: string, interpretation: string, xres: double, yres: double, xoffset: int, yoffset: int);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="bands">Number of bands in image.</param>
            <param name="format">Pixel format in image.</param>
            <param name="coding">Pixel coding.</param>
            <param name="interpretation">Pixel interpretation.</param>
            <param name="xres">Horizontal resolution in pixels/mm.</param>
            <param name="yres">Vertical resolution in pixels/mm.</param>
            <param name="xoffset">Horizontal offset of origin.</param>
            <param name="yoffset">Vertical offset of origin.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Countlines(System.String)">
            <summary>
            Count lines in an image.
            </summary>
            <example>
            <code language="lang-csharp">
            double nolines = in.Countlines(direction);
            </code>
            </example>
            <param name="direction">Countlines left-right or up-down.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Csvload(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load csv from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Csvload(filename, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="skip">Skip this many lines at the start of the file.</param>
            <param name="lines">Read this many lines from the file.</param>
            <param name="whitespace">Set of whitespace characters.</param>
            <param name="separator">Set of separator characters.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Csvload(System.String,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load csv from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Csvload(filename, out var flags, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="skip">Skip this many lines at the start of the file.</param>
            <param name="lines">Read this many lines from the file.</param>
            <param name="whitespace">Set of whitespace characters.</param>
            <param name="separator">Set of separator characters.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Csvsave(System.String,System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to csv file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Csvsave(filename, separator: string, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="separator">Separator characters.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.DE00(NetVips.Image)">
            <summary>
            Calculate dE00.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.DE00(right);
            </code>
            </example>
            <param name="right">Right-hand input image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DE76(NetVips.Image)">
            <summary>
            Calculate dE76.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.DE76(right);
            </code>
            </example>
            <param name="right">Right-hand input image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DECMC(NetVips.Image)">
            <summary>
            Calculate dECMC.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.DECMC(right);
            </code>
            </example>
            <param name="right">Right-hand input image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Deviate">
            <summary>
            Find image standard deviation.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Deviate();
            </code>
            </example>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Divide(NetVips.Image)">
            <summary>
            Divide two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Divide(right);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawCircle(System.Double[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Draw a circle on an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawCircle(ink, cx, cy, radius, fill: bool);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="cx">Centre of draw_circle.</param>
            <param name="cy">Centre of draw_circle.</param>
            <param name="radius">Radius in pixels.</param>
            <param name="fill">Draw a solid object.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawFlood(System.Double[],System.Int32,System.Int32,NetVips.Image,System.Nullable{System.Boolean})">
            <summary>
            Flood-fill an area.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawFlood(ink, x, y, test: Image, equal: bool);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="x">DrawFlood start point.</param>
            <param name="y">DrawFlood start point.</param>
            <param name="test">Test pixels in this image.</param>
            <param name="equal">DrawFlood while equal to edge.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawFlood(System.Double[],System.Int32,System.Int32,System.Int32@,NetVips.Image,System.Nullable{System.Boolean})">
            <summary>
            Flood-fill an area.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawFlood(ink, x, y, out var left, test: Image, equal: bool);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="x">DrawFlood start point.</param>
            <param name="y">DrawFlood start point.</param>
            <param name="left">Left edge of modified area.</param>
            <param name="test">Test pixels in this image.</param>
            <param name="equal">DrawFlood while equal to edge.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawFlood(System.Double[],System.Int32,System.Int32,System.Int32@,System.Int32@,NetVips.Image,System.Nullable{System.Boolean})">
            <summary>
            Flood-fill an area.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawFlood(ink, x, y, out var left, out var top, test: Image, equal: bool);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="x">DrawFlood start point.</param>
            <param name="y">DrawFlood start point.</param>
            <param name="left">Left edge of modified area.</param>
            <param name="top">top edge of modified area.</param>
            <param name="test">Test pixels in this image.</param>
            <param name="equal">DrawFlood while equal to edge.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawFlood(System.Double[],System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,NetVips.Image,System.Nullable{System.Boolean})">
            <summary>
            Flood-fill an area.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawFlood(ink, x, y, out var left, out var top, out var width, test: Image, equal: bool);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="x">DrawFlood start point.</param>
            <param name="y">DrawFlood start point.</param>
            <param name="left">Left edge of modified area.</param>
            <param name="top">top edge of modified area.</param>
            <param name="width">width of modified area.</param>
            <param name="test">Test pixels in this image.</param>
            <param name="equal">DrawFlood while equal to edge.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawFlood(System.Double[],System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,NetVips.Image,System.Nullable{System.Boolean})">
            <summary>
            Flood-fill an area.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawFlood(ink, x, y, out var left, out var top, out var width, out var height, test: Image, equal: bool);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="x">DrawFlood start point.</param>
            <param name="y">DrawFlood start point.</param>
            <param name="left">Left edge of modified area.</param>
            <param name="top">top edge of modified area.</param>
            <param name="width">width of modified area.</param>
            <param name="height">height of modified area.</param>
            <param name="test">Test pixels in this image.</param>
            <param name="equal">DrawFlood while equal to edge.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawImage(NetVips.Image,System.Int32,System.Int32,System.String)">
            <summary>
            Paint an image into another image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawImage(sub, x, y, mode: string);
            </code>
            </example>
            <param name="sub">Sub-image to insert into main image.</param>
            <param name="x">Draw image here.</param>
            <param name="y">Draw image here.</param>
            <param name="mode">Combining mode.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawLine(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw a line on an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawLine(ink, x1, y1, x2, y2);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="x1">Start of draw_line.</param>
            <param name="y1">Start of draw_line.</param>
            <param name="x2">End of draw_line.</param>
            <param name="y2">End of draw_line.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawMask(System.Double[],NetVips.Image,System.Int32,System.Int32)">
            <summary>
            Draw a mask on an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawMask(ink, mask, x, y);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="mask">Mask of pixels to draw.</param>
            <param name="x">Draw mask here.</param>
            <param name="y">Draw mask here.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawRect(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Paint a rectangle on an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawRect(ink, left, top, width, height, fill: bool);
            </code>
            </example>
            <param name="ink">Color for pixels.</param>
            <param name="left">Rect to fill.</param>
            <param name="top">Rect to fill.</param>
            <param name="width">Rect to fill.</param>
            <param name="height">Rect to fill.</param>
            <param name="fill">Draw a solid object.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.DrawSmudge(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Blur a rectangle on an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image image = image.DrawSmudge(left, top, width, height);
            </code>
            </example>
            <param name="left">Rect to fill.</param>
            <param name="top">Rect to fill.</param>
            <param name="width">Rect to fill.</param>
            <param name="height">Rect to fill.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Dzsave(System.String,System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.String,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to deepzoom file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Dzsave(filename, basename: string, layout: string, suffix: string, overlap: int, tileSize: int, centre: bool, depth: string, angle: string, container: string, properties: bool, compression: int, regionShrink: string, skipBlanks: int, noStrip: bool, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="basename">Base name to save to.</param>
            <param name="layout">Directory layout.</param>
            <param name="suffix">Filename suffix for tiles.</param>
            <param name="overlap">Tile overlap in pixels.</param>
            <param name="tileSize">Tile size in pixels.</param>
            <param name="centre">Center image in tile.</param>
            <param name="depth">Pyramid depth.</param>
            <param name="angle">Rotate image during save.</param>
            <param name="container">Pyramid container type.</param>
            <param name="properties">Write a properties file to the output directory.</param>
            <param name="compression">ZIP deflate compression level.</param>
            <param name="regionShrink">Method to shrink regions.</param>
            <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
            <param name="noStrip">Don't strip tile metadata.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.DzsaveBuffer(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.String,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to dz buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.DzsaveBuffer(basename: string, layout: string, suffix: string, overlap: int, tileSize: int, centre: bool, depth: string, angle: string, container: string, properties: bool, compression: int, regionShrink: string, skipBlanks: int, noStrip: bool, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="basename">Base name to save to.</param>
            <param name="layout">Directory layout.</param>
            <param name="suffix">Filename suffix for tiles.</param>
            <param name="overlap">Tile overlap in pixels.</param>
            <param name="tileSize">Tile size in pixels.</param>
            <param name="centre">Center image in tile.</param>
            <param name="depth">Pyramid depth.</param>
            <param name="angle">Rotate image during save.</param>
            <param name="container">Pyramid container type.</param>
            <param name="properties">Write a properties file to the output directory.</param>
            <param name="compression">ZIP deflate compression level.</param>
            <param name="regionShrink">Method to shrink regions.</param>
            <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
            <param name="noStrip">Don't strip tile metadata.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.Embed(System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Double[])">
            <summary>
            Embed an image in a larger image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Embed(x, y, width, height, extend: string, background: double[]);
            </code>
            </example>
            <param name="x">Left edge of input in output.</param>
            <param name="y">Top edge of input in output.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="extend">How to generate the extra pixels.</param>
            <param name="background">Color for background pixels.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ExtractArea(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extract an area from an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = input.ExtractArea(left, top, width, height);
            </code>
            </example>
            <param name="left">Left edge of extract area.</param>
            <param name="top">Top edge of extract area.</param>
            <param name="width">Width of extract area.</param>
            <param name="height">Height of extract area.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ExtractBand(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Extract band from an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.ExtractBand(band, n: int);
            </code>
            </example>
            <param name="band">Band to extract.</param>
            <param name="n">Number of bands to extract.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Eye(System.Int32,System.Int32,System.Nullable{System.Boolean},System.Nullable{System.Double})">
            <summary>
            Make an image showing the eye's spatial response.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Eye(width, height, uchar: bool, factor: double);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="factor">Maximum spatial frequency.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Falsecolour">
            <summary>
            False-color an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Falsecolour();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Fastcor(NetVips.Image)">
            <summary>
            Fast correlation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Fastcor(@ref);
            </code>
            </example>
            <param name="ref">Input reference image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FillNearest">
            <summary>
            Fill image zeros with nearest non-zero pixel.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.FillNearest();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FillNearest(NetVips.Image@)">
            <summary>
            Fill image zeros with nearest non-zero pixel.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.FillNearest(out var distance);
            </code>
            </example>
            <param name="distance">Distance to nearest non-zero pixel.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.FindTrim(System.Nullable{System.Double},System.Double[])">
            <summary>
            Search an image for non-edge areas.
            </summary>
            <example>
            <code language="lang-csharp">
            var output = in.FindTrim(threshold: double, background: double[]);
            </code>
            </example>
            <param name="threshold">Object threshold.</param>
            <param name="background">Color for background pixels.</param>
            <returns>An array of objects.</returns>
        </member>
        <member name="M:NetVips.Image.Fitsload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a FITS image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Fitsload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Fitsload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a FITS image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Fitsload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Fitssave(System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to fits file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Fitssave(filename, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Flatten(System.Double[],System.Nullable{System.Double})">
            <summary>
            Flatten alpha out of an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Flatten(background: double[], maxAlpha: double);
            </code>
            </example>
            <param name="background">Background value.</param>
            <param name="maxAlpha">Maximum value of alpha channel.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Flip(System.String)">
            <summary>
            Flip an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Flip(direction);
            </code>
            </example>
            <param name="direction">Direction to flip image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Float2rad">
            <summary>
            Transform float RGB to Radiance coding.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Float2rad();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Fractsurf(System.Int32,System.Int32,System.Double)">
            <summary>
            Make a fractal surface.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Fractsurf(width, height, fractalDimension);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="fractalDimension">Fractal dimension.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Freqmult(NetVips.Image)">
            <summary>
            Frequency-domain filtering.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Freqmult(mask);
            </code>
            </example>
            <param name="mask">Input mask image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Fwfft">
            <summary>
            Forward FFT.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Fwfft();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Gamma(System.Nullable{System.Double})">
            <summary>
            Gamma an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Gamma(exponent: double);
            </code>
            </example>
            <param name="exponent">Gamma factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Gaussblur(System.Double,System.Nullable{System.Double},System.String)">
            <summary>
            Gaussian blur.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Gaussblur(sigma, minAmpl: double, precision: string);
            </code>
            </example>
            <param name="sigma">Sigma of Gaussian.</param>
            <param name="minAmpl">Minimum amplitude of Gaussian.</param>
            <param name="precision">Convolve with this precision.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Gaussmat(System.Double,System.Double,System.Nullable{System.Boolean},System.String)">
            <summary>
            Make a gaussian image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Gaussmat(sigma, minAmpl, separable: bool, precision: string);
            </code>
            </example>
            <param name="sigma">Sigma of Gaussian.</param>
            <param name="minAmpl">Minimum amplitude of Gaussian.</param>
            <param name="separable">Generate separable Gaussian.</param>
            <param name="precision">Generate with this precision.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Gaussnoise(System.Int32,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Make a gaussnoise image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Gaussnoise(width, height, sigma: double, mean: double);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="sigma">Standard deviation of pixels in generated image.</param>
            <param name="mean">Mean of pixels in generated image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Getpoint(System.Int32,System.Int32)">
            <summary>
            Read a point from an image.
            </summary>
            <example>
            <code language="lang-csharp">
            double[] outArray = in.Getpoint(x, y);
            </code>
            </example>
            <param name="x">Point to read.</param>
            <param name="y">Point to read.</param>
            <returns>An array of doubles.</returns>
        </member>
        <member name="M:NetVips.Image.Gifload(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load GIF with giflib.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Gifload(filename, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Gifload(System.String,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load GIF with giflib.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Gifload(filename, out var flags, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.GifloadBuffer(System.Byte[],System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load GIF with giflib.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.GifloadBuffer(buffer, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.GifloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load GIF with giflib.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.GifloadBuffer(buffer, out var flags, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Globalbalance(System.Nullable{System.Double},System.Nullable{System.Boolean})">
            <summary>
            Global balance an image mosaic.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Globalbalance(gamma: double, intOutput: bool);
            </code>
            </example>
            <param name="gamma">Image gamma.</param>
            <param name="intOutput">Integer output.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Gravity(System.String,System.Int32,System.Int32,System.String,System.Double[])">
            <summary>
            Place an image within a larger image with a certain gravity.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Gravity(direction, width, height, extend: string, background: double[]);
            </code>
            </example>
            <param name="direction">direction to place image within width/height.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="extend">How to generate the extra pixels.</param>
            <param name="background">Color for background pixels.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Grey(System.Int32,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Make a grey ramp image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Grey(width, height, uchar: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Grid(System.Int32,System.Int32,System.Int32)">
            <summary>
            Grid an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Grid(tileHeight, across, down);
            </code>
            </example>
            <param name="tileHeight">chop into tiles this high.</param>
            <param name="across">number of tiles across.</param>
            <param name="down">number of tiles down.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Heifload(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a HEIF image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Heifload(filename, page: int, n: int, thumbnail: bool, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="thumbnail">Fetch thumbnail image.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Heifload(System.String,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a HEIF image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Heifload(filename, out var flags, page: int, n: int, thumbnail: bool, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="thumbnail">Fetch thumbnail image.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HeifloadBuffer(System.Byte[],System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a HEIF image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.HeifloadBuffer(buffer, page: int, n: int, thumbnail: bool, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="thumbnail">Fetch thumbnail image.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HeifloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a HEIF image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.HeifloadBuffer(buffer, out var flags, page: int, n: int, thumbnail: bool, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="thumbnail">Fetch thumbnail image.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Heifsave(System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image in HEIF format.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Heifsave(filename, q: int, lossless: bool, compression: string, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="q">Q factor.</param>
            <param name="lossless">Enable lossless compression.</param>
            <param name="compression">Compression format.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.HeifsaveBuffer(System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image in HEIF format.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.HeifsaveBuffer(q: int, lossless: bool, compression: string, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="q">Q factor.</param>
            <param name="lossless">Enable lossless compression.</param>
            <param name="compression">Compression format.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.HistCum">
            <summary>
            Form cumulative histogram.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistCum();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistEntropy">
            <summary>
            Estimate image entropy.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.HistEntropy();
            </code>
            </example>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.HistEqual(System.Nullable{System.Int32})">
            <summary>
            Histogram equalisation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistEqual(band: int);
            </code>
            </example>
            <param name="band">Equalise with this band.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistFind(System.Nullable{System.Int32})">
            <summary>
            Find image histogram.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistFind(band: int);
            </code>
            </example>
            <param name="band">Find histogram of band.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistFindIndexed(NetVips.Image,System.String)">
            <summary>
            Find indexed image histogram.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistFindIndexed(index, combine: string);
            </code>
            </example>
            <param name="index">Index image.</param>
            <param name="combine">Combine bins like this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistFindNdim(System.Nullable{System.Int32})">
            <summary>
            Find n-dimensional image histogram.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistFindNdim(bins: int);
            </code>
            </example>
            <param name="bins">Number of bins in each dimension.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistIsmonotonic">
            <summary>
            Test for monotonicity.
            </summary>
            <example>
            <code language="lang-csharp">
            bool monotonic = in.HistIsmonotonic();
            </code>
            </example>
            <returns>A bool.</returns>
        </member>
        <member name="M:NetVips.Image.HistLocal(System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Local histogram equalisation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistLocal(width, height, maxSlope: int);
            </code>
            </example>
            <param name="width">Window width in pixels.</param>
            <param name="height">Window height in pixels.</param>
            <param name="maxSlope">Maximum slope (CLAHE).</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistMatch(NetVips.Image)">
            <summary>
            Match two histograms.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistMatch(@ref);
            </code>
            </example>
            <param name="ref">Reference histogram.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistNorm">
            <summary>
            Normalise histogram.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistNorm();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HistPlot">
            <summary>
            Plot histogram.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HistPlot();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HoughCircle(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Find hough circle transform.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HoughCircle(scale: int, minRadius: int, maxRadius: int);
            </code>
            </example>
            <param name="scale">Scale down dimensions by this factor.</param>
            <param name="minRadius">Smallest radius to search for.</param>
            <param name="maxRadius">Largest radius to search for.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HoughLine(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Find hough line transform.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HoughLine(width: int, height: int);
            </code>
            </example>
            <param name="width">horizontal size of parameter space.</param>
            <param name="height">Vertical size of parameter space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.HSV2sRGB">
            <summary>
            Transform HSV to sRGB.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.HSV2sRGB();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.IccExport(System.String,System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Output to device with ICC profile.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.IccExport(pcs: string, intent: string, outputProfile: string, depth: int);
            </code>
            </example>
            <param name="pcs">Set Profile Connection Space.</param>
            <param name="intent">Rendering intent.</param>
            <param name="outputProfile">Filename to load output profile from.</param>
            <param name="depth">Output device space depth in bits.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.IccImport(System.String,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
            Import from device with ICC profile.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.IccImport(pcs: string, intent: string, embedded: bool, inputProfile: string);
            </code>
            </example>
            <param name="pcs">Set Profile Connection Space.</param>
            <param name="intent">Rendering intent.</param>
            <param name="embedded">Use embedded input profile, if available.</param>
            <param name="inputProfile">Filename to load input profile from.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.IccTransform(System.String,System.String,System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32})">
            <summary>
            Transform between devices with ICC profiles.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.IccTransform(outputProfile, pcs: string, intent: string, embedded: bool, inputProfile: string, depth: int);
            </code>
            </example>
            <param name="outputProfile">Filename to load output profile from.</param>
            <param name="pcs">Set Profile Connection Space.</param>
            <param name="intent">Rendering intent.</param>
            <param name="embedded">Use embedded input profile, if available.</param>
            <param name="inputProfile">Filename to load input profile from.</param>
            <param name="depth">Output device space depth in bits.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Identity(System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32})">
            <summary>
            Make a 1D image where pixel values are indexes.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Identity(bands: int, @ushort: bool, size: int);
            </code>
            </example>
            <param name="bands">Number of bands in LUT.</param>
            <param name="ushort">Create a 16-bit LUT.</param>
            <param name="size">Size of 16-bit LUT.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Insert(NetVips.Image,System.Int32,System.Int32,System.Nullable{System.Boolean},System.Double[])">
            <summary>
            Insert image @sub into @main at @x, @y.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = main.Insert(sub, x, y, expand: bool, background: double[]);
            </code>
            </example>
            <param name="sub">Sub-image to insert into main image.</param>
            <param name="x">Left edge of sub in main.</param>
            <param name="y">Top edge of sub in main.</param>
            <param name="expand">Expand output to hold all of both inputs.</param>
            <param name="background">Color for new pixels.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Invert">
            <summary>
            Invert an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Invert();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Invertlut(System.Nullable{System.Int32})">
            <summary>
            Build an inverted look-up table.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Invertlut(size: int);
            </code>
            </example>
            <param name="size">LUT size to generate.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Invfft(System.Nullable{System.Boolean})">
            <summary>
            Inverse FFT.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Invfft(real: bool);
            </code>
            </example>
            <param name="real">Output only the real part of the transform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Join(NetVips.Image,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Double[],System.String)">
            <summary>
            Join a pair of images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in1.Join(in2, direction, expand: bool, shim: int, background: double[], align: string);
            </code>
            </example>
            <param name="in2">Second input image.</param>
            <param name="direction">Join left-right or up-down.</param>
            <param name="expand">Expand output to hold all of both inputs.</param>
            <param name="shim">Pixels between images.</param>
            <param name="background">Colour for new pixels.</param>
            <param name="align">Align on the low, centre or high coordinate edge.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Jpegload(System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load jpeg from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Jpegload(filename, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Jpegload(System.String,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load jpeg from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Jpegload(filename, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.JpegloadBuffer(System.Byte[],System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load jpeg from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.JpegloadBuffer(buffer, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.JpegloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load jpeg from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.JpegloadBuffer(buffer, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.JpegloadSource(NetVips.Source,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load image from jpeg source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.JpegloadSource(source, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.JpegloadStream(System.IO.Stream,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load image from jpeg stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.JpegloadStream(stream, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.JpegloadSource(NetVips.Source,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load image from jpeg source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.JpegloadSource(source, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.JpegloadStream(System.IO.Stream,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load image from jpeg stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.JpegloadStream(stream, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="shrink">Shrink factor on load.</param>
            <param name="autorotate">Rotate image using exif orientation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Jpegsave(System.String,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to jpeg file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Jpegsave(filename, q: int, profile: string, optimizeCoding: bool, interlace: bool, noSubsample: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="q">Q factor.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
            <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
            <param name="noSubsample">Disable chroma subsample.</param>
            <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
            <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
            <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
            <param name="quantTable">Use predefined quantization table with given index.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.JpegsaveBuffer(System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to jpeg buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.JpegsaveBuffer(q: int, profile: string, optimizeCoding: bool, interlace: bool, noSubsample: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="q">Q factor.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
            <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
            <param name="noSubsample">Disable chroma subsample.</param>
            <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
            <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
            <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
            <param name="quantTable">Use predefined quantization table with given index.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.JpegsaveMime(System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to jpeg mime.
            </summary>
            <example>
            <code language="lang-csharp">
            in.JpegsaveMime(q: int, profile: string, optimizeCoding: bool, interlace: bool, noSubsample: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="q">Q factor.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
            <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
            <param name="noSubsample">Disable chroma subsample.</param>
            <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
            <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
            <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
            <param name="quantTable">Use predefined quantization table with given index.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.JpegsaveTarget(NetVips.Target,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to jpeg target.
            </summary>
            <example>
            <code language="lang-csharp">
            in.JpegsaveTarget(target, q: int, profile: string, optimizeCoding: bool, interlace: bool, noSubsample: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="target">Target to save to.</param>
            <param name="q">Q factor.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
            <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
            <param name="noSubsample">Disable chroma subsample.</param>
            <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
            <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
            <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
            <param name="quantTable">Use predefined quantization table with given index.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.JpegsaveStream(System.IO.Stream,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to jpeg stream.
            </summary>
            <example>
            <code language="lang-csharp">
            in.JpegsaveStream(stream, q: int, profile: string, optimizeCoding: bool, interlace: bool, noSubsample: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="stream">Stream to save to.</param>
            <param name="q">Q factor.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
            <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
            <param name="noSubsample">Disable chroma subsample.</param>
            <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
            <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
            <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
            <param name="quantTable">Use predefined quantization table with given index.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Lab2LabQ">
            <summary>
            Transform float Lab to LabQ coding.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Lab2LabQ();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Lab2LabS">
            <summary>
            Transform float Lab to signed short.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Lab2LabS();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Lab2LCh">
            <summary>
            Transform Lab to LCh.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Lab2LCh();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Lab2XYZ(System.Double[])">
            <summary>
            Transform CIELAB to XYZ.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Lab2XYZ(temp: double[]);
            </code>
            </example>
            <param name="temp">Color temperature.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Labelregions">
            <summary>
            Label regions in an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image mask = in.Labelregions();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Labelregions(System.Int32@)">
            <summary>
            Label regions in an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image mask = in.Labelregions(out var segments);
            </code>
            </example>
            <param name="segments">Number of discrete contigious regions.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.LabQ2Lab">
            <summary>
            Unpack a LabQ image to float Lab.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.LabQ2Lab();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.LabQ2LabS">
            <summary>
            Unpack a LabQ image to short Lab.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.LabQ2LabS();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.LabQ2sRGB">
            <summary>
            Convert a LabQ image to sRGB.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.LabQ2sRGB();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.LabS2Lab">
            <summary>
            Transform signed short Lab to float.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.LabS2Lab();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.LabS2LabQ">
            <summary>
            Transform short Lab to LabQ coding.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.LabS2LabQ();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.LCh2CMC">
            <summary>
            Transform LCh to CMC.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.LCh2CMC();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.LCh2Lab">
            <summary>
            Transform LCh to Lab.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.LCh2Lab();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Linear(System.Double[],System.Double[],System.Nullable{System.Boolean})">
            <summary>
            Calculate (a * in + b).
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Linear(a, b, uchar: bool);
            </code>
            </example>
            <param name="a">Multiply by this.</param>
            <param name="b">Add this.</param>
            <param name="uchar">Output should be uchar.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Linecache(System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Cache an image as a set of lines.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Linecache(tileHeight: int, access: string, threaded: bool, persistent: bool);
            </code>
            </example>
            <param name="tileHeight">Tile height in pixels.</param>
            <param name="access">Expected access pattern.</param>
            <param name="threaded">Allow threaded access.</param>
            <param name="persistent">Keep cache between evaluations.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Logmat(System.Double,System.Double,System.Nullable{System.Boolean},System.String)">
            <summary>
            Make a laplacian of gaussian image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Logmat(sigma, minAmpl, separable: bool, precision: string);
            </code>
            </example>
            <param name="sigma">Radius of Logmatian.</param>
            <param name="minAmpl">Minimum amplitude of Logmatian.</param>
            <param name="separable">Generate separable Logmatian.</param>
            <param name="precision">Generate with this precision.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Magickload(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load file with ImageMagick.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Magickload(filename, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Magickload(System.String,System.Int32@,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load file with ImageMagick.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Magickload(filename, out var flags, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MagickloadBuffer(System.Byte[],System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load buffer with ImageMagick.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MagickloadBuffer(buffer, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MagickloadBuffer(System.Byte[],System.Int32@,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load buffer with ImageMagick.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MagickloadBuffer(buffer, out var flags, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Magicksave(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save file with ImageMagick.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Magicksave(filename, format: string, quality: int, optimizeGifFrames: bool, optimizeGifTransparency: bool, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="format">Format to save in.</param>
            <param name="quality">Quality to use.</param>
            <param name="optimizeGifFrames">Apply GIF frames optimization.</param>
            <param name="optimizeGifTransparency">Apply GIF transparency optimization.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.MagicksaveBuffer(System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to magick buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.MagicksaveBuffer(format: string, quality: int, optimizeGifFrames: bool, optimizeGifTransparency: bool, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="format">Format to save in.</param>
            <param name="quality">Quality to use.</param>
            <param name="optimizeGifFrames">Apply GIF frames optimization.</param>
            <param name="optimizeGifTransparency">Apply GIF transparency optimization.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.Mapim(NetVips.Image,NetVips.GObject)">
            <summary>
            Resample with a map image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Mapim(index, interpolate: GObject);
            </code>
            </example>
            <param name="index">Index pixels with this.</param>
            <param name="interpolate">Interpolate pixels with this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Maplut(NetVips.Image,System.Nullable{System.Int32})">
            <summary>
            Map an image though a lut.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Maplut(lut, band: int);
            </code>
            </example>
            <param name="lut">Look-up table image.</param>
            <param name="band">apply one-band lut to this band of in.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskButterworth(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make a butterworth filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskButterworth(width, height, order, frequencyCutoff, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="order">Filter order.</param>
            <param name="frequencyCutoff">Frequency cutoff.</param>
            <param name="amplitudeCutoff">Amplitude cutoff.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskButterworthBand(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make a butterworth_band filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskButterworthBand(width, height, order, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="order">Filter order.</param>
            <param name="frequencyCutoffX">Frequency cutoff x.</param>
            <param name="frequencyCutoffY">Frequency cutoff y.</param>
            <param name="radius">radius of circle.</param>
            <param name="amplitudeCutoff">Amplitude cutoff.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskButterworthRing(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make a butterworth ring filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskButterworthRing(width, height, order, frequencyCutoff, amplitudeCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="order">Filter order.</param>
            <param name="frequencyCutoff">Frequency cutoff.</param>
            <param name="amplitudeCutoff">Amplitude cutoff.</param>
            <param name="ringwidth">Ringwidth.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskFractal(System.Int32,System.Int32,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make fractal filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskFractal(width, height, fractalDimension, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="fractalDimension">Fractal dimension.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskGaussian(System.Int32,System.Int32,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make a gaussian filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskGaussian(width, height, frequencyCutoff, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="frequencyCutoff">Frequency cutoff.</param>
            <param name="amplitudeCutoff">Amplitude cutoff.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskGaussianBand(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make a gaussian filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskGaussianBand(width, height, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="frequencyCutoffX">Frequency cutoff x.</param>
            <param name="frequencyCutoffY">Frequency cutoff y.</param>
            <param name="radius">radius of circle.</param>
            <param name="amplitudeCutoff">Amplitude cutoff.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskGaussianRing(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make a gaussian ring filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskGaussianRing(width, height, frequencyCutoff, amplitudeCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="frequencyCutoff">Frequency cutoff.</param>
            <param name="amplitudeCutoff">Amplitude cutoff.</param>
            <param name="ringwidth">Ringwidth.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskIdeal(System.Int32,System.Int32,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make an ideal filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskIdeal(width, height, frequencyCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="frequencyCutoff">Frequency cutoff.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskIdealBand(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make an ideal band filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskIdealBand(width, height, frequencyCutoffX, frequencyCutoffY, radius, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="frequencyCutoffX">Frequency cutoff x.</param>
            <param name="frequencyCutoffY">Frequency cutoff y.</param>
            <param name="radius">radius of circle.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.MaskIdealRing(System.Int32,System.Int32,System.Double,System.Double,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Make an ideal ring filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.MaskIdealRing(width, height, frequencyCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="frequencyCutoff">Frequency cutoff.</param>
            <param name="ringwidth">Ringwidth.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="nodc">Remove DC component.</param>
            <param name="reject">Invert the sense of the filter.</param>
            <param name="optical">Rotate quadrants to optical space.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Match(NetVips.Image,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},NetVips.GObject)">
            <summary>
            First-order match of two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Match(sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, hwindow: int, harea: int, search: bool, interpolate: GObject);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="xr1">Position of first reference tie-point.</param>
            <param name="yr1">Position of first reference tie-point.</param>
            <param name="xs1">Position of first secondary tie-point.</param>
            <param name="ys1">Position of first secondary tie-point.</param>
            <param name="xr2">Position of second reference tie-point.</param>
            <param name="yr2">Position of second reference tie-point.</param>
            <param name="xs2">Position of second secondary tie-point.</param>
            <param name="ys2">Position of second secondary tie-point.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="search">Search to improve tie-points.</param>
            <param name="interpolate">Interpolate pixels with this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Math(System.String)">
            <summary>
            Apply a math operation to an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Math(math);
            </code>
            </example>
            <param name="math">math to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Math2(NetVips.Image,System.String)">
            <summary>
            Binary math operations.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Math2(right, math2);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <param name="math2">math to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Math2Const(System.String,System.Double[])">
            <summary>
            Binary math operations with a constant.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Math2Const(math2, c);
            </code>
            </example>
            <param name="math2">math to perform.</param>
            <param name="c">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Matload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load mat from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Matload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Matload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load mat from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Matload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Matrixload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load matrix from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Matrixload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Matrixload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load matrix from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Matrixload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Matrixprint(System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Print matrix.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Matrixprint(strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Matrixsave(System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to matrix file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Matrixsave(filename, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Max(System.Nullable{System.Int32})">
            <summary>
            Find image maximum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Max(size: int);
            </code>
            </example>
            <param name="size">Number of maximum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Max(System.Int32@,System.Nullable{System.Int32})">
            <summary>
            Find image maximum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Max(out var x, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of maximum.</param>
            <param name="size">Number of maximum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Max(System.Int32@,System.Int32@,System.Nullable{System.Int32})">
            <summary>
            Find image maximum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Max(out var x, out var y, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of maximum.</param>
            <param name="y">Vertical position of maximum.</param>
            <param name="size">Number of maximum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Max(System.Int32@,System.Int32@,System.Double[]@,System.Nullable{System.Int32})">
            <summary>
            Find image maximum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Max(out var x, out var y, out var outArray, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of maximum.</param>
            <param name="y">Vertical position of maximum.</param>
            <param name="outArray">Array of output values.</param>
            <param name="size">Number of maximum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Max(System.Int32@,System.Int32@,System.Double[]@,System.Int32[]@,System.Nullable{System.Int32})">
            <summary>
            Find image maximum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Max(out var x, out var y, out var outArray, out var xArray, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of maximum.</param>
            <param name="y">Vertical position of maximum.</param>
            <param name="outArray">Array of output values.</param>
            <param name="xArray">Array of horizontal positions.</param>
            <param name="size">Number of maximum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Max(System.Int32@,System.Int32@,System.Double[]@,System.Int32[]@,System.Int32[]@,System.Nullable{System.Int32})">
            <summary>
            Find image maximum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Max(out var x, out var y, out var outArray, out var xArray, out var yArray, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of maximum.</param>
            <param name="y">Vertical position of maximum.</param>
            <param name="outArray">Array of output values.</param>
            <param name="xArray">Array of horizontal positions.</param>
            <param name="yArray">Array of vertical positions.</param>
            <param name="size">Number of maximum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Measure(System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Measure a set of patches on a color chart.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Measure(h, v, left: int, top: int, width: int, height: int);
            </code>
            </example>
            <param name="h">Number of patches across chart.</param>
            <param name="v">Number of patches down chart.</param>
            <param name="left">Left edge of extract area.</param>
            <param name="top">Top edge of extract area.</param>
            <param name="width">Width of extract area.</param>
            <param name="height">Height of extract area.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Merge(NetVips.Image,System.String,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Merge two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Merge(sec, direction, dx, dy, mblend: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial merge.</param>
            <param name="dx">Horizontal displacement from sec to ref.</param>
            <param name="dy">Vertical displacement from sec to ref.</param>
            <param name="mblend">Maximum blend size.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Min(System.Nullable{System.Int32})">
            <summary>
            Find image minimum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Min(size: int);
            </code>
            </example>
            <param name="size">Number of minimum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Min(System.Int32@,System.Nullable{System.Int32})">
            <summary>
            Find image minimum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Min(out var x, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of minimum.</param>
            <param name="size">Number of minimum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Min(System.Int32@,System.Int32@,System.Nullable{System.Int32})">
            <summary>
            Find image minimum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Min(out var x, out var y, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of minimum.</param>
            <param name="y">Vertical position of minimum.</param>
            <param name="size">Number of minimum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Min(System.Int32@,System.Int32@,System.Double[]@,System.Nullable{System.Int32})">
            <summary>
            Find image minimum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Min(out var x, out var y, out var outArray, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of minimum.</param>
            <param name="y">Vertical position of minimum.</param>
            <param name="outArray">Array of output values.</param>
            <param name="size">Number of minimum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Min(System.Int32@,System.Int32@,System.Double[]@,System.Int32[]@,System.Nullable{System.Int32})">
            <summary>
            Find image minimum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Min(out var x, out var y, out var outArray, out var xArray, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of minimum.</param>
            <param name="y">Vertical position of minimum.</param>
            <param name="outArray">Array of output values.</param>
            <param name="xArray">Array of horizontal positions.</param>
            <param name="size">Number of minimum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Min(System.Int32@,System.Int32@,System.Double[]@,System.Int32[]@,System.Int32[]@,System.Nullable{System.Int32})">
            <summary>
            Find image minimum.
            </summary>
            <example>
            <code language="lang-csharp">
            double @out = in.Min(out var x, out var y, out var outArray, out var xArray, out var yArray, size: int);
            </code>
            </example>
            <param name="x">Horizontal position of minimum.</param>
            <param name="y">Vertical position of minimum.</param>
            <param name="outArray">Array of output values.</param>
            <param name="xArray">Array of horizontal positions.</param>
            <param name="yArray">Array of vertical positions.</param>
            <param name="size">Number of minimum values to find.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:NetVips.Image.Morph(NetVips.Image,System.String)">
            <summary>
            Morphology operation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Morph(mask, morph);
            </code>
            </example>
            <param name="mask">Input matrix image.</param>
            <param name="morph">Morphological operation to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Mosaic two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, hwindow: int, harea: int, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xref">Position of reference tie-point.</param>
            <param name="yref">Position of reference tie-point.</param>
            <param name="xsec">Position of secondary tie-point.</param>
            <param name="ysec">Position of secondary tie-point.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Mosaic two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, hwindow: int, harea: int, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xref">Position of reference tie-point.</param>
            <param name="yref">Position of reference tie-point.</param>
            <param name="xsec">Position of secondary tie-point.</param>
            <param name="ysec">Position of secondary tie-point.</param>
            <param name="dx0">Detected integer offset.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Mosaic two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, hwindow: int, harea: int, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xref">Position of reference tie-point.</param>
            <param name="yref">Position of reference tie-point.</param>
            <param name="xsec">Position of secondary tie-point.</param>
            <param name="ysec">Position of secondary tie-point.</param>
            <param name="dx0">Detected integer offset.</param>
            <param name="dy0">Detected integer offset.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Mosaic two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, hwindow: int, harea: int, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xref">Position of reference tie-point.</param>
            <param name="yref">Position of reference tie-point.</param>
            <param name="xsec">Position of secondary tie-point.</param>
            <param name="ysec">Position of secondary tie-point.</param>
            <param name="dx0">Detected integer offset.</param>
            <param name="dy0">Detected integer offset.</param>
            <param name="scale1">Detected scale.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Mosaic two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, hwindow: int, harea: int, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xref">Position of reference tie-point.</param>
            <param name="yref">Position of reference tie-point.</param>
            <param name="xsec">Position of secondary tie-point.</param>
            <param name="ysec">Position of secondary tie-point.</param>
            <param name="dx0">Detected integer offset.</param>
            <param name="dy0">Detected integer offset.</param>
            <param name="scale1">Detected scale.</param>
            <param name="angle1">Detected rotation.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Mosaic two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, out var dy1, hwindow: int, harea: int, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xref">Position of reference tie-point.</param>
            <param name="yref">Position of reference tie-point.</param>
            <param name="xsec">Position of secondary tie-point.</param>
            <param name="ysec">Position of secondary tie-point.</param>
            <param name="dx0">Detected integer offset.</param>
            <param name="dy0">Detected integer offset.</param>
            <param name="scale1">Detected scale.</param>
            <param name="angle1">Detected rotation.</param>
            <param name="dy1">Detected first-order displacement.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Mosaic two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, out var dy1, out var dx1, hwindow: int, harea: int, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xref">Position of reference tie-point.</param>
            <param name="yref">Position of reference tie-point.</param>
            <param name="xsec">Position of secondary tie-point.</param>
            <param name="ysec">Position of secondary tie-point.</param>
            <param name="dx0">Detected integer offset.</param>
            <param name="dy0">Detected integer offset.</param>
            <param name="scale1">Detected scale.</param>
            <param name="angle1">Detected rotation.</param>
            <param name="dy1">Detected first-order displacement.</param>
            <param name="dx1">Detected first-order displacement.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Mosaic1(NetVips.Image,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},NetVips.GObject,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            First-order mosaic of two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = ref.Mosaic1(sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, hwindow: int, harea: int, search: bool, interpolate: GObject, mblend: int, bandno: int);
            </code>
            </example>
            <param name="sec">Secondary image.</param>
            <param name="direction">Horizontal or vertcial mosaic.</param>
            <param name="xr1">Position of first reference tie-point.</param>
            <param name="yr1">Position of first reference tie-point.</param>
            <param name="xs1">Position of first secondary tie-point.</param>
            <param name="ys1">Position of first secondary tie-point.</param>
            <param name="xr2">Position of second reference tie-point.</param>
            <param name="yr2">Position of second reference tie-point.</param>
            <param name="xs2">Position of second secondary tie-point.</param>
            <param name="ys2">Position of second secondary tie-point.</param>
            <param name="hwindow">Half window size.</param>
            <param name="harea">Half area size.</param>
            <param name="search">Search to improve tie-points.</param>
            <param name="interpolate">Interpolate pixels with this.</param>
            <param name="mblend">Maximum blend size.</param>
            <param name="bandno">Band to search for features on.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Msb(System.Nullable{System.Int32})">
            <summary>
            Pick most-significant byte from an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Msb(band: int);
            </code>
            </example>
            <param name="band">Band to msb.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Multiply(NetVips.Image)">
            <summary>
            Multiply two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Multiply(right);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Niftiload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a NIFTI image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Niftiload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Niftiload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a NIFTI image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Niftiload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Niftisave(System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to nifti file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Niftisave(filename, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Openexrload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load an OpenEXR image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Openexrload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Openexrload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load an OpenEXR image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Openexrload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Openslideload(System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load file with OpenSlide.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Openslideload(filename, attachAssociated: bool, level: int, autocrop: bool, associated: string, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="attachAssociated">Attach all asssociated images.</param>
            <param name="level">Load this level from the file.</param>
            <param name="autocrop">Crop to image bounds.</param>
            <param name="associated">Load this associated image.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Openslideload(System.String,System.Int32@,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load file with OpenSlide.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Openslideload(filename, out var flags, attachAssociated: bool, level: int, autocrop: bool, associated: string, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="attachAssociated">Attach all asssociated images.</param>
            <param name="level">Load this level from the file.</param>
            <param name="autocrop">Crop to image bounds.</param>
            <param name="associated">Load this associated image.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pdfload(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load PDF with libpoppler.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Pdfload(filename, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="background">Background value.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pdfload(System.String,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load PDF with libpoppler.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Pdfload(filename, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="background">Background value.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PdfloadBuffer(System.Byte[],System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load PDF with libpoppler.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PdfloadBuffer(buffer, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="background">Background value.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PdfloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load PDF with libpoppler.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PdfloadBuffer(buffer, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="background">Background value.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Percent(System.Double)">
            <summary>
            Find threshold for percent of pixels.
            </summary>
            <example>
            <code language="lang-csharp">
            int threshold = in.Percent(percent);
            </code>
            </example>
            <param name="percent">Percent of pixels.</param>
            <returns>A int.</returns>
        </member>
        <member name="M:NetVips.Image.Perlin(System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <summary>
            Make a perlin noise image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Perlin(width, height, cellSize: int, uchar: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="cellSize">Size of Perlin cells.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Phasecor(NetVips.Image)">
            <summary>
            Calculate phase correlation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Phasecor(in2);
            </code>
            </example>
            <param name="in2">Second input image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pngload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Pngload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pngload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Pngload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PngloadBuffer(System.Byte[],System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PngloadBuffer(buffer, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PngloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PngloadBuffer(buffer, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PngloadSource(NetVips.Source,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PngloadSource(source, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PngloadStream(System.IO.Stream,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PngloadStream(stream, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PngloadSource(NetVips.Source,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PngloadSource(source, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.PngloadStream(System.IO.Stream,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load png from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.PngloadStream(stream, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Pngsave(System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to png file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Pngsave(filename, compression: int, interlace: bool, profile: string, filter: int, palette: bool, colours: int, q: int, dither: double, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="compression">Compression factor.</param>
            <param name="interlace">Interlace image.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="filter">libpng row filter flag(s).</param>
            <param name="palette">Quantise to 8bpp palette.</param>
            <param name="colours">Max number of palette colours.</param>
            <param name="q">Quantisation quality.</param>
            <param name="dither">Amount of dithering.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.PngsaveBuffer(System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to png buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.PngsaveBuffer(compression: int, interlace: bool, profile: string, filter: int, palette: bool, colours: int, q: int, dither: double, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="compression">Compression factor.</param>
            <param name="interlace">Interlace image.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="filter">libpng row filter flag(s).</param>
            <param name="palette">Quantise to 8bpp palette.</param>
            <param name="colours">Max number of palette colours.</param>
            <param name="q">Quantisation quality.</param>
            <param name="dither">Amount of dithering.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.PngsaveTarget(NetVips.Target,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to target as PNG.
            </summary>
            <example>
            <code language="lang-csharp">
            in.PngsaveTarget(target, compression: int, interlace: bool, profile: string, filter: int, palette: bool, colours: int, q: int, dither: double, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="target">Target to save to.</param>
            <param name="compression">Compression factor.</param>
            <param name="interlace">Interlace image.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="filter">libpng row filter flag(s).</param>
            <param name="palette">Quantise to 8bpp palette.</param>
            <param name="colours">Max number of palette colours.</param>
            <param name="q">Quantisation quality.</param>
            <param name="dither">Amount of dithering.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.PngsaveStream(System.IO.Stream,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to stream as PNG.
            </summary>
            <example>
            <code language="lang-csharp">
            in.PngsaveStream(stream, compression: int, interlace: bool, profile: string, filter: int, palette: bool, colours: int, q: int, dither: double, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="stream">Stream to save to.</param>
            <param name="compression">Compression factor.</param>
            <param name="interlace">Interlace image.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="filter">libpng row filter flag(s).</param>
            <param name="palette">Quantise to 8bpp palette.</param>
            <param name="colours">Max number of palette colours.</param>
            <param name="q">Quantisation quality.</param>
            <param name="dither">Amount of dithering.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Ppmload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load ppm from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Ppmload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Ppmload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load ppm from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Ppmload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Ppmsave(System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to ppm file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Ppmsave(filename, ascii: bool, squash: bool, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="ascii">save as ascii.</param>
            <param name="squash">save as one bit.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Premultiply(System.Nullable{System.Double})">
            <summary>
            Premultiply image alpha.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Premultiply(maxAlpha: double);
            </code>
            </example>
            <param name="maxAlpha">Maximum value of alpha channel.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Profile">
            <summary>
            Find image profiles.
            </summary>
            <example>
            <code language="lang-csharp">
            var output = in.Profile();
            </code>
            </example>
            <returns>An array of objects.</returns>
        </member>
        <member name="M:NetVips.Image.ProfileLoad(System.String)">
            <summary>
            Load named ICC profile.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] profile = NetVips.Image.ProfileLoad(name);
            </code>
            </example>
            <param name="name">Profile name.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.Project">
            <summary>
            Find image projections.
            </summary>
            <example>
            <code language="lang-csharp">
            var output = in.Project();
            </code>
            </example>
            <returns>An array of objects.</returns>
        </member>
        <member name="M:NetVips.Image.Quadratic(NetVips.Image,NetVips.GObject)">
            <summary>
            Resample an image with a quadratic transform.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Quadratic(coeff, interpolate: GObject);
            </code>
            </example>
            <param name="coeff">Coefficient matrix.</param>
            <param name="interpolate">Interpolate values with this.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rad2float">
            <summary>
            Unpack Radiance coding to float RGB.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Rad2float();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Radload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a Radiance image from a file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Radload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Radload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load a Radiance image from a file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Radload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RadloadBuffer(System.Byte[],System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load rad from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.RadloadBuffer(buffer, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RadloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load rad from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.RadloadBuffer(buffer, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RadloadSource(NetVips.Source,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load rad from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.RadloadSource(source, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RadloadStream(System.IO.Stream,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load rad from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.RadloadStream(stream, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RadloadSource(NetVips.Source,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load rad from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.RadloadSource(source, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RadloadStream(System.IO.Stream,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load rad from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.RadloadStream(stream, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Radsave(System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to Radiance file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Radsave(filename, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.RadsaveBuffer(System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to Radiance buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.RadsaveBuffer(strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.RadsaveTarget(NetVips.Target,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to Radiance target.
            </summary>
            <example>
            <code language="lang-csharp">
            in.RadsaveTarget(target, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="target">Target to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.RadsaveStream(System.IO.Stream,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to Radiance stream.
            </summary>
            <example>
            <code language="lang-csharp">
            in.RadsaveStream(stream, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="stream">Stream to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Rank(System.Int32,System.Int32,System.Int32)">
            <summary>
            Rank filter.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Rank(width, height, index);
            </code>
            </example>
            <param name="width">Window width in pixels.</param>
            <param name="height">Window height in pixels.</param>
            <param name="index">Select pixel at index.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rawload(System.String,System.Int32,System.Int32,System.Int32,System.Nullable{System.UInt64},System.String,System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load raw data from a file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Rawload(filename, width, height, bands, offset: ulong, format: string, interpretation: string, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="bands">Number of bands in image.</param>
            <param name="offset">Offset in bytes from start of file.</param>
            <param name="format">Pixel format in image.</param>
            <param name="interpretation">Pixel interpretation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rawload(System.String,System.Int32,System.Int32,System.Int32,System.Int32@,System.Nullable{System.UInt64},System.String,System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load raw data from a file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Rawload(filename, width, height, bands, out var flags, offset: ulong, format: string, interpretation: string, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="bands">Number of bands in image.</param>
            <param name="flags">Flags for this file.</param>
            <param name="offset">Offset in bytes from start of file.</param>
            <param name="format">Pixel format in image.</param>
            <param name="interpretation">Pixel interpretation.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rawsave(System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to raw file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Rawsave(filename, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.RawsaveFd(System.Int32,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Write raw image to file descriptor.
            </summary>
            <example>
            <code language="lang-csharp">
            in.RawsaveFd(fd, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="fd">File descriptor to write to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Recomb(NetVips.Image)">
            <summary>
            Linear recombination with matrix.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Recomb(m);
            </code>
            </example>
            <param name="m">matrix of coefficients.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Reduce(System.Double,System.Double,System.String,System.Nullable{System.Boolean})">
            <summary>
            Reduce an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Reduce(hshrink, vshrink, kernel: string, centre: bool);
            </code>
            </example>
            <param name="hshrink">Horizontal shrink factor.</param>
            <param name="vshrink">Vertical shrink factor.</param>
            <param name="kernel">Resampling kernel.</param>
            <param name="centre">Use centre sampling convention.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Reduceh(System.Double,System.String,System.Nullable{System.Boolean})">
            <summary>
            Shrink an image horizontally.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Reduceh(hshrink, kernel: string, centre: bool);
            </code>
            </example>
            <param name="hshrink">Horizontal shrink factor.</param>
            <param name="kernel">Resampling kernel.</param>
            <param name="centre">Use centre sampling convention.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Reducev(System.Double,System.String,System.Nullable{System.Boolean})">
            <summary>
            Shrink an image vertically.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Reducev(vshrink, kernel: string, centre: bool);
            </code>
            </example>
            <param name="vshrink">Vertical shrink factor.</param>
            <param name="kernel">Resampling kernel.</param>
            <param name="centre">Use centre sampling convention.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Relational(NetVips.Image,System.String)">
            <summary>
            Relational operation on two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Relational(right, relational);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <param name="relational">relational to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RelationalConst(System.String,System.Double[])">
            <summary>
            Relational operations against a constant.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.RelationalConst(relational, c);
            </code>
            </example>
            <param name="relational">relational to perform.</param>
            <param name="c">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Remainder(NetVips.Image)">
            <summary>
            Remainder after integer division of two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Remainder(right);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.RemainderConst(System.Double[])">
            <summary>
            Remainder after integer division of an image and a constant.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.RemainderConst(c);
            </code>
            </example>
            <param name="c">Array of constants.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Replicate(System.Int32,System.Int32)">
            <summary>
            Replicate an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Replicate(across, down);
            </code>
            </example>
            <param name="across">Repeat this many times horizontally.</param>
            <param name="down">Repeat this many times vertically.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Resize(System.Double,System.String,System.Nullable{System.Double})">
            <summary>
            Resize an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Resize(scale, kernel: string, vscale: double);
            </code>
            </example>
            <param name="scale">Scale image by this factor.</param>
            <param name="kernel">Resampling kernel.</param>
            <param name="vscale">Vertical scale image by this factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rot(System.String)">
            <summary>
            Rotate an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Rot(angle);
            </code>
            </example>
            <param name="angle">Angle to rotate image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rot45(System.String)">
            <summary>
            Rotate an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Rot45(angle: string);
            </code>
            </example>
            <param name="angle">Angle to rotate image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Rotate(System.Double,NetVips.GObject,System.Double[],System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Rotate an image by a number of degrees.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Rotate(angle, interpolate: GObject, background: double[], odx: double, ody: double, idx: double, idy: double);
            </code>
            </example>
            <param name="angle">Rotate anticlockwise by this many degrees.</param>
            <param name="interpolate">Interpolate pixels with this.</param>
            <param name="background">Background value.</param>
            <param name="odx">Horizontal output displacement.</param>
            <param name="ody">Vertical output displacement.</param>
            <param name="idx">Horizontal input displacement.</param>
            <param name="idy">Vertical input displacement.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Round(System.String)">
            <summary>
            Perform a round function on an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Round(round);
            </code>
            </example>
            <param name="round">rounding operation to perform.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ScRGB2BW(System.Nullable{System.Int32})">
            <summary>
            Convert scRGB to BW.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.ScRGB2BW(depth: int);
            </code>
            </example>
            <param name="depth">Output device space depth in bits.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ScRGB2sRGB(System.Nullable{System.Int32})">
            <summary>
            Convert an scRGB image to sRGB.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.ScRGB2sRGB(depth: int);
            </code>
            </example>
            <param name="depth">Output device space depth in bits.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ScRGB2XYZ">
            <summary>
            Transform scRGB to XYZ.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.ScRGB2XYZ();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Sequential(System.Nullable{System.Int32})">
            <summary>
            Check sequential access.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Sequential(tileHeight: int);
            </code>
            </example>
            <param name="tileHeight">Tile height in pixels.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Sharpen(System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Unsharp masking for print.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Sharpen(sigma: double, x1: double, y2: double, y3: double, m1: double, m2: double);
            </code>
            </example>
            <param name="sigma">Sigma of Gaussian.</param>
            <param name="x1">Flat/jaggy threshold.</param>
            <param name="y2">Maximum brightening.</param>
            <param name="y3">Maximum darkening.</param>
            <param name="m1">Slope for flat areas.</param>
            <param name="m2">Slope for jaggy areas.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Shrink(System.Double,System.Double)">
            <summary>
            Shrink an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Shrink(hshrink, vshrink);
            </code>
            </example>
            <param name="hshrink">Horizontal shrink factor.</param>
            <param name="vshrink">Vertical shrink factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Shrinkh(System.Int32)">
            <summary>
            Shrink an image horizontally.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Shrinkh(hshrink);
            </code>
            </example>
            <param name="hshrink">Horizontal shrink factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Shrinkv(System.Int32)">
            <summary>
            Shrink an image vertically.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Shrinkv(vshrink);
            </code>
            </example>
            <param name="vshrink">Vertical shrink factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Sign">
            <summary>
            Unit vector of pixel.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Sign();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Similarity(System.Nullable{System.Double},System.Nullable{System.Double},NetVips.GObject,System.Double[],System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Similarity transform of an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Similarity(scale: double, angle: double, interpolate: GObject, background: double[], odx: double, ody: double, idx: double, idy: double);
            </code>
            </example>
            <param name="scale">Scale by this factor.</param>
            <param name="angle">Rotate anticlockwise by this many degrees.</param>
            <param name="interpolate">Interpolate pixels with this.</param>
            <param name="background">Background value.</param>
            <param name="odx">Horizontal output displacement.</param>
            <param name="ody">Vertical output displacement.</param>
            <param name="idx">Horizontal input displacement.</param>
            <param name="idy">Vertical input displacement.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Sines(System.Int32,System.Int32,System.Nullable{System.Boolean},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Make a 2D sine wave.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Sines(width, height, uchar: bool, hfreq: double, vfreq: double);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <param name="hfreq">Horizontal spatial frequency.</param>
            <param name="vfreq">Vertical spatial frequency.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Smartcrop(System.Int32,System.Int32,System.String)">
            <summary>
            Extract an area from an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = input.Smartcrop(width, height, interesting: string);
            </code>
            </example>
            <param name="width">Width of extract area.</param>
            <param name="height">Height of extract area.</param>
            <param name="interesting">How to measure interestingness.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Sobel">
            <summary>
            Sobel edge detector.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Sobel();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Spcor(NetVips.Image)">
            <summary>
            Spatial correlation.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Spcor(@ref);
            </code>
            </example>
            <param name="ref">Input reference image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Spectrum">
            <summary>
            Make displayable power spectrum.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Spectrum();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SRGB2HSV">
            <summary>
            Transform sRGB to HSV.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.SRGB2HSV();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SRGB2scRGB">
            <summary>
            Convert an sRGB image to scRGB.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.SRGB2scRGB();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Stats">
            <summary>
            Find many image stats.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Stats();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Stdif(System.Int32,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Statistical difference.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Stdif(width, height, s0: double, b: double, m0: double, a: double);
            </code>
            </example>
            <param name="width">Window width in pixels.</param>
            <param name="height">Window height in pixels.</param>
            <param name="s0">New deviation.</param>
            <param name="b">Weight of new deviation.</param>
            <param name="m0">New mean.</param>
            <param name="a">Weight of new mean.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Subsample(System.Int32,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Subsample an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = input.Subsample(xfac, yfac, point: bool);
            </code>
            </example>
            <param name="xfac">Horizontal subsample factor.</param>
            <param name="yfac">Vertical subsample factor.</param>
            <param name="point">Point sample.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Subtract(NetVips.Image)">
            <summary>
            Subtract two images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = left.Subtract(right);
            </code>
            </example>
            <param name="right">Right-hand image argument.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Sum(NetVips.Image[])">
            <summary>
            Sum an array of images.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Sum(@in);
            </code>
            </example>
            <param name="in">Array of input images.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Svgload(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load SVG with rsvg.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Svgload(filename, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Svgload(System.String,System.Int32@,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load SVG with rsvg.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Svgload(filename, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SvgloadBuffer(System.Byte[],System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load SVG with rsvg.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.SvgloadBuffer(buffer, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SvgloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load SVG with rsvg.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.SvgloadBuffer(buffer, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SvgloadSource(NetVips.Source,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load svg from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.SvgloadSource(source, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SvgloadStream(System.IO.Stream,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load svg from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.SvgloadStream(stream, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SvgloadSource(NetVips.Source,System.Int32@,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load svg from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.SvgloadSource(source, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.SvgloadStream(System.IO.Stream,System.Int32@,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load svg from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.SvgloadStream(stream, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="dpi">Render at this DPI.</param>
            <param name="scale">Scale output by this factor.</param>
            <param name="unlimited">Allow SVG of any size.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Switch(NetVips.Image[])">
            <summary>
            Find the index of the first non-zero pixel in tests.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Switch(tests);
            </code>
            </example>
            <param name="tests">Table of images to test.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.System(System.String,NetVips.Image[],System.String,System.String)">
            <summary>
            Run an external command.
            </summary>
            <example>
            <code language="lang-csharp">
            NetVips.Image.System(cmdFormat, @in: Image[], outFormat: string, inFormat: string);
            </code>
            </example>
            <param name="cmdFormat">Command to run.</param>
            <param name="in">Array of input images.</param>
            <param name="outFormat">Format for output filename.</param>
            <param name="inFormat">Format for input filename.</param>
        </member>
        <member name="M:NetVips.Image.System(System.String,NetVips.Image@,NetVips.Image[],System.String,System.String)">
            <summary>
            Run an external command.
            </summary>
            <example>
            <code language="lang-csharp">
            NetVips.Image.System(cmdFormat, out var @out, @in: Image[], outFormat: string, inFormat: string);
            </code>
            </example>
            <param name="cmdFormat">Command to run.</param>
            <param name="out">Output image.</param>
            <param name="in">Array of input images.</param>
            <param name="outFormat">Format for output filename.</param>
            <param name="inFormat">Format for input filename.</param>
        </member>
        <member name="M:NetVips.Image.System(System.String,NetVips.Image@,System.String@,NetVips.Image[],System.String,System.String)">
            <summary>
            Run an external command.
            </summary>
            <example>
            <code language="lang-csharp">
            NetVips.Image.System(cmdFormat, out var @out, out var log, @in: Image[], outFormat: string, inFormat: string);
            </code>
            </example>
            <param name="cmdFormat">Command to run.</param>
            <param name="out">Output image.</param>
            <param name="log">Command log.</param>
            <param name="in">Array of input images.</param>
            <param name="outFormat">Format for output filename.</param>
            <param name="inFormat">Format for input filename.</param>
        </member>
        <member name="M:NetVips.Image.Text(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String)">
            <summary>
            Make a text image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Text(text, font: string, width: int, height: int, align: string, dpi: int, justify: bool, spacing: int, fontfile: string);
            </code>
            </example>
            <param name="text">Text to render.</param>
            <param name="font">Font to render with.</param>
            <param name="width">Maximum image width in pixels.</param>
            <param name="height">Maximum image height in pixels.</param>
            <param name="align">Align on the low, centre or high edge.</param>
            <param name="dpi">DPI to render at.</param>
            <param name="justify">Justify lines.</param>
            <param name="spacing">Line spacing.</param>
            <param name="fontfile">Load this font file.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Text(System.String,System.Int32@,System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.String)">
            <summary>
            Make a text image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Text(text, out var autofitDpi, font: string, width: int, height: int, align: string, dpi: int, justify: bool, spacing: int, fontfile: string);
            </code>
            </example>
            <param name="text">Text to render.</param>
            <param name="autofitDpi">DPI selected by autofit.</param>
            <param name="font">Font to render with.</param>
            <param name="width">Maximum image width in pixels.</param>
            <param name="height">Maximum image height in pixels.</param>
            <param name="align">Align on the low, centre or high edge.</param>
            <param name="dpi">DPI to render at.</param>
            <param name="justify">Justify lines.</param>
            <param name="spacing">Line spacing.</param>
            <param name="fontfile">Load this font file.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Thumbnail(System.String,System.Int32,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.String,System.String)">
            <summary>
            Generate thumbnail from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Thumbnail(filename, width, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
            </code>
            </example>
            <param name="filename">Filename to read from.</param>
            <param name="width">Size to this width.</param>
            <param name="height">Size to this height.</param>
            <param name="size">Only upsize, only downsize, or both.</param>
            <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
            <param name="crop">Reduce to fill target rectangle, then crop.</param>
            <param name="linear">Reduce in linear light.</param>
            <param name="importProfile">Fallback import profile.</param>
            <param name="exportProfile">Fallback export profile.</param>
            <param name="intent">Rendering intent.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ThumbnailBuffer(System.Byte[],System.Int32,System.String,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.String,System.String)">
            <summary>
            Generate thumbnail from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.ThumbnailBuffer(buffer, width, optionString: string, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="width">Size to this width.</param>
            <param name="optionString">Options that are passed on to the underlying loader.</param>
            <param name="height">Size to this height.</param>
            <param name="size">Only upsize, only downsize, or both.</param>
            <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
            <param name="crop">Reduce to fill target rectangle, then crop.</param>
            <param name="linear">Reduce in linear light.</param>
            <param name="importProfile">Fallback import profile.</param>
            <param name="exportProfile">Fallback export profile.</param>
            <param name="intent">Rendering intent.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ThumbnailImage(System.Int32,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.String,System.String)">
            <summary>
            Generate thumbnail from image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.ThumbnailImage(width, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
            </code>
            </example>
            <param name="width">Size to this width.</param>
            <param name="height">Size to this height.</param>
            <param name="size">Only upsize, only downsize, or both.</param>
            <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
            <param name="crop">Reduce to fill target rectangle, then crop.</param>
            <param name="linear">Reduce in linear light.</param>
            <param name="importProfile">Fallback import profile.</param>
            <param name="exportProfile">Fallback export profile.</param>
            <param name="intent">Rendering intent.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ThumbnailSource(NetVips.Source,System.Int32,System.String,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.String,System.String)">
            <summary>
            Generate thumbnail from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.ThumbnailSource(source, width, optionString: string, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="width">Size to this width.</param>
            <param name="optionString">Options that are passed on to the underlying loader.</param>
            <param name="height">Size to this height.</param>
            <param name="size">Only upsize, only downsize, or both.</param>
            <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
            <param name="crop">Reduce to fill target rectangle, then crop.</param>
            <param name="linear">Reduce in linear light.</param>
            <param name="importProfile">Fallback import profile.</param>
            <param name="exportProfile">Fallback export profile.</param>
            <param name="intent">Rendering intent.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.ThumbnailStream(System.IO.Stream,System.Int32,System.String,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.String,System.String,System.String)">
            <summary>
            Generate thumbnail from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.ThumbnailStream(stream, width, optionString: string, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="width">Size to this width.</param>
            <param name="optionString">Options that are passed on to the underlying loader.</param>
            <param name="height">Size to this height.</param>
            <param name="size">Only upsize, only downsize, or both.</param>
            <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
            <param name="crop">Reduce to fill target rectangle, then crop.</param>
            <param name="linear">Reduce in linear light.</param>
            <param name="importProfile">Fallback import profile.</param>
            <param name="exportProfile">Fallback export profile.</param>
            <param name="intent">Rendering intent.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Tiffload(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Tiffload(filename, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Tiffload(System.String,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Tiffload(filename, out var flags, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.TiffloadBuffer(System.Byte[],System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.TiffloadBuffer(buffer, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.TiffloadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.TiffloadBuffer(buffer, out var flags, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.TiffloadSource(NetVips.Source,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.TiffloadSource(source, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.TiffloadStream(System.IO.Stream,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.TiffloadStream(stream, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.TiffloadSource(NetVips.Source,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.TiffloadSource(source, out var flags, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.TiffloadStream(System.IO.Stream,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load tiff from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.TiffloadStream(stream, out var flags, page: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the image.</param>
            <param name="n">Load this many pages.</param>
            <param name="autorotate">Rotate image using orientation tag.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Tiffsave(System.String,System.String,System.Nullable{System.Int32},System.String,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to tiff file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Tiffsave(filename, compression: string, q: int, predictor: string, profile: string, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, squash: bool, resunit: string, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: string, level: int, lossless: bool, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="compression">Compression for this file.</param>
            <param name="q">Q factor.</param>
            <param name="predictor">Compression prediction.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="tile">Write a tiled tiff.</param>
            <param name="tileWidth">Tile width in pixels.</param>
            <param name="tileHeight">Tile height in pixels.</param>
            <param name="pyramid">Write a pyramidal tiff.</param>
            <param name="miniswhite">Use 0 for white in 1-bit images.</param>
            <param name="squash">Squash images down to 1 bit.</param>
            <param name="resunit">Resolution unit.</param>
            <param name="xres">Horizontal resolution in pixels/mm.</param>
            <param name="yres">Vertical resolution in pixels/mm.</param>
            <param name="bigtiff">Write a bigtiff image.</param>
            <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
            <param name="regionShrink">Method to shrink regions.</param>
            <param name="level">ZSTD compression level.</param>
            <param name="lossless">Enable WEBP lossless mode.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.TiffsaveBuffer(System.String,System.Nullable{System.Int32},System.String,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to tiff buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.TiffsaveBuffer(compression: string, q: int, predictor: string, profile: string, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, squash: bool, resunit: string, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: string, level: int, lossless: bool, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="compression">Compression for this file.</param>
            <param name="q">Q factor.</param>
            <param name="predictor">Compression prediction.</param>
            <param name="profile">ICC profile to embed.</param>
            <param name="tile">Write a tiled tiff.</param>
            <param name="tileWidth">Tile width in pixels.</param>
            <param name="tileHeight">Tile height in pixels.</param>
            <param name="pyramid">Write a pyramidal tiff.</param>
            <param name="miniswhite">Use 0 for white in 1-bit images.</param>
            <param name="squash">Squash images down to 1 bit.</param>
            <param name="resunit">Resolution unit.</param>
            <param name="xres">Horizontal resolution in pixels/mm.</param>
            <param name="yres">Vertical resolution in pixels/mm.</param>
            <param name="bigtiff">Write a bigtiff image.</param>
            <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
            <param name="regionShrink">Method to shrink regions.</param>
            <param name="level">ZSTD compression level.</param>
            <param name="lossless">Enable WEBP lossless mode.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.Tilecache(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Cache an image as a set of tiles.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Tilecache(tileWidth: int, tileHeight: int, maxTiles: int, access: string, threaded: bool, persistent: bool);
            </code>
            </example>
            <param name="tileWidth">Tile width in pixels.</param>
            <param name="tileHeight">Tile height in pixels.</param>
            <param name="maxTiles">Maximum number of tiles to cache.</param>
            <param name="access">Expected access pattern.</param>
            <param name="threaded">Allow threaded access.</param>
            <param name="persistent">Keep cache between evaluations.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Tonelut(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Build a look-up table.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Tonelut(inMax: int, outMax: int, lb: double, lw: double, ps: double, pm: double, ph: double, s: double, m: double, h: double);
            </code>
            </example>
            <param name="inMax">Size of LUT to build.</param>
            <param name="outMax">Maximum value in output LUT.</param>
            <param name="lb">Lowest value in output.</param>
            <param name="lw">Highest value in output.</param>
            <param name="ps">Position of shadow.</param>
            <param name="pm">Position of mid-tones.</param>
            <param name="ph">Position of highlights.</param>
            <param name="s">Adjust shadows by this much.</param>
            <param name="m">Adjust mid-tones by this much.</param>
            <param name="h">Adjust highlights by this much.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Transpose3d(System.Nullable{System.Int32})">
            <summary>
            Transpose3d an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Transpose3d(pageHeight: int);
            </code>
            </example>
            <param name="pageHeight">Height of each input page.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Unpremultiply(System.Nullable{System.Double},System.Nullable{System.Int32})">
            <summary>
            Unpremultiply image alpha.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Unpremultiply(maxAlpha: double, alphaBand: int);
            </code>
            </example>
            <param name="maxAlpha">Maximum value of alpha channel.</param>
            <param name="alphaBand">Unpremultiply with this alpha.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Vipsload(System.String,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load vips from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Vipsload(filename, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Vipsload(System.String,System.Int32@,System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load vips from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Vipsload(filename, out var flags, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Vipssave(System.String,System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to vips file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Vipssave(filename, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Webpload(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Webpload(filename, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Webpload(System.String,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from file.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Webpload(filename, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="filename">Filename to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.WebploadBuffer(System.Byte[],System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.WebploadBuffer(buffer, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.WebploadBuffer(System.Byte[],System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.WebploadBuffer(buffer, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="buffer">Buffer to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.WebploadSource(NetVips.Source,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.WebploadSource(source, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.WebploadStream(System.IO.Stream,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.WebploadStream(stream, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.WebploadSource(NetVips.Source,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from source.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.WebploadSource(source, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="source">Source to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.WebploadStream(System.IO.Stream,System.Int32@,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Double},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean})">
            <summary>
            Load webp from stream.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.WebploadStream(stream, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
            </code>
            </example>
            <param name="stream">Stream to load from.</param>
            <param name="flags">Flags for this file.</param>
            <param name="page">Load this page from the file.</param>
            <param name="n">Load this many pages.</param>
            <param name="scale">Scale factor on load.</param>
            <param name="memory">Force open via memory.</param>
            <param name="access">Required access pattern for this file.</param>
            <param name="fail">Fail on first error.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Webpsave(System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to webp file.
            </summary>
            <example>
            <code language="lang-csharp">
            in.Webpsave(filename, q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="filename">Filename to save to.</param>
            <param name="q">Q factor.</param>
            <param name="lossless">enable lossless compression.</param>
            <param name="preset">Preset for lossy compression.</param>
            <param name="smartSubsample">Enable high quality chroma subsampling.</param>
            <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
            <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
            <param name="minSize">Optimise for minium size.</param>
            <param name="kmin">Minimum number of frames between key frames.</param>
            <param name="kmax">Maximum number of frames between key frames.</param>
            <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.WebpsaveBuffer(System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to webp buffer.
            </summary>
            <example>
            <code language="lang-csharp">
            byte[] buffer = in.WebpsaveBuffer(q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="q">Q factor.</param>
            <param name="lossless">enable lossless compression.</param>
            <param name="preset">Preset for lossy compression.</param>
            <param name="smartSubsample">Enable high quality chroma subsampling.</param>
            <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
            <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
            <param name="minSize">Optimise for minium size.</param>
            <param name="kmin">Minimum number of frames between key frames.</param>
            <param name="kmax">Maximum number of frames between key frames.</param>
            <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
            <returns>An array of bytes.</returns>
        </member>
        <member name="M:NetVips.Image.WebpsaveTarget(NetVips.Target,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to webp target.
            </summary>
            <example>
            <code language="lang-csharp">
            in.WebpsaveTarget(target, q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="target">Target to save to.</param>
            <param name="q">Q factor.</param>
            <param name="lossless">enable lossless compression.</param>
            <param name="preset">Preset for lossy compression.</param>
            <param name="smartSubsample">Enable high quality chroma subsampling.</param>
            <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
            <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
            <param name="minSize">Optimise for minium size.</param>
            <param name="kmin">Minimum number of frames between key frames.</param>
            <param name="kmax">Maximum number of frames between key frames.</param>
            <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.WebpsaveStream(System.IO.Stream,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.String,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Double[],System.Nullable{System.Int32})">
            <summary>
            Save image to webp stream.
            </summary>
            <example>
            <code language="lang-csharp">
            in.WebpsaveStream(stream, q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
            </code>
            </example>
            <param name="stream">Stream to save to.</param>
            <param name="q">Q factor.</param>
            <param name="lossless">enable lossless compression.</param>
            <param name="preset">Preset for lossy compression.</param>
            <param name="smartSubsample">Enable high quality chroma subsampling.</param>
            <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
            <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
            <param name="minSize">Optimise for minium size.</param>
            <param name="kmin">Minimum number of frames between key frames.</param>
            <param name="kmax">Maximum number of frames between key frames.</param>
            <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
            <param name="strip">Strip all metadata from image.</param>
            <param name="background">Background value.</param>
            <param name="pageHeight">Set page height for multipage save.</param>
        </member>
        <member name="M:NetVips.Image.Worley(System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Make a worley noise image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Worley(width, height, cellSize: int);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="cellSize">Size of Worley cells.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Wrap(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Wrap image origin.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Wrap(x: int, y: int);
            </code>
            </example>
            <param name="x">Left edge of input in output.</param>
            <param name="y">Top edge of input in output.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Xyz(System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Make an image where pixel values are coordinates.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Xyz(width, height, csize: int, dsize: int, esize: int);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="csize">Size of third dimension.</param>
            <param name="dsize">Size of fourth dimension.</param>
            <param name="esize">Size of fifth dimension.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.XYZ2CMYK">
            <summary>
            Transform XYZ to CMYK.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.XYZ2CMYK();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.XYZ2Lab(System.Double[])">
            <summary>
            Transform XYZ to Lab.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.XYZ2Lab(temp: double[]);
            </code>
            </example>
            <param name="temp">Colour temperature.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.XYZ2scRGB">
            <summary>
            Transform XYZ to scRGB.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.XYZ2scRGB();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.XYZ2Yxy">
            <summary>
            Transform XYZ to Yxy.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.XYZ2Yxy();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Yxy2XYZ">
            <summary>
            Transform Yxy to XYZ.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = in.Yxy2XYZ();
            </code>
            </example>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Zone(System.Int32,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Make a zone plate.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = NetVips.Image.Zone(width, height, uchar: bool);
            </code>
            </example>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="uchar">Output an unsigned char image.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.Zoom(System.Int32,System.Int32)">
            <summary>
            Zoom an image.
            </summary>
            <example>
            <code language="lang-csharp">
            Image @out = input.Zoom(xfac, yfac);
            </code>
            </example>
            <param name="xfac">Horizontal zoom factor.</param>
            <param name="yfac">Vertical zoom factor.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="P:NetVips.Image.Width">
            <summary>
            Image width in pixels
            </summary>
        </member>
        <member name="P:NetVips.Image.Height">
            <summary>
            Image height in pixels
            </summary>
        </member>
        <member name="P:NetVips.Image.Bands">
            <summary>
            Number of bands in image
            </summary>
        </member>
        <member name="P:NetVips.Image.Format">
            <summary>
            Pixel format in image
            </summary>
        </member>
        <member name="P:NetVips.Image.Coding">
            <summary>
            Pixel coding
            </summary>
        </member>
        <member name="P:NetVips.Image.Interpretation">
            <summary>
            Pixel interpretation
            </summary>
        </member>
        <member name="P:NetVips.Image.Xoffset">
            <summary>
            Horizontal offset of origin
            </summary>
        </member>
        <member name="P:NetVips.Image.Yoffset">
            <summary>
            Vertical offset of origin
            </summary>
        </member>
        <member name="P:NetVips.Image.Xres">
            <summary>
            Horizontal resolution in pixels/mm
            </summary>
        </member>
        <member name="P:NetVips.Image.Yres">
            <summary>
            Vertical resolution in pixels/mm
            </summary>
        </member>
        <member name="P:NetVips.Image.Filename">
            <summary>
            Image filename
            </summary>
        </member>
        <member name="M:NetVips.Image.op_Addition(NetVips.Image,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> + <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Addition(System.Double,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> + <paramref name="right"/>.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Addition(NetVips.Image,System.Double)">
            <summary>
            This operation calculates <paramref name="left"/> + <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Addition(System.Double[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> + <paramref name="right"/>.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Addition(NetVips.Image,System.Double[])">
            <summary>
            This operation calculates <paramref name="left"/> + <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Addition(System.Int32[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> + <paramref name="right"/>.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Addition(NetVips.Image,System.Int32[])">
            <summary>
            This operation calculates <paramref name="left"/> + <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Subtraction(NetVips.Image,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> - <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Subtraction(System.Double,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> - <paramref name="right"/>.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Subtraction(NetVips.Image,System.Double)">
            <summary>
            This operation calculates <paramref name="left"/> - <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Subtraction(System.Double[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> - <paramref name="right"/>.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Subtraction(NetVips.Image,System.Double[])">
            <summary>
            This operation calculates <paramref name="left"/> - <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Subtraction(System.Int32[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> - <paramref name="right"/>.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Subtraction(NetVips.Image,System.Int32[])">
            <summary>
            This operation calculates <paramref name="left"/> - <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Multiply(NetVips.Image,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> * <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Multiply(System.Double,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> * <paramref name="right"/>.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Multiply(NetVips.Image,System.Double)">
            <summary>
            This operation calculates <paramref name="left"/> * <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Multiply(System.Double[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> * <paramref name="right"/>.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Multiply(NetVips.Image,System.Double[])">
            <summary>
            This operation calculates <paramref name="left"/> * <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Multiply(System.Int32[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> * <paramref name="right"/>.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Multiply(NetVips.Image,System.Int32[])">
            <summary>
            This operation calculates <paramref name="left"/> * <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Division(NetVips.Image,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> / <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Division(System.Double,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> / <paramref name="right"/>.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Division(NetVips.Image,System.Double)">
            <summary>
            This operation calculates <paramref name="left"/> / <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Division(System.Double[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> / <paramref name="right"/>.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Division(NetVips.Image,System.Double[])">
            <summary>
            This operation calculates <paramref name="left"/> / <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Division(System.Int32[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> / <paramref name="right"/>.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Division(NetVips.Image,System.Int32[])">
            <summary>
            This operation calculates <paramref name="left"/> / <paramref name="right"/>.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Modulus(NetVips.Image,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> % <paramref name="right"/>
            (remainder after integer division).
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Modulus(System.Double,NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> % <paramref name="right"/>
            (remainder after integer division).
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Modulus(NetVips.Image,System.Double)">
            <summary>
            This operation calculates <paramref name="left"/> % <paramref name="right"/>
            (remainder after integer division).
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Modulus(System.Double[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> % <paramref name="right"/>
            (remainder after integer division).
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Modulus(NetVips.Image,System.Double[])">
            <summary>
            This operation calculates <paramref name="left"/> % <paramref name="right"/>
            (remainder after integer division).
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Modulus(System.Int32[],NetVips.Image)">
            <summary>
            This operation calculates <paramref name="left"/> % <paramref name="right"/>
            (remainder after integer division).
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Modulus(NetVips.Image,System.Int32[])">
            <summary>
            This operation calculates <paramref name="left"/> % <paramref name="right"/>
            (remainder after integer division).
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseAnd(NetVips.Image,NetVips.Image)">
            <summary>
            This operation computes the logical bitwise AND of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseAnd(System.Double,NetVips.Image)">
            <summary>
            This operation computes the logical bitwise AND of its operands.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseAnd(NetVips.Image,System.Double)">
            <summary>
            This operation computes the logical bitwise AND of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseAnd(System.Double[],NetVips.Image)">
            <summary>
            This operation computes the logical bitwise AND of its operands.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseAnd(NetVips.Image,System.Double[])">
            <summary>
            This operation computes the logical bitwise AND of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseAnd(System.Int32[],NetVips.Image)">
            <summary>
            This operation computes the logical bitwise AND of its operands.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseAnd(NetVips.Image,System.Int32[])">
            <summary>
            This operation computes the logical bitwise AND of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseOr(NetVips.Image,NetVips.Image)">
            <summary>
            This operation computes the bitwise OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseOr(System.Double,NetVips.Image)">
            <summary>
            This operation computes the bitwise OR of its operands.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseOr(NetVips.Image,System.Double)">
            <summary>
            This operation computes the bitwise OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseOr(System.Double[],NetVips.Image)">
            <summary>
            This operation computes the bitwise OR of its operands.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseOr(NetVips.Image,System.Double[])">
            <summary>
            This operation computes the bitwise OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseOr(System.Int32[],NetVips.Image)">
            <summary>
            This operation computes the bitwise OR of its operands.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_BitwiseOr(NetVips.Image,System.Int32[])">
            <summary>
            This operation computes the bitwise OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_ExclusiveOr(NetVips.Image,NetVips.Image)">
            <summary>
            This operation computes the bitwise exclusive-OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_ExclusiveOr(System.Double,NetVips.Image)">
            <summary>
            This operation computes the bitwise exclusive-OR of its operands.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_ExclusiveOr(NetVips.Image,System.Double)">
            <summary>
            This operation computes the bitwise exclusive-OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_ExclusiveOr(System.Double[],NetVips.Image)">
            <summary>
            This operation computes the bitwise exclusive-OR of its operands.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_ExclusiveOr(NetVips.Image,System.Double[])">
            <summary>
            This operation computes the bitwise exclusive-OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_ExclusiveOr(System.Int32[],NetVips.Image)">
            <summary>
            This operation computes the bitwise exclusive-OR of its operands.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_ExclusiveOr(NetVips.Image,System.Int32[])">
            <summary>
            This operation computes the bitwise exclusive-OR of its operands.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LeftShift(NetVips.Image,System.Int32)">
            <summary>
            This operation shifts its first operand left by the number of bits specified by its second operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">The number of bits.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_RightShift(NetVips.Image,System.Int32)">
            <summary>
            This operation shifts its first operand right by the number of bits specified by its second operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">The number of bits.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Equality(System.Double,NetVips.Image)">
            <summary>
            This operation compares two images on equality.
            </summary>
            <param name="left">Left double constant to compare.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Equality(System.Double[],NetVips.Image)">
            <summary>
            This operation compares two images on equality.
            </summary>
            <param name="left">Left double array to compare.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Equality(System.Int32[],NetVips.Image)">
            <summary>
            This operation compares two images on equality.
            </summary>
            <param name="left">Left integer array to compare.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Inequality(System.Double,NetVips.Image)">
            <summary>
            This operation compares two images on inequality.
            </summary>
            <param name="left">Left double constant to compare.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Inequality(System.Double[],NetVips.Image)">
            <summary>
            This operation compares two images on inequality.
            </summary>
            <param name="left">Left double array to compare.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_Inequality(System.Int32[],NetVips.Image)">
            <summary>
            This operation compares two images on inequality.
            </summary>
            <param name="left">Left integer array to compare.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/> to compare.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThan(NetVips.Image,NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThan(System.Double,NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than the right operand.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThan(NetVips.Image,System.Double)">
            <summary>
            This operation compares if the left operand is less than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThan(System.Double[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than the right operand.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThan(NetVips.Image,System.Double[])">
            <summary>
            This operation compares if the left operand is less than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThan(System.Int32[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than the right operand.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThan(NetVips.Image,System.Int32[])">
            <summary>
            This operation compares if the left operand is less than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThan(NetVips.Image,NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThan(System.Double,NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than the right operand.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThan(NetVips.Image,System.Double)">
            <summary>
            This operation compares if the left operand is greater than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThan(System.Double[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than the right operand.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThan(NetVips.Image,System.Double[])">
            <summary>
            This operation compares if the left operand is greater than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThan(System.Int32[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than the right operand.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThan(NetVips.Image,System.Int32[])">
            <summary>
            This operation compares if the left operand is greater than the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThanOrEqual(NetVips.Image,NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThanOrEqual(System.Double,NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than or equal to the right operand.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThanOrEqual(NetVips.Image,System.Double)">
            <summary>
            This operation compares if the left operand is less than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThanOrEqual(System.Double[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than or equal to the right operand.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThanOrEqual(NetVips.Image,System.Double[])">
            <summary>
            This operation compares if the left operand is less than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThanOrEqual(System.Int32[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is less than or equal to the right operand.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_LessThanOrEqual(NetVips.Image,System.Int32[])">
            <summary>
            This operation compares if the left operand is less than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThanOrEqual(NetVips.Image,NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThanOrEqual(System.Double,NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than or equal to the right operand.
            </summary>
            <param name="left">Left double constant.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThanOrEqual(NetVips.Image,System.Double)">
            <summary>
            This operation compares if the left operand is greater than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double constant.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThanOrEqual(System.Double[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than or equal to the right operand.
            </summary>
            <param name="left">Left double array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThanOrEqual(NetVips.Image,System.Double[])">
            <summary>
            This operation compares if the left operand is greater than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right double array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThanOrEqual(System.Int32[],NetVips.Image)">
            <summary>
            This operation compares if the left operand is greater than or equal to the right operand.
            </summary>
            <param name="left">Left integer array.</param>
            <param name="right">Right <see cref="T:NetVips.Image"/>.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_GreaterThanOrEqual(NetVips.Image,System.Int32[])">
            <summary>
            This operation compares if the left operand is greater than or equal to the right operand.
            </summary>
            <param name="left">Left <see cref="T:NetVips.Image"/>.</param>
            <param name="right">Right integer array.</param>
            <returns>A new <see cref="T:NetVips.Image"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_True(NetVips.Image)">
            <summary>
            Returns a value indicating whether a given <see cref="T:NetVips.Image"/> is definitely <see langword="true"/>.
            </summary>
            <param name="image">The image to check.</param>
            <returns><see langword="true"/> if <paramref name="image"/> is definitely <see langword="true"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.Image.op_False(NetVips.Image)">
            <summary>
            Returns a value indicating whether a given <see cref="T:NetVips.Image"/> is definitely <see langword="false"/>.
            </summary>
            <param name="image">The image to check.</param>
            <returns><see langword="true"/> if <paramref name="image"/> is definitely <see langword="false"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:NetVips.Interpolate">
            <summary>
            Make interpolators for operators like <see cref="M:NetVips.Image.Affine(System.Double[],NetVips.GObject,System.Int32[],System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.String)"/>.
            </summary>
        </member>
        <member name="M:NetVips.Interpolate.NewFromName(System.String)">
            <summary>
            Make a new interpolator by name.
            </summary>
            <remarks>
            Make a new interpolator from the libvips class nickname. For example:
            <code language="lang-csharp">
            var inter = Interpolate.NewFromName("bicubic");
            </code>
            You can get a list of all supported interpolators from the command-line
            with:
            <code language="lang-shell">
            $ vips -l interpolate
            </code>
            See for example <see cref="M:NetVips.Image.Affine(System.Double[],NetVips.GObject,System.Int32[],System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Double[],System.String)"/>.
            </remarks>
            <param name="name">libvips class nickname.</param>
            <returns>A new <see cref="T:NetVips.Interpolate"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to make a new interpolator from <paramref name="name"/>.</exception>
        </member>
        <member name="T:NetVips.Introspect">
            <summary>
            Build introspection data for operations.
            </summary>
            <remarks>
            Make an operation, introspect it, and build a structure representing
            everything we know about it.
            </remarks>
        </member>
        <member name="F:NetVips.Introspect.IntrospectCache">
            <summary>
            A cache for introspection data.
            </summary>
        </member>
        <member name="T:NetVips.Introspect.Argument">
            <summary>
            An object structure that encapsulates the metadata
            required to specify arguments.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.Argument.Name">
            <summary>
            Name of this argument.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.Argument.Flags">
            <summary>
            Flags for this argument.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.Argument.Type">
            <summary>
            The GType for this argument.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.MemberX">
            <summary>
            The first required input image or <see langword="null"/>.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.RequiredInput">
            <summary>
            The required input for this operation.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.OptionalInput">
            <summary>
            The optional input for this operation.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.RequiredOutput">
            <summary>
            The required output for this operation.
            </summary>
        </member>
        <member name="F:NetVips.Introspect.OptionalOutput">
            <summary>
            The optional output for this operation.
            </summary>
        </member>
        <member name="M:NetVips.Introspect.#ctor(System.String)">
            <summary>
            Build introspection data for a specified operation name.
            </summary>
            <param name="operationName">The operation name to introspect.</param>
        </member>
        <member name="M:NetVips.Introspect.GetArgs(NetVips.Operation)">
            <summary>
            Get all arguments for an operation.
            </summary>
            <remarks>
            Not quick! Try to call this infrequently.
            </remarks>
            <param name="operation">Operation to lookup.</param>
            <returns>Arguments for the operation.</returns>
        </member>
        <member name="M:NetVips.Introspect.Get(System.String)">
            <summary>
            Get introspection data for a specified operation name.
            </summary>
            <param name="operationName">Operation name.</param>
            <returns>Introspection data.</returns>
        </member>
        <member name="T:NetVips.Log">
            <summary>
            Wrapper for message logging functions.
            </summary>
        </member>
        <member name="T:NetVips.Log.LogDelegate">
            <summary>
            Specifies the prototype of log handler functions.
            </summary>
            <param name="logDomain">The log domain of the message.</param>
            <param name="logLevel">The log level of the message (including the fatal and recursion flags).</param>
            <param name="message">The message to process.</param>
        </member>
        <member name="M:NetVips.Log.SetLogHandler(System.String,NetVips.Enums.LogLevelFlags,NetVips.Log.LogDelegate)">
            <summary>
            Sets the log handler for a domain and a set of log levels.
            </summary>
            <param name="logDomain">The log domain, or <see langword="null"/> for the default "" application domain.</param>
            <param name="flags">The log levels to apply the log handler for.</param>
            <param name="logFunc">The log handler function.</param>
            <returns>The id of the handler.</returns>
        </member>
        <member name="M:NetVips.Log.RemoveLogHandler(System.String,System.UInt32)">
            <summary>
            Removes the log handler.
            </summary>
            <param name="logDomain">The log domain.</param>
            <param name="handlerId">The id of the handler, which was returned in <see cref="M:NetVips.Log.SetLogHandler(System.String,NetVips.Enums.LogLevelFlags,NetVips.Log.LogDelegate)"/>.</param>
        </member>
        <member name="M:NetVips.Log.SetAlwaysFatal(NetVips.Enums.LogLevelFlags)">
            <summary>
            Sets the message levels which are always fatal, in any log domain.
            When a message with any of these levels is logged the program terminates.
            </summary>
            <param name="fatalMask">The mask containing bits set for each level of error which is to be fatal.</param>
            <returns>The old fatal mask.</returns>
        </member>
        <member name="M:NetVips.Log.SetAlwaysFatal(System.String,NetVips.Enums.LogLevelFlags)">
            <summary>
            Sets the log levels which are fatal in the given domain.
            </summary>
            <param name="logDomain">The log domain.</param>
            <param name="fatalMask">The new fatal mask.</param>
            <returns>The old fatal mask for the log domain.</returns>
        </member>
        <member name="M:NetVips.Log.PrintLogFunction(System.String,NetVips.Enums.LogLevelFlags,System.String)">
            <summary>
            Common logging method.
            </summary>
            <remarks>
            Sample usage:
            <code language="lang-csharp">
            // Print the messages for the NULL domain
            var logFunc = new LogFunc(Log.PrintLogFunction);
            Log.SetLogHandler(null, Enums.LogLevelFlags.All, logFunc);
            </code>
            </remarks>
            <param name="domain">The log domain of the message.</param>
            <param name="level">The log level of the message (including the fatal and recursion flags).</param>
            <param name="message">The message to process.</param>
        </member>
        <member name="M:NetVips.Log.PrintTraceLogFunction(System.String,NetVips.Enums.LogLevelFlags,System.String)">
            <summary>
            Common logging method.
            </summary>
            <remarks>
            Sample usage:
            <code language="lang-csharp">
            // Print messages and stack trace for vips critical messages
            var logFunc = new LogFunc(Log.PrintTraceLogFunction);
            Log.SetLogHandler("VIPS", Enums.LogLevelFlags.Critical, logFunc);
            </code>
            </remarks>
            <param name="domain">The log domain of the message.</param>
            <param name="level">The log level of the message (including the fatal and recursion flags).</param>
            <param name="message">The message to process.</param>
        </member>
        <member name="T:NetVips.ModuleInitializer">
            <summary>
            Used by the ModuleInit. All code inside the Initialize method is ran as soon as the assembly is loaded.
            </summary>
        </member>
        <member name="F:NetVips.ModuleInitializer.VipsInitialized">
            <summary>
            Is vips initialized?
            </summary>
        </member>
        <member name="F:NetVips.ModuleInitializer.Exception">
            <summary>
            Contains the exception when initialization of libvips fails.
            </summary>
        </member>
        <member name="F:NetVips.ModuleInitializer.Version">
            <summary>
            Could contain the version number of libvips in an 3-bytes integer.
            </summary>
        </member>
        <member name="M:NetVips.ModuleInitializer.Initialize">
            <summary>
            Initializes the module.
            </summary>
        </member>
        <member name="T:NetVips.NetVips">
            <summary>
            Basic utility stuff.
            </summary>
        </member>
        <member name="M:NetVips.NetVips.Init">
            <summary>
            Init() starts up the world of VIPS.
            </summary>
            <remarks>
            This function will be automatically called by <see cref="M:NetVips.ModuleInitializer.Initialize"/>
            once the assembly is loaded. You should only call this method in your own program if the
            <see cref="T:NetVips.ModuleInitializer"/> fails to initialize libvips.
            </remarks>
            <returns><see langword="true"/> if successful started; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.NetVips.LeakSet(System.Boolean)">
            <summary>
            Enable or disable libvips leak checking.
            </summary>
            <remarks>
            With this enabled, libvips will check for object and area leaks on exit.
            Enabling this option will make libvips run slightly more slowly.
            </remarks>
            <param name="leak">Bool indicating if leak checking should be turned on.</param>
        </member>
        <member name="M:NetVips.NetVips.ProfileSet(System.Boolean)">
            <summary>
            Enable or disable libvips profile recording.
            </summary>
            <remarks>
            If set, vips will record profiling information, and dump it on program
            exit. These profiles can be analysed with the `vipsprofile` program.
            </remarks>
            <param name="profile">Bool indicating if profile recording should be turned on.</param>
        </member>
        <member name="M:NetVips.NetVips.CacheSetMax(System.Int32)">
            <summary>
            Set the maximum number of operations libvips will cache.
            </summary>
            <param name="max">Maximum number of operations.</param>
        </member>
        <member name="M:NetVips.NetVips.CacheSetMaxMem(System.UInt64)">
            <summary>
            Limit the operation cache by memory use.
            </summary>
            <param name="maxMem">Maximum memory use.</param>
        </member>
        <member name="M:NetVips.NetVips.CacheSetMaxFiles(System.Int32)">
            <summary>
            Limit the operation cache by number of open files.
            </summary>
            <param name="maxFiles">Maximum open files.</param>
        </member>
        <member name="M:NetVips.NetVips.CacheSetTrace(System.Boolean)">
            <summary>
            Turn on libvips cache tracing.
            </summary>
            <param name="trace">Bool indicating if tracing should be turned on.</param>
        </member>
        <member name="M:NetVips.NetVips.ConcurrencySet(System.Int32)">
            <summary>
            Set the size of the pools of worker threads vips uses for image
            evaluation.
            </summary>
            <param name="concurrency">The size of the pools of worker threads vips uses
            for image evaluation.</param>
        </member>
        <member name="M:NetVips.NetVips.ConcurrencyGet">
            <summary>
            Returns the number of worker threads that vips uses for image
            evaluation.
            </summary>
            <returns>The number of worker threads.</returns>
        </member>
        <member name="M:NetVips.NetVips.VectorSet(System.Boolean)">
            <summary>
            Enable or disable SIMD and the run-time compiler.
            </summary>
            <remarks>
            This can give a nice speed-up, but can also be unstable on
            some systems or with some versions of the run-time compiler.
            </remarks>
            <param name="enabled">Bool indicating if SIMD and the run-time
            compiler should be turned on.</param>
        </member>
        <member name="M:NetVips.NetVips.MemoryStats">
            <summary>
            Returns an array with:
            - the number of active allocations.
            - the number of bytes currently allocated via `vips_malloc()` and friends.
            - the number of open files.
            </summary>
            <returns>An array with memory stats. Handy for debugging / leak testing.</returns>
        </member>
        <member name="M:NetVips.NetVips.MemoryHigh">
            <summary>
            Returns the largest number of bytes simultaneously allocated via vips_tracked_malloc().
            Handy for estimating max memory requirements for a program.
            </summary>
            <returns>The largest number of bytes simultaneously allocated.</returns>
        </member>
        <member name="M:NetVips.NetVips.Version(System.Int32,System.Boolean)">
            <summary>
            Get the major, minor or patch version number of the libvips library.
            </summary>
            <param name="flag">Pass 0 to get the major version number, 1 to get minor, 2 to get patch.</param>
            <param name="fromModule"><see langword="true"/> to get this value from the pre-initialized
            <see cref="F:NetVips.ModuleInitializer.Version"/> variable.</param>
            <returns>The version number.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="flag"/> is not in range.</exception>
        </member>
        <member name="M:NetVips.NetVips.AtLeastLibvips(System.Int32,System.Int32,System.Int32)">
            <summary>
            Is this at least libvips major.minor[.patch]?
            </summary>
            <param name="x">Major component.</param>
            <param name="y">Minor component.</param>
            <param name="z">Patch component.</param>
            <returns><see langword="true"/> if at least libvips major.minor[.patch]; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.NetVips.GetSuffixes">
            <summary>
            Get a list of all the filename suffixes supported by libvips.
            </summary>
            <remarks>
            At least libvips 8.8 is needed.
            </remarks>
            <returns>An array of strings or <see langword="null"/>.</returns>
        </member>
        <member name="M:NetVips.NetVips.ReportLeak">
            <summary>
            Reports leaks (hopefully there are none) it also tracks and reports peak memory use.
            </summary>
        </member>
        <member name="M:NetVips.NetVips.PathFilename7(System.String)">
            <summary>
            For testing only.
            </summary>
            <param name="path">Path to split.</param>
            <returns>The filename part of a vips7 path.</returns>
        </member>
        <member name="M:NetVips.NetVips.PathMode7(System.String)">
            <summary>
            For testing only.
            </summary>
            <param name="path">Path to split.</param>
            <returns>The mode part of a vips7 path.</returns>
        </member>
        <member name="M:NetVips.NetVips.VipsInterpretationGetType">
            <summary>
            For testing only.
            </summary>
        </member>
        <member name="M:NetVips.NetVips.VipsOperationFlagsGetType">
            <summary>
            For testing only.
            </summary>
        </member>
        <member name="M:NetVips.NetVips.TypeFind(System.String,System.String)">
            <summary>
            Get the GType for a name.
            </summary>
            <remarks>
            Looks up the GType for a nickname. Types below basename in the type
            hierarchy are searched.
            </remarks>
            <param name="basename">Name of base class.</param>
            <param name="nickname">Search for a class with this nickname.</param>
            <returns>The GType of the class, or <see cref="F:System.IntPtr.Zero"/> if the class is not found.</returns>
        </member>
        <member name="M:NetVips.NetVips.TypeName(System.IntPtr)">
            <summary>
            Return the name for a GType.
            </summary>
            <param name="type">Type to return name for.</param>
            <returns>Type name.</returns>
        </member>
        <member name="M:NetVips.NetVips.NicknameFind(System.IntPtr)">
            <summary>
            Return the nickname for a GType.
            </summary>
            <param name="type">Type to return nickname for.</param>
            <returns>Nickname.</returns>
        </member>
        <member name="M:NetVips.NetVips.GetOperations">
            <summary>
            Get a list of operations available within the libvips library.
            </summary>
            <remarks>
            This can be useful for documentation generators.
            </remarks>
            <returns>A list of operations.</returns>
        </member>
        <member name="M:NetVips.NetVips.GetEnums">
            <summary>
            Get a list of enums available within the libvips library.
            </summary>
            <returns>A list of enums.</returns>
        </member>
        <member name="M:NetVips.NetVips.ValuesForEnum(System.IntPtr)">
            <summary>
            Get all values for a enum (GType).
            </summary>
            <param name="type">Type to return enum values for.</param>
            <returns>A list of values.</returns>
        </member>
        <member name="M:NetVips.NetVips.TypeFromName(System.String)">
            <summary>
            Return the GType for a name.
            </summary>
            <param name="name">Type name to lookup.</param>
            <returns>Corresponding type ID or <see cref="F:System.IntPtr.Zero"/>.</returns>
        </member>
        <member name="M:NetVips.NetVips.FundamentalType(System.IntPtr)">
            <summary>
            Extract the fundamental type ID portion.
            </summary>
            <param name="type">A valid type ID.</param>
            <returns>Fundamental type ID.</returns>
        </member>
        <member name="M:NetVips.NetVips.Free(System.IntPtr)">
            <summary>
            Frees the memory pointed to by <paramref name="mem"/>.
            </summary>
            <remarks>
            This is needed for <see cref="M:NetVips.Image.WriteToMemory(System.UInt64@)"/>.
            </remarks>
            <param name="mem">The memory to free.</param>
        </member>
        <member name="T:NetVips.Operation">
            <summary>
            Wrap a <see cref="T:NetVips.Internal.VipsOperation"/> object.
            </summary>
        </member>
        <member name="M:NetVips.Operation.#ctor(System.IntPtr)">
            <inheritdoc cref="T:NetVips.VipsObject"/>
        </member>
        <member name="M:NetVips.Operation.NewFromName(System.String)">
            <summary>
            Create a new <see cref="T:NetVips.Internal.VipsOperation"/> with the specified nickname.
            </summary>
            <remarks>
            You'll need to set any arguments and build the operation before you can use it. See
            <see cref="M:NetVips.Operation.Call(System.String,NetVips.VOption,NetVips.Image,System.Object[])"/> for a higher-level way to make new operations.
            </remarks>
            <param name="operationName">Nickname of operation to create.</param>
            <returns>The new operation.</returns>
            <exception cref="T:NetVips.VipsException">If the operation doesn't exist.</exception>
        </member>
        <member name="M:NetVips.Operation.Set(System.IntPtr,NetVips.Enums.ArgumentFlags,System.String,System.Object)">
            <summary>
            Set a GObject property. The value is converted to the property type, if possible.
            </summary>
            <param name="gtype">The GType of the property.</param>
            <param name="flags">See <see cref="T:NetVips.Enums.ArgumentFlags"/>.</param>
            <param name="name">The name of the property to set.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NetVips.Operation.Set(System.IntPtr,NetVips.Enums.ArgumentFlags,NetVips.Image,System.String,System.Object)">
            <summary>
            Set a GObject property. The value is converted to the property type, if possible.
            </summary>
            <param name="name">The name of the property to set.</param>
            <param name="flags">See <see cref="T:NetVips.Enums.ArgumentFlags"/>.</param>
            <param name="matchImage">A <see cref="T:NetVips.Image"/> used as guide.</param>
            <param name="value">The value.</param>
            <param name="gtype">The GType of the property.</param>
        </member>
        <member name="M:NetVips.Operation.GetFlags">
            <summary>
            Lookup the set of flags for this operation.
            </summary>
            <returns>Flags for this operation.</returns>
        </member>
        <member name="M:NetVips.Operation.Call(System.String,System.Object[])">
            <summary>
            Call a libvips operation.
            </summary>
            <remarks>
            Use this method to call any libvips operation. For example:
            <code language="lang-csharp">
            var blackImage = Operation.Call("black", 10, 10);
            </code>
            See the Introduction for notes on how this works.
            </remarks>
            <param name="operationName">Operation name.</param>
            <param name="args">An arbitrary number and variety of arguments.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:NetVips.Operation.Call(System.String,NetVips.VOption,System.Object[])">
            <summary>
            Call a libvips operation.
            </summary>
            <remarks>
            Use this method to call any libvips operation. For example:
            <code language="lang-csharp">
            var blackImage = Operation.Call("black", 10, 10);
            </code>
            See the Introduction for notes on how this works.
            </remarks>
            <param name="operationName">Operation name.</param>
            <param name="kwargs">Optional arguments.</param>
            <param name="args">An arbitrary number and variety of arguments.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:NetVips.Operation.Call(System.String,NetVips.VOption,NetVips.Image,System.Object[])">
            <summary>
            Call a libvips operation.
            </summary>
            <remarks>
            Use this method to call any libvips operation. For example:
            <code language="lang-csharp">
            var blackImage = Operation.Call("black", 10, 10);
            </code>
            See the Introduction for notes on how this works.
            </remarks>
            <param name="operationName">Operation name.</param>
            <param name="kwargs">Optional arguments.</param>
            <param name="matchImage">A <see cref="T:NetVips.Image"/> used as guide.</param>
            <param name="args">An arbitrary number and variety of arguments.</param>
            <returns>A new object.</returns>
        </member>
        <member name="T:NetVips.Region">
            <summary>
            Wrap a <see cref="T:NetVips.Internal.VipsRegion"/> object.
            </summary>
            <remarks>
            A region is a small part of an image. You use regions to read pixels
            out of images without storing the entire image in memory.
            At least libvips 8.8 is needed.
            </remarks>
        </member>
        <member name="M:NetVips.Region.New(NetVips.Image)">
            <summary>
            Make a region on an image.
            </summary>
            <param name="image"><see cref="T:NetVips.Image"/> to create this region on.</param>
            <returns>A new <see cref="T:NetVips.Region"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to make a new region on <paramref name="image"/>.</exception>
        </member>
        <member name="P:NetVips.Region.Width">
            <summary>
            Width of pixels held by region.
            </summary>
        </member>
        <member name="P:NetVips.Region.Height">
            <summary>
            Height of pixels held by region.
            </summary>
        </member>
        <member name="M:NetVips.Region.Fetch(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fetch an area of pixels.
            </summary>
            <param name="left">Left edge of area to fetch.</param>
            <param name="top">Top edge of area to fetch.</param>
            <param name="width">Width of area to fetch.</param>
            <param name="height">Height of area to fetch.</param>
            <returns>An array of bytes filled with pixel data.</returns>
        </member>
        <member name="T:NetVips.Source">
            <summary>
            An input connection.
            </summary>
        </member>
        <member name="F:NetVips.Source._dataHandle">
            <summary>
            Secret ref for <see cref="M:NetVips.Source.NewFromMemory(System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:NetVips.Source.#ctor(System.IntPtr)">
            <inheritdoc cref="T:NetVips.Connection"/>
        </member>
        <member name="M:NetVips.Source.NewFromDescriptor(System.Int32)">
             <summary>
             Make a new source from a file descriptor (a small integer).
             </summary>
             <remarks>
             Make a new source that is attached to the descriptor. For example:
             <code language="lang-csharp">
             var source = Source.NewFromDescriptor(0);
             </code>
             Makes a descriptor attached to stdin.
            
             You can pass this source to (for example) <see cref="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
             </remarks>
             <param name="descriptor">Read from this file descriptor.</param>
             <returns>A new <see cref="T:NetVips.Source"/>.</returns>
             <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Source"/> from <paramref name="descriptor"/>.</exception>
        </member>
        <member name="M:NetVips.Source.NewFromFile(System.String)">
            <summary>
            Make a new source from a filename.
            </summary>
            <remarks>
            Make a new source that is attached to the named file. For example:
            <code language="lang-csharp">
            var source = Source.NewFromFile("myfile.jpg");
            </code>
            You can pass this source to (for example) <see cref="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="filename">Read from this filename.</param>
            <returns>A new <see cref="T:NetVips.Source"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Source"/> from <paramref name="filename"/>.</exception>
        </member>
        <member name="M:NetVips.Source.NewFromMemory(System.Byte[])">
            <summary>
            Make a new source from a memory object.
            </summary>
            <remarks>
            Make a new source that is attached to the memory object. For example:
            <code language="lang-csharp">
            var source = Source.NewFromMemory(data);
            </code>
            You can pass this source to (for example) <see cref="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="data">The memory object.</param>
            <returns>A new <see cref="T:NetVips.Source"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Source"/> from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Source.NewFromMemory(System.String)">
            <summary>
            Make a new source from a memory object.
            </summary>
            <remarks>
            Make a new source that is attached to the memory object. For example:
            <code language="lang-csharp">
            var source = Source.NewFromMemory(data);
            </code>
            You can pass this source to (for example) <see cref="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="data">The memory object.</param>
            <returns>A new <see cref="T:NetVips.Source"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Source"/> from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Source.NewFromMemory(System.Char[])">
            <summary>
            Make a new source from a memory object.
            </summary>
            <remarks>
            Make a new source that is attached to the memory object. For example:
            <code language="lang-csharp">
            var source = Source.NewFromMemory(data);
            </code>
            You can pass this source to (for example) <see cref="M:NetVips.Image.NewFromSource(NetVips.Source,System.String,System.String,System.Nullable{System.Boolean},NetVips.VOption)"/>.
            </remarks>
            <param name="data">The memory object.</param>
            <returns>A new <see cref="T:NetVips.Source"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Source"/> from <paramref name="data"/>.</exception>
        </member>
        <member name="M:NetVips.Source.Dispose(System.Boolean)">
            <inheritdoc cref="T:NetVips.GObject"/>
        </member>
        <member name="T:NetVips.SourceCustom">
            <summary>
            An source you can connect delegates to implement behaviour.
            </summary>
        </member>
        <member name="T:NetVips.SourceCustom.ReadDelegate">
            <summary>
            A read delegate.
            </summary>
            <remarks>
            The interface is exactly as <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>. The handler is given a number
            of bytes to fetch, and should return a bytes-like object containing up
            to that number of bytes. If there is no more data available, it should
            return <see langword="0"/>.
            </remarks>
            <param name="buffer">An array of bytes.</param>
            <param name="length">The maximum number of bytes to be read.</param>
            <returns>The total number of bytes read into the buffer.</returns>
        </member>
        <member name="T:NetVips.SourceCustom.SeekDelegate">
             <summary>
             A seek delegate.
             </summary>
             <remarks>
             The interface is exactly as <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)"/>. The handler is given
             parameters for offset and whence with the same meanings. It also returns the
             new position within the current source.
            
             Seek handlers are optional. If you do not set one, your source will be
             treated as unseekable and libvips will do extra caching.
             </remarks>
             <param name="offset">A byte offset relative to the <paramref name="origin"/>
             parameter.</param>
             <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the
             reference point used to obtain the new position.</param>
             <returns>The new position within the current source.</returns>
        </member>
        <member name="E:NetVips.SourceCustom.OnRead">
            <summary>
            Attach a read delegate.
            </summary>
        </member>
        <member name="E:NetVips.SourceCustom.OnSeek">
            <summary>
            Attach a seek delegate.
            </summary>
        </member>
        <member name="M:NetVips.SourceCustom.#ctor">
            <inheritdoc cref="T:NetVips.Source"/>
        </member>
        <member name="M:NetVips.SourceCustom.ReadHandler(System.IntPtr,System.IntPtr,System.Int64,System.IntPtr)">
            <summary>
            The internal read handler.
            </summary>
            <param name="sourcePtr">The underlying pointer to the source.</param>
            <param name="buffer">A pointer to an array of bytes.</param>
            <param name="length">The maximum number of bytes to be read.</param>
            <param name="userDataPtr">User data associated with the source.</param>
            <returns>The total number of bytes read into the buffer.</returns>
        </member>
        <member name="M:NetVips.SourceCustom.SeekHandler(System.IntPtr,System.Int64,System.Int32,System.IntPtr)">
            <summary>
            The internal seek handler.
            </summary>
            <param name="sourcePtr">The underlying pointer to the source.</param>
            <param name="offset">A byte offset relative to the <paramref name="whence"/>
            parameter.</param>
            <param name="whence">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the
            reference point used to obtain the new position.</param>
            <param name="userDataPtr">User data associated with the source.</param>
            <returns>The new position within the current source.</returns>
        </member>
        <member name="T:NetVips.SourceStream">
            <summary>
            An source connected to a readable <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:NetVips.SourceStream._stream">
            <summary>
            Read from this stream.
            </summary>
        </member>
        <member name="F:NetVips.SourceStream._startPosition">
            <summary>
            The start position within the stream.
            </summary>
        </member>
        <member name="M:NetVips.SourceStream.#ctor(System.IO.Stream)">
            <inheritdoc cref="T:NetVips.SourceCustom"/>
        </member>
        <member name="M:NetVips.SourceStream.NewFromStream(System.IO.Stream)">
            <summary>
            Create a <see cref="T:NetVips.SourceStream"/> attached to an <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">Read from this stream.</param>
            <returns>A new <see cref="T:NetVips.SourceStream"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="stream"/> is not readable.</exception>
        </member>
        <member name="M:NetVips.SourceStream.Read(System.Byte[],System.Int32)">
            <summary>
            Attach a read handler.
            </summary>
            <param name="buffer">An array of bytes.</param>
            <param name="length">The maximum number of bytes to be read.</param>
            <returns>The total number of bytes read into the buffer.</returns>
        </member>
        <member name="M:NetVips.SourceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Attach a seek handler.
            </summary>
            <param name="offset">A byte offset relative to the <paramref name="origin"/>
            parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the
            reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
        </member>
        <member name="T:NetVips.Target">
            <summary>
            An output connection.
            </summary>
        </member>
        <member name="M:NetVips.Target.#ctor(System.IntPtr)">
            <inheritdoc cref="T:NetVips.Connection"/>
        </member>
        <member name="M:NetVips.Target.NewToDescriptor(System.Int32)">
             <summary>
             Make a new target to write to a file descriptor (a small integer).
             </summary>
             <remarks>
             Make a new target that is attached to the descriptor. For example:
             <code language="lang-csharp">
             var target = Target.NewToDescriptor(1);
             </code>
             Makes a descriptor attached to stdout.
            
             You can pass this target to (for example) <see cref="M:NetVips.Image.WriteToTarget(NetVips.Target,System.String,NetVips.VOption)"/>.
             </remarks>
             <param name="descriptor">Write to this file descriptor.</param>
             <returns>A new <see cref="T:NetVips.Target"/>.</returns>
             <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Target"/> from <paramref name="descriptor"/>.</exception>
        </member>
        <member name="M:NetVips.Target.NewToFile(System.String)">
            <summary>
            Make a new target to write to a file.
            </summary>
            <remarks>
            Make a new target that will write to the named file. For example:
            <code language="lang-csharp">
            var target = Target.NewToFile("myfile.jpg");
            </code>
            You can pass this target to (for example) <see cref="M:NetVips.Image.WriteToTarget(NetVips.Target,System.String,NetVips.VOption)"/>.
            </remarks>
            <param name="filename">Write to this this file.</param>
            <returns>A new <see cref="T:NetVips.Target"/>.</returns>
            <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Target"/> from <paramref name="filename"/>.</exception>
        </member>
        <member name="M:NetVips.Target.NewToMemory">
             <summary>
             Make a new target to write to an area of memory.
             </summary>
             <remarks>
             Make a new target that will write to memory. For example:
             <code language="lang-csharp">
             var target = Target.NewToMemory();
             </code>
             You can pass this target to (for example) <see cref="M:NetVips.Image.WriteToTarget(NetVips.Target,System.String,NetVips.VOption)"/>.
            
             After writing to the target, fetch the bytes from the target object with:
             <code language="lang-csharp">
             var bytes = target.Get("blob");
             </code>
             </remarks>
             <returns>A new <see cref="T:NetVips.Target"/>.</returns>
             <exception cref="T:NetVips.VipsException">If unable to create a new <see cref="T:NetVips.Target"/>.</exception>
        </member>
        <member name="T:NetVips.TargetCustom">
            <summary>
            An target you can connect delegates to implement behaviour.
            </summary>
        </member>
        <member name="T:NetVips.TargetCustom.WriteDelegate">
            <summary>
            A write delegate.
            </summary>
            <remarks>
            The interface is the same as <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/>, so the handler is
            given a bytes-like object to write. However, the handler MUST return the number
            of bytes written.
            </remarks>
            <param name="buffer">An array of bytes.</param>
            <param name="length">The number of bytes to be written to the current target.</param>
            <returns>The total number of bytes written to the target.</returns>
        </member>
        <member name="T:NetVips.TargetCustom.FinishDelegate">
            <summary>
            A finish delegate.
            </summary>
            <remarks>
            This optional handler is called at the end of write. It should do any
            cleaning up, if necessary.
            </remarks>
        </member>
        <member name="E:NetVips.TargetCustom.OnWrite">
            <summary>
            Attach a write delegate.
            </summary>
        </member>
        <member name="E:NetVips.TargetCustom.OnFinish">
            <summary>
            Attach a finish delegate.
            </summary>
        </member>
        <member name="M:NetVips.TargetCustom.#ctor">
            <inheritdoc cref="T:NetVips.Target"/>
        </member>
        <member name="M:NetVips.TargetCustom.WriteHandler(System.IntPtr,System.Byte[],System.Int32,System.IntPtr)">
            <summary>
            The internal write handler.
            </summary>
            <param name="targetPtr">The underlying pointer to the target.</param>
            <param name="buffer">An array of bytes.</param>
            <param name="length">The number of bytes to be written to the current target.</param>
            <param name="userDataPtr">User data associated with the target.</param>
            <returns>The total number of bytes written to the target.</returns>
        </member>
        <member name="M:NetVips.TargetCustom.FinishHandler(System.IntPtr,System.IntPtr)">
            <summary>
            The internal finish handler.
            </summary>
            <param name="targetPtr">The underlying pointer to the target.</param>
            <param name="userDataPtr">User data associated with the target.</param>
        </member>
        <member name="T:NetVips.TargetStream">
            <summary>
            An source connected to a writable <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:NetVips.TargetStream._stream">
            <summary>
            Write to this stream.
            </summary>
        </member>
        <member name="M:NetVips.TargetStream.#ctor(System.IO.Stream)">
            <inheritdoc cref="T:NetVips.GObject"/>
        </member>
        <member name="M:NetVips.TargetStream.NewFromStream(System.IO.Stream)">
            <summary>
            Create a <see cref="T:NetVips.TargetStream"/> which will output to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">Write to this stream.</param>
            <returns>A new <see cref="T:NetVips.TargetStream"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="stream"/> is not writable.</exception>
        </member>
        <member name="M:NetVips.TargetStream.Write(System.Byte[],System.Int32)">
            <summary>
            Attach a write handler.
            </summary>
            <param name="buffer">An array of bytes.</param>
            <param name="length">The number of bytes to be written to the current stream.</param>
            <returns>The total number of bytes written to the stream.</returns>
        </member>
        <member name="M:NetVips.TargetStream.Finish">
            <summary>
            Attach a finish handler.
            </summary>
        </member>
        <member name="T:NetVips.VipsBlob">
            <summary>
            Manage a <see cref="T:NetVips.Internal.VipsBlob"/>.
            </summary>
        </member>
        <member name="M:NetVips.VipsBlob.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:NetVips.VipsBlob"/> class
            with the specified pointer to wrap around.
            </summary>
            <param name="pointer">The pointer to wrap around.</param>
        </member>
        <member name="M:NetVips.VipsBlob.GetData(System.UIntPtr@)">
            <summary>
            Get the data from a <see cref="T:NetVips.Internal.VipsBlob"/>.
            </summary>
            <param name="length">Return number of bytes of data.</param>
            <returns>A <see cref="T:System.IntPtr"/> containing the data.</returns>
        </member>
        <member name="M:NetVips.VipsBlob.ReleaseHandle">
            <summary>
            Decreases the reference count of the blob.
            When its reference count drops to 0, the blob is finalized (i.e. its memory is freed).
            </summary>
            <returns><see langword="true"/> if the handle is released successfully; otherwise,
            in the event of a catastrophic failure, <see langword="false"/>.</returns>
        </member>
        <member name="P:NetVips.VipsBlob.IsInvalid">
            <summary>
            Gets a value indicating whether the handle is invalid.
            </summary>
            <returns><see langword="true"/> if the handle is not valid; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="P:NetVips.VipsBlob.Length">
            <summary>
            Get the number of bytes of data.
            </summary>
        </member>
        <member name="P:NetVips.VipsBlob.RefCount">
            <summary>
            Get the reference count of the blob. Handy for debugging.
            </summary>
        </member>
        <member name="T:NetVips.VipsException">
            <summary>
            Our own exception class which handles the libvips error buffer.
            </summary>
        </member>
        <member name="M:NetVips.VipsException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetVips.VipsException"/> class.
            </summary>
        </member>
        <member name="M:NetVips.VipsException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NetVips.VipsException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NetVips.VipsException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NetVips.VipsException"/> class with a specified error message
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="inner">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        </member>
        <member name="T:NetVips.VipsObject">
            <summary>
            Manage a <see cref="T:NetVips.Internal.VipsObject"/>.
            </summary>
        </member>
        <member name="M:NetVips.VipsObject.#ctor(System.IntPtr)">
            <inheritdoc cref="T:NetVips.GObject"/>
        </member>
        <member name="M:NetVips.VipsObject.PrintAll">
            <summary>
            Print a table of all active libvips objects. Handy for debugging.
            </summary>
        </member>
        <member name="M:NetVips.VipsObject.GetPspec(System.String)">
            <summary>
            slow! eeeeew.
            </summary>
            <param name="name">Arg to fetch.</param>
            <returns>The pspec for this arg.</returns>
        </member>
        <member name="M:NetVips.VipsObject.GetTypeOf(System.String)">
            <summary>
            Get the GType of a GObject property.
            </summary>
            <param name="name">The name of the GType to get the type of.</param>
            <returns>A new instance of <see cref="T:System.IntPtr"/> initialized to the GType or
            <see cref="F:System.IntPtr.Zero"/> if the property does not exist.</returns>
        </member>
        <member name="M:NetVips.VipsObject.GetBlurb(System.String)">
            <summary>
            Get the blurb for a GObject property.
            </summary>
            <param name="name">Arg to fetch.</param>
            <returns>The blurb.</returns>
        </member>
        <member name="M:NetVips.VipsObject.Get(System.String)">
            <summary>
            Get a GObject property.
            </summary>
            <remarks>
            The value of the property is converted to a C# value.
            </remarks>
            <param name="name">Arg to fetch.</param>
            <returns>The GObject property.</returns>
        </member>
        <member name="M:NetVips.VipsObject.Set(System.IntPtr,System.String,System.Object)">
            <summary>
            Set a GObject property. The value is converted to the property type, if possible.
            </summary>
            <param name="name">The name of the property to set.</param>
            <param name="value">The value.</param>
            <param name="gtype">The GType of the property.</param>
        </member>
        <member name="M:NetVips.VipsObject.SetString(System.String)">
            <summary>
            Set a series of properties using a string.
            </summary>
            <remarks>
            For example:
            "fred=12, tile"
            "[fred=12]"
            </remarks>
            <param name="stringOptions">Arguments as a string.</param>
            <returns><see langword="true"/> on success; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.VipsObject.GetDescription">
            <summary>
            Get the description of a GObject.
            </summary>
            <returns>The description of a GObject.</returns>
        </member>
        <member name="T:NetVips.GTimer">
            <summary>
            Records a start time, and counts microseconds elapsed since that time.
            </summary>
        </member>
        <member name="F:NetVips.GTimer.Start">
            <summary>
            Monotonic start time, in microseconds.
            </summary>
        </member>
        <member name="F:NetVips.GTimer.End">
            <summary>
            Monotonic end time, in microseconds.
            </summary>
        </member>
        <member name="F:NetVips.GTimer.Active">
            <summary>
            Is the timer currently active?
            </summary>
        </member>
        <member name="T:NetVips.VipsProgress">
            <summary>
            Struct we keep a record of execution time in. Passed to eval signal so
            it can assess progress.
            </summary>
        </member>
        <member name="F:NetVips.VipsProgress.Im">
            <summary>
            Image we are part of.
            </summary>
        </member>
        <member name="F:NetVips.VipsProgress.Run">
            <summary>
            Time we have been running.
            </summary>
        </member>
        <member name="F:NetVips.VipsProgress.Eta">
            <summary>
            Estimated seconds of computation left.
            </summary>
        </member>
        <member name="F:NetVips.VipsProgress.TPels">
            <summary>
            Number of pels we expect to calculate.
            </summary>
        </member>
        <member name="F:NetVips.VipsProgress.NPels">
            <summary>
             Number of pels calculated so far.
            </summary>
        </member>
        <member name="F:NetVips.VipsProgress.Percent">
            <summary>
            Percent complete.
            </summary>
        </member>
        <member name="F:NetVips.VipsProgress.Start">
            <summary>
            Start time.
            </summary>
        </member>
        <member name="T:NetVips.VOption">
            <summary>
            This class wraps a <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            This is used to call functions with optional arguments. See <see cref="M:NetVips.Operation.Call(System.String,NetVips.VOption,System.Object[])"/>.
            </summary>
        </member>
        <member name="M:NetVips.VOption.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="F:NetVips.VOption._internalDictionary"/>.
            </summary>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2.Enumerator"/> structure for the <see cref="F:NetVips.VOption._internalDictionary"/>.</returns>
        </member>
        <member name="M:NetVips.VOption.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc cref="M:NetVips.VOption.GetEnumerator"/>
        </member>
        <member name="P:NetVips.VOption.Item(System.String)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns>The value associated with the specified key.</returns>
        </member>
        <member name="P:NetVips.VOption.Keys">
            <summary>
            Gets a collection containing the keys in the <see cref="F:NetVips.VOption._internalDictionary"/>.
            </summary>
        </member>
        <member name="P:NetVips.VOption.Count">
            <summary>
            Gets the number of key/value pairs contained in the <see cref="F:NetVips.VOption._internalDictionary"/>.
            </summary>
            <returns>The number of key/value pairs contained in the <see cref="F:NetVips.VOption._internalDictionary"/>.</returns>
        </member>
        <member name="M:NetVips.VOption.Add(System.String,System.Object)">
            <summary>
            Adds the specified key and value to the <see cref="F:NetVips.VOption._internalDictionary"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be null for reference types.</param>
        </member>
        <member name="M:NetVips.VOption.ContainsKey(System.String)">
            <summary>
            Determines whether the <see cref="F:NetVips.VOption._internalDictionary"/> contains the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="F:NetVips.VOption._internalDictionary"/>.</param>
            <returns><see langword="true"/> if the <see cref="F:NetVips.VOption._internalDictionary"/> contains an element with the specified key; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.VOption.Remove(System.String)">
            <summary>
            Removes the value with the specified key from the <see cref="F:NetVips.VOption._internalDictionary"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns><see langword="true"/> if the element is successfully found and removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:NetVips.VOption.TryGetValue(System.String,System.Object@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/> if the <see cref="F:NetVips.VOption._internalDictionary"/> contains an element with the specified key; otherwise, <see langword="false"/>.</returns>
        </member>
    </members>
</doc>
